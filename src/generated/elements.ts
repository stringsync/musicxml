/* eslint-disable @typescript-eslint/ban-types */
import * as operations from '../lib/operations';
import { XMLElement } from '../lib/schema';

export type WorkNumberAttributes = Record<string, unknown>;

export type WorkNumberContents = [string];

/**
 * The `<work-number>` element
 *
 * Parent element: `<work>`
 *
 * The `<work-number>` element specifies the number of a work, such as its opus number.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/work-number/}
 */
export class WorkNumber implements XMLElement<'work-number', WorkNumberAttributes, WorkNumberContents> {
  static readonly schema = { name: 'work-number', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = WorkNumber.schema;

  attributes: WorkNumberAttributes;
  contents: WorkNumberContents;

  constructor(opts?: { attributes?: Partial<WorkNumberAttributes>; contents?: WorkNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WorkNumber.schema);
    this.contents = opts?.contents ?? operations.zero(WorkNumber.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type WorkTitleAttributes = Record<string, unknown>;

export type WorkTitleContents = [string];

/**
 * The `<work-title>` element
 *
 * Parent element: `<work>`
 *
 * The `<work-title>` element specifies the title of a work, not including its opus or other work number.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/work-title/}
 */
export class WorkTitle implements XMLElement<'work-title', WorkTitleAttributes, WorkTitleContents> {
  static readonly schema = { name: 'work-title', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = WorkTitle.schema;

  attributes: WorkTitleAttributes;
  contents: WorkTitleContents;

  constructor(opts?: { attributes?: Partial<WorkTitleAttributes>; contents?: WorkTitleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WorkTitle.schema);
    this.contents = opts?.contents ?? operations.zero(WorkTitle.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type OpusAttributes = {
  /**
   * The href attribute provides the data that allows an application to find a remote resource or resource
   * fragment. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-locators)
   */
  'xlink:href': string;
  /**
   * The actuate attribute is used to communicate the desired timing of traversal from the starting resource to the
   * ending resource. The default value is onRequest. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-behaviors)
   */
  'xlink:actuate': 'none' | 'onRequest' | 'onLoad' | 'other' | null;
  /**
   * The role attribute indicates a property of the link. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-semantics)
   */
  'xlink:role': string | null;
  /**
   * The show attribute is used to communicate the desired presentation of the ending resource on traversal from the
   * starting resource. The default value is replace. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-behaviors)
   */
  'xlink:show': 'none' | 'new' | 'replace' | 'embed' | 'other' | null;
  /**
   * The title attribute describes the meaning of a link or resource in a human-readable fashion. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-semantics)
   */
  'xlink:title': string | null;
  /**
   * The type attribute identifies XLink element types. In MusicXML, the value is always simple. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-types)
   */
  'xlink:type': 'simple' | null;
};

export type OpusContents = [];

/**
 * The `<opus>` element
 *
 * Parent element: `<work>`
 *
 * The `<opus>` element represents a link to a MusicXML opus document that composes multiple MusicXML scores into a
 * collection.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/opus-reference/}
 */
export class Opus implements XMLElement<'opus', OpusAttributes, OpusContents> {
  static readonly schema = {
    name: 'opus',
    attributes: {
      'xlink:href': { type: 'required', value: { type: 'string' } },
      'xlink:actuate': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
      },
      'xlink:role': { type: 'optional', value: { type: 'string' } },
      'xlink:show': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
      },
      'xlink:title': { type: 'optional', value: { type: 'string' } },
      'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
    },
    contents: [],
  } as const;

  readonly schema = Opus.schema;

  attributes: OpusAttributes;
  contents: OpusContents;

  constructor(opts?: { attributes?: Partial<OpusAttributes>; contents?: OpusContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Opus.schema);
    this.contents = opts?.contents ?? operations.zero(Opus.schema.contents);
  }
  /** Gets @type {OpusAttributes['xlink:href']}. */
  getXlinkHref(): string {
    return this.attributes['xlink:href'];
  }
  /** Sets @type {OpusAttributes['xlink:href']}. */
  setXlinkHref(xlinkHref: string): Opus {
    this.attributes['xlink:href'] = xlinkHref;
    return this;
  }
  /** Gets @type {OpusAttributes['xlink:actuate']}. */
  getXlinkActuate(): 'none' | 'onRequest' | 'onLoad' | 'other' | null {
    return this.attributes['xlink:actuate'];
  }
  /** Sets @type {OpusAttributes['xlink:actuate']}. */
  setXlinkActuate(xlinkActuate: 'none' | 'onRequest' | 'onLoad' | 'other' | null): Opus {
    this.attributes['xlink:actuate'] = xlinkActuate;
    return this;
  }
  /** Gets @type {OpusAttributes['xlink:role']}. */
  getXlinkRole(): string | null {
    return this.attributes['xlink:role'];
  }
  /** Sets @type {OpusAttributes['xlink:role']}. */
  setXlinkRole(xlinkRole: string | null): Opus {
    this.attributes['xlink:role'] = xlinkRole;
    return this;
  }
  /** Gets @type {OpusAttributes['xlink:show']}. */
  getXlinkShow(): 'none' | 'new' | 'replace' | 'embed' | 'other' | null {
    return this.attributes['xlink:show'];
  }
  /** Sets @type {OpusAttributes['xlink:show']}. */
  setXlinkShow(xlinkShow: 'none' | 'new' | 'replace' | 'embed' | 'other' | null): Opus {
    this.attributes['xlink:show'] = xlinkShow;
    return this;
  }
  /** Gets @type {OpusAttributes['xlink:title']}. */
  getXlinkTitle(): string | null {
    return this.attributes['xlink:title'];
  }
  /** Sets @type {OpusAttributes['xlink:title']}. */
  setXlinkTitle(xlinkTitle: string | null): Opus {
    this.attributes['xlink:title'] = xlinkTitle;
    return this;
  }
  /** Gets @type {OpusAttributes['xlink:type']}. */
  getXlinkType(): 'simple' | null {
    return this.attributes['xlink:type'];
  }
  /** Sets @type {OpusAttributes['xlink:type']}. */
  setXlinkType(xlinkType: 'simple' | null): Opus {
    this.attributes['xlink:type'] = xlinkType;
    return this;
  }
}

export type WorkAttributes = Record<string, unknown>;

export type WorkContents = [WorkNumber | null, WorkTitle | null, Opus | null];

/**
 * The `<work>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * Works are optionally identified by number and title. The `<work>` element also may indicate a link to the `<opus>`
 * document that composes multiple scores into a collection.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/work/}
 */
export class Work implements XMLElement<'work', WorkAttributes, WorkContents> {
  static readonly schema = {
    name: 'work',
    attributes: {},
    contents: [
      { type: 'optional', value: WorkNumber },
      { type: 'optional', value: WorkTitle },
      { type: 'optional', value: Opus },
    ],
  } as const;

  readonly schema = Work.schema;

  attributes: WorkAttributes;
  contents: WorkContents;

  constructor(opts?: { attributes?: Partial<WorkAttributes>; contents?: WorkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Work.schema);
    this.contents = opts?.contents ?? operations.zero(Work.schema.contents);
  }

  /** Gets @type {WorkNumber | null}. */
  getWorkNumber(): WorkNumber | null {
    return this.contents[0];
  }
  /** Sets @type {WorkNumber | null}. */
  setWorkNumber(workNumber: WorkNumber | null): this {
    this.contents[0] = workNumber;
    return this;
  }
  /** Gets @type {WorkTitle | null}. */
  getWorkTitle(): WorkTitle | null {
    return this.contents[1];
  }
  /** Sets @type {WorkTitle | null}. */
  setWorkTitle(workTitle: WorkTitle | null): this {
    this.contents[1] = workTitle;
    return this;
  }
  /** Gets @type {Opus | null}. */
  getOpus(): Opus | null {
    return this.contents[2];
  }
  /** Sets @type {Opus | null}. */
  setOpus(opus: Opus | null): this {
    this.contents[2] = opus;
    return this;
  }
}

export type MovementNumberAttributes = Record<string, unknown>;

export type MovementNumberContents = [string];

/**
 * The `<movement-number>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<movement-number>` element specifies the number of a movement.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/movement-number/}
 */
export class MovementNumber implements XMLElement<'movement-number', MovementNumberAttributes, MovementNumberContents> {
  static readonly schema = { name: 'movement-number', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = MovementNumber.schema;

  attributes: MovementNumberAttributes;
  contents: MovementNumberContents;

  constructor(opts?: { attributes?: Partial<MovementNumberAttributes>; contents?: MovementNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MovementNumber.schema);
    this.contents = opts?.contents ?? operations.zero(MovementNumber.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MovementTitleAttributes = Record<string, unknown>;

export type MovementTitleContents = [string];

/**
 * The `<movement-title>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<movement-title>` element specifies the title of a movement, not including its number.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/movement-title/}
 */
export class MovementTitle implements XMLElement<'movement-title', MovementTitleAttributes, MovementTitleContents> {
  static readonly schema = { name: 'movement-title', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = MovementTitle.schema;

  attributes: MovementTitleAttributes;
  contents: MovementTitleContents;

  constructor(opts?: { attributes?: Partial<MovementTitleAttributes>; contents?: MovementTitleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MovementTitle.schema);
    this.contents = opts?.contents ?? operations.zero(MovementTitle.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type CreatorAttributes = {
  /**
   * Distinguishes different creative contributions. Thus there can be multiple `<creator>` elements within an
   * `<identification>` element. Standard values are composer, lyricist, and arranger. Other values may be used for
   * different types of creative roles. This attribute should usually be used even if there is just a single
   * `<creator>` element.
   */
  type: string | null;
};

export type CreatorContents = [string];

/**
 * The `<creator>` element
 *
 * Parent elements: `<score-part>`, `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<identification>` element contains basic metadata about the score. It includes information that may apply at a
 * score-wide, movement-wide, or part-wide level. The `<creator>`, `<rights>`, `<source>`, and `<relation>` elements are
 * based on Dublin Core.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/identification/}
 */
export class Creator implements XMLElement<'creator', CreatorAttributes, CreatorContents> {
  static readonly schema = {
    name: 'creator',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Creator.schema;

  attributes: CreatorAttributes;
  contents: CreatorContents;

  constructor(opts?: { attributes?: Partial<CreatorAttributes>; contents?: CreatorContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Creator.schema);
    this.contents = opts?.contents ?? operations.zero(Creator.schema.contents);
  }
  /** Gets @type {CreatorAttributes['type']}. */
  getType(): string | null {
    return this.attributes['type'];
  }
  /** Sets @type {CreatorAttributes['type']}. */
  setType(type: string | null): Creator {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type RightsAttributes = {
  /**
   * Standard type values are music, words, and arrangement, but other types may be used. This attribute is only
   * needed when there are multiple `<rights>` elements.
   */
  type: string | null;
};

export type RightsContents = [string];

/**
 * The `<rights>` element
 *
 * Parent element: `<identification>`
 *
 * The `<rights>` element contains copyright and other intellectual property notices. This is similar to the Dublin
 * Core rights element. Words, music, and derivatives can have different types, so multiple <rights> elements with
 * different type attributes are supported.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rights/}
 */
export class Rights implements XMLElement<'rights', RightsAttributes, RightsContents> {
  static readonly schema = {
    name: 'rights',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Rights.schema;

  attributes: RightsAttributes;
  contents: RightsContents;

  constructor(opts?: { attributes?: Partial<RightsAttributes>; contents?: RightsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rights.schema);
    this.contents = opts?.contents ?? operations.zero(Rights.schema.contents);
  }
  /** Gets @type {RightsAttributes['type']}. */
  getType(): string | null {
    return this.attributes['type'];
  }
  /** Sets @type {RightsAttributes['type']}. */
  setType(type: string | null): Rights {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type EncodingDateAttributes = Record<string, unknown>;

export type EncodingDateContents = [Date];

/**
 * The `<encoding-date>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<encoding-date>` element specifies the date of the digital encoding.
 */
export class EncodingDate implements XMLElement<'encoding-date', EncodingDateAttributes, EncodingDateContents> {
  static readonly schema = {
    name: 'encoding-date',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'yyyy-mm-dd', value: { type: 'date' } } }],
  } as const;

  readonly schema = EncodingDate.schema;

  attributes: EncodingDateAttributes;
  contents: EncodingDateContents;

  constructor(opts?: { attributes?: Partial<EncodingDateAttributes>; contents?: EncodingDateContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EncodingDate.schema);
    this.contents = opts?.contents ?? operations.zero(EncodingDate.schema.contents);
  }

  /** Gets @type {Date}. */
  getYyyyMmDd(): Date {
    return this.contents[0];
  }
  /** Sets @type {Date}. */
  setYyyyMmDd(yyyyMmDd: Date): this {
    this.contents[0] = yyyyMmDd;
    return this;
  }
}

export type EncoderAttributes = {
  /**
   * Standard values are music, words, and arrangement, but other types may be used. This attribute is only needed
   * when there are multiple `<encoder>` elements.
   */
  type: string | null;
};

export type EncoderContents = [string];

/**
 * The `<encoder>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<encoder>` element contains information about who did the digital encoding.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/encoder/}
 */
export class Encoder implements XMLElement<'encoder', EncoderAttributes, EncoderContents> {
  static readonly schema = {
    name: 'encoder',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Encoder.schema;

  attributes: EncoderAttributes;
  contents: EncoderContents;

  constructor(opts?: { attributes?: Partial<EncoderAttributes>; contents?: EncoderContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Encoder.schema);
    this.contents = opts?.contents ?? operations.zero(Encoder.schema.contents);
  }
  /** Gets @type {EncoderAttributes['type']}. */
  getType(): string | null {
    return this.attributes['type'];
  }
  /** Sets @type {EncoderAttributes['type']}. */
  setType(type: string | null): Encoder {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type SoftwareAttributes = Record<string, unknown>;

export type SoftwareContents = [string];

/**
 * The `<software>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<software>` element specifies what software created the digital encoding.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/software/}
 */
export class Software implements XMLElement<'software', SoftwareAttributes, SoftwareContents> {
  static readonly schema = { name: 'software', attributes: {}, contents: [{ type: 'string' }] } as const;

  readonly schema = Software.schema;

  attributes: SoftwareAttributes;
  contents: SoftwareContents;

  constructor(opts?: { attributes?: Partial<SoftwareAttributes>; contents?: SoftwareContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Software.schema);
    this.contents = opts?.contents ?? operations.zero(Software.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type EncodingDescriptionAttributes = Record<string, unknown>;

export type EncodingDescriptionContents = [string];

/**
 * The `<encoding-description>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<encoding-description>` element contains descriptive information about the digital encoding that is not
 * provided in the other `<encoding>` child elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/encoding-description/}
 */
export class EncodingDescription
  implements XMLElement<'encoding-description', EncodingDescriptionAttributes, EncodingDescriptionContents>
{
  static readonly schema = {
    name: 'encoding-description',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = EncodingDescription.schema;

  attributes: EncodingDescriptionAttributes;
  contents: EncodingDescriptionContents;

  constructor(opts?: { attributes?: Partial<EncodingDescriptionAttributes>; contents?: EncodingDescriptionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EncodingDescription.schema);
    this.contents = opts?.contents ?? operations.zero(EncodingDescription.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type SupportsAttributes = {
  /**
   * Indicates the element that is supported or not by the encoding.
   */
  element: string;
  /**
   * If yes, the absence of a particular element with a specified attribute or value is meaningful. It indicates
   * that this information is not present in the score. If no, the absence is not meaningful because the encoding
   * does not include this type of information.
   */
  type: 'yes' | 'no';
  /**
   * Indicates a specific element attribute that is supported or not by the encoding.
   */
  attribute: string | null;
  /**
   * Indicates a specific attribute value that is supported or not by the encoding. Only used together with the
   * attribute attribute.
   */
  value: string | null;
};

export type SupportsContents = [];

/**
 * The `<supports>` element
 *
 * Parent element: `<encoding>`
 *
 * The `<supports>` element indicates if a MusicXML encoding supports a particular MusicXML element. This is recommended
 * for elements like `<beam>`, `<stem>`, and `<accidental>`, where the absence of an element is ambiguous if you do not
 * know if the encoding supports that element. It also allows programs to indicate support for specific attributes, or
 * specific attributes with specific values. This lets applications communicate, for example, that all system and/or
 * page breaks are contained in the MusicXML file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/supports/}
 */
export class Supports implements XMLElement<'supports', SupportsAttributes, SupportsContents> {
  static readonly schema = {
    name: 'supports',
    attributes: {
      element: { type: 'required', value: { type: 'string' } },
      type: { type: 'required', value: { type: 'choices', choices: ['yes', 'no'] } },
      attribute: { type: 'optional', value: { type: 'string' } },
      value: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = Supports.schema;

  attributes: SupportsAttributes;
  contents: SupportsContents;

  constructor(opts?: { attributes?: Partial<SupportsAttributes>; contents?: SupportsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Supports.schema);
    this.contents = opts?.contents ?? operations.zero(Supports.schema.contents);
  }
  /** Gets @type {SupportsAttributes['element']}. */
  getElement(): string {
    return this.attributes['element'];
  }
  /** Sets @type {SupportsAttributes['element']}. */
  setElement(element: string): Supports {
    this.attributes['element'] = element;
    return this;
  }
  /** Gets @type {SupportsAttributes['type']}. */
  getType(): 'yes' | 'no' {
    return this.attributes['type'];
  }
  /** Sets @type {SupportsAttributes['type']}. */
  setType(type: 'yes' | 'no'): Supports {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {SupportsAttributes['attribute']}. */
  getAttribute(): string | null {
    return this.attributes['attribute'];
  }
  /** Sets @type {SupportsAttributes['attribute']}. */
  setAttribute(attribute: string | null): Supports {
    this.attributes['attribute'] = attribute;
    return this;
  }
  /** Gets @type {SupportsAttributes['value']}. */
  getValue(): string | null {
    return this.attributes['value'];
  }
  /** Sets @type {SupportsAttributes['value']}. */
  setValue(value: string | null): Supports {
    this.attributes['value'] = value;
    return this;
  }
}

export type EncodingAttributes = Record<string, unknown>;

export type EncodingContents = [
  Array<[EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]>,
];

/**
 * The `<encoding>` element
 *
 * Parent element: `<identification>`
 *
 * The `<encoding>` element contains information about who did the digital encoding, when, with what software, and in
 * what aspects.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/encoding/}
 */
export class Encoding implements XMLElement<'encoding', EncodingAttributes, EncodingContents> {
  static readonly schema = {
    name: 'encoding',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'encodings',
        value: {
          type: 'zeroOrMore',
          value: [
            { type: 'optional', value: EncodingDate },
            { type: 'optional', value: Encoder },
            { type: 'optional', value: Software },
            { type: 'optional', value: EncodingDescription },
            { type: 'optional', value: Supports },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Encoding.schema;

  attributes: EncodingAttributes;
  contents: EncodingContents;

  constructor(opts?: { attributes?: Partial<EncodingAttributes>; contents?: EncodingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Encoding.schema);
    this.contents = opts?.contents ?? operations.zero(Encoding.schema.contents);
  }

  /** Gets @type {Array<[EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]>}. */
  getEncodings(): Array<
    [EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]
  > {
    return this.contents[0];
  }
  /** Sets @type {Array<[EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]>}. */
  setEncodings(
    encodings: Array<
      [EncodingDate | null, Encoder | null, Software | null, EncodingDescription | null, Supports | null]
    >
  ): this {
    this.contents[0] = encodings;
    return this;
  }
}

export type SourceAttributes = Record<string, unknown>;

export type SourceContents = [string | null];

/**
 * The `<source>` element
 *
 * Parent element: `<identification>`
 *
 * The `<source>` element describes the source for the music that is encoded. This is similar to the [Dublin Core source
 * element](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/source/).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/source/}
 */
export class Source implements XMLElement<'source', SourceAttributes, SourceContents> {
  static readonly schema = {
    name: 'source',
    attributes: {},
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = Source.schema;

  attributes: SourceAttributes;
  contents: SourceContents;

  constructor(opts?: { attributes?: Partial<SourceAttributes>; contents?: SourceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Source.schema);
    this.contents = opts?.contents ?? operations.zero(Source.schema.contents);
  }

  /** Gets @type {string | null}. */
  getText(): string | null {
    return this.contents[0];
  }
  /** Sets @type {string | null}. */
  setText(text: string | null): this {
    this.contents[0] = text;
    return this;
  }
}

export type RelationAttributes = {
  /**
   * Standard type values are music, words, and arrangement, but other types may be used.
   */
  type: string | null;
};

export type RelationContents = [string];

/**
 * The `<relation>` element
 *
 * Parent element: `<identification>`
 *
 * The `<relation>` element describes a related resource for the music that is encoded. This is similar to the [Dublin
 * Core relation element](https://www.dublincore.org/specifications/dublin-core/dcmi-terms/elements11/relation/).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/relation/}
 */
export class Relation implements XMLElement<'relation', RelationAttributes, RelationContents> {
  static readonly schema = {
    name: 'relation',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Relation.schema;

  attributes: RelationAttributes;
  contents: RelationContents;

  constructor(opts?: { attributes?: Partial<RelationAttributes>; contents?: RelationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Relation.schema);
    this.contents = opts?.contents ?? operations.zero(Relation.schema.contents);
  }
  /** Gets @type {RelationAttributes['type']}. */
  getType(): string | null {
    return this.attributes['type'];
  }
  /** Sets @type {RelationAttributes['type']}. */
  setType(type: string | null): Relation {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MiscellaneousFieldAttributes = {
  /**
   * Indicates the type of metadata the element content represents.
   */
  name: string;
};

export type MiscellaneousFieldContents = [string];

/**
 * The `<miscellaneous-field>` element
 *
 * Parent element: `<miscellaneous>`
 *
 * If a program has other metadata not yet supported in the MusicXML format, each type of metadata can go in a'
 * `<miscellaneous-field>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/miscellaneous-field/}
 */
export class MiscellaneousField
  implements XMLElement<'miscellaneous-field', MiscellaneousFieldAttributes, MiscellaneousFieldContents>
{
  static readonly schema = {
    name: 'miscellaneous-field',
    attributes: { name: { type: 'required', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = MiscellaneousField.schema;

  attributes: MiscellaneousFieldAttributes;
  contents: MiscellaneousFieldContents;

  constructor(opts?: { attributes?: Partial<MiscellaneousFieldAttributes>; contents?: MiscellaneousFieldContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MiscellaneousField.schema);
    this.contents = opts?.contents ?? operations.zero(MiscellaneousField.schema.contents);
  }
  /** Gets @type {MiscellaneousFieldAttributes['name']}. */
  getName(): string {
    return this.attributes['name'];
  }
  /** Sets @type {MiscellaneousFieldAttributes['name']}. */
  setName(name: string): MiscellaneousField {
    this.attributes['name'] = name;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MiscellaneousAttributes = Record<string, unknown>;

export type MiscellaneousContents = [Array<MiscellaneousField>];

/**
 * The `<miscellaneous>` element
 *
 * Parent element: `<identification>`
 *
 * If a program has other metadata not yet supported in the MusicXML format, it can go in the `<miscellaneous>` element.
 * The `<miscellaneous>` element puts each separate part of metadata into its own `<miscellaneous-field>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/miscellaneous/}
 */
export class Miscellaneous implements XMLElement<'miscellaneous', MiscellaneousAttributes, MiscellaneousContents> {
  static readonly schema = {
    name: 'miscellaneous',
    attributes: {},
    contents: [
      { type: 'label', label: 'miscellaneous-fields', value: { type: 'zeroOrMore', value: MiscellaneousField } },
    ],
  } as const;

  readonly schema = Miscellaneous.schema;

  attributes: MiscellaneousAttributes;
  contents: MiscellaneousContents;

  constructor(opts?: { attributes?: Partial<MiscellaneousAttributes>; contents?: MiscellaneousContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Miscellaneous.schema);
    this.contents = opts?.contents ?? operations.zero(Miscellaneous.schema.contents);
  }

  /** Gets @type {Array<MiscellaneousField>}. */
  getMiscellaneousFields(): Array<MiscellaneousField> {
    return this.contents[0];
  }
  /** Sets @type {Array<MiscellaneousField>}. */
  setMiscellaneousFields(miscellaneousFields: Array<MiscellaneousField>): this {
    this.contents[0] = miscellaneousFields;
    return this;
  }
}

export type IdentificationAttributes = Record<string, unknown>;

export type IdentificationContents = [
  Array<Creator>,
  Array<Rights>,
  Encoding | null,
  Source | null,
  Array<Relation>,
  Miscellaneous | null,
];

/**
 * The `<identification>` element
 *
 * Parent elements: `<score-part>`, `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<identification>` element contains basic metadata about the score. It includes information that may apply at a
 * score-wide, movement-wide, or part-wide level. The `<creator>`, `<rights>`, `<source>`, and `<relation>` elements are
 * based on Dublin Core.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/identification/}
 */
export class Identification implements XMLElement<'identification', IdentificationAttributes, IdentificationContents> {
  static readonly schema = {
    name: 'identification',
    attributes: {},
    contents: [
      { type: 'label', label: 'creators', value: { type: 'zeroOrMore', value: Creator } },
      { type: 'label', label: 'rights', value: { type: 'zeroOrMore', value: Rights } },
      { type: 'optional', value: Encoding },
      { type: 'optional', value: Source },
      { type: 'label', label: 'relations', value: { type: 'zeroOrMore', value: Relation } },
      { type: 'optional', value: Miscellaneous },
    ],
  } as const;

  readonly schema = Identification.schema;

  attributes: IdentificationAttributes;
  contents: IdentificationContents;

  constructor(opts?: { attributes?: Partial<IdentificationAttributes>; contents?: IdentificationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Identification.schema);
    this.contents = opts?.contents ?? operations.zero(Identification.schema.contents);
  }

  /** Gets @type {Array<Creator>}. */
  getCreators(): Array<Creator> {
    return this.contents[0];
  }
  /** Sets @type {Array<Creator>}. */
  setCreators(creators: Array<Creator>): this {
    this.contents[0] = creators;
    return this;
  }
  /** Gets @type {Array<Rights>}. */
  getRights(): Array<Rights> {
    return this.contents[1];
  }
  /** Sets @type {Array<Rights>}. */
  setRights(rights: Array<Rights>): this {
    this.contents[1] = rights;
    return this;
  }
  /** Gets @type {Encoding | null}. */
  getEncoding(): Encoding | null {
    return this.contents[2];
  }
  /** Sets @type {Encoding | null}. */
  setEncoding(encoding: Encoding | null): this {
    this.contents[2] = encoding;
    return this;
  }
  /** Gets @type {Source | null}. */
  getSource(): Source | null {
    return this.contents[3];
  }
  /** Sets @type {Source | null}. */
  setSource(source: Source | null): this {
    this.contents[3] = source;
    return this;
  }
  /** Gets @type {Array<Relation>}. */
  getRelations(): Array<Relation> {
    return this.contents[4];
  }
  /** Sets @type {Array<Relation>}. */
  setRelations(relations: Array<Relation>): this {
    this.contents[4] = relations;
    return this;
  }
  /** Gets @type {Miscellaneous | null}. */
  getMiscellaneous(): Miscellaneous | null {
    return this.contents[5];
  }
  /** Sets @type {Miscellaneous | null}. */
  setMiscellaneous(miscellaneous: Miscellaneous | null): this {
    this.contents[5] = miscellaneous;
    return this;
  }
}

export type MillimetersAttributes = Record<string, unknown>;

export type MillimetersContents = [number];

/**
 * The `<millimeters>` element
 *
 * Parent element: `<scaling>`
 *
 * The `<millimeters>` element contains the number of millimeters that correspond to the given number of tenths within
 * the `<scaling>` element formula.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/millimeters/}
 */
export class Millimeters implements XMLElement<'millimeters', MillimetersAttributes, MillimetersContents> {
  static readonly schema = {
    name: 'millimeters',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'millimeters', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Millimeters.schema;

  attributes: MillimetersAttributes;
  contents: MillimetersContents;

  constructor(opts?: { attributes?: Partial<MillimetersAttributes>; contents?: MillimetersContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Millimeters.schema);
    this.contents = opts?.contents ?? operations.zero(Millimeters.schema.contents);
  }

  /** Gets @type {number}. */
  getMillimeters(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setMillimeters(millimeters: number): this {
    this.contents[0] = millimeters;
    return this;
  }
}

export type TenthsAttributes = Record<string, unknown>;

export type TenthsContents = [number];

/**
 * The `<tenths>` element
 *
 * Parent element: `<scaling>`
 *
 * The `<tenths>` element contains the number of tenths that correspond to the given number of millimeters within the
 * `<scaling>` element formula. Setting this to 40 allows the `<millimeters>` element to specify the size of a 5-line
 * staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tenths/}
 */
export class Tenths implements XMLElement<'tenths', TenthsAttributes, TenthsContents> {
  static readonly schema = {
    name: 'tenths',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'tenths-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Tenths.schema;

  attributes: TenthsAttributes;
  contents: TenthsContents;

  constructor(opts?: { attributes?: Partial<TenthsAttributes>; contents?: TenthsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tenths.schema);
    this.contents = opts?.contents ?? operations.zero(Tenths.schema.contents);
  }

  /** Gets @type {number}. */
  getTenthsValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setTenthsValue(tenthsValue: number): this {
    this.contents[0] = tenthsValue;
    return this;
  }
}

export type ScalingAttributes = Record<string, unknown>;

export type ScalingContents = [Millimeters, Tenths];

/**
 * The `<scaling>` element
 *
 * Parent element: `<defaults>`
 *
 * Margins, page sizes, and distances are all measured in tenths to keep MusicXML data in a consistent coordinate system
 * as much as possible. The translation to absolute units is done with the `<scaling>` element, which specifies how many
 * millimeters are equal to how many tenths. For a staff height of 7 mm, `<millimeters>` would be set to 7 while
 * `<tenths>` is set to 40. The ability to set a formula rather than a single scaling factor helps avoid roundoff errors.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/scaling/}
 */
export class Scaling implements XMLElement<'scaling', ScalingAttributes, ScalingContents> {
  static readonly schema = {
    name: 'scaling',
    attributes: {},
    contents: [
      { type: 'required', value: Millimeters },
      { type: 'required', value: Tenths },
    ],
  } as const;

  readonly schema = Scaling.schema;

  attributes: ScalingAttributes;
  contents: ScalingContents;

  constructor(opts?: { attributes?: Partial<ScalingAttributes>; contents?: ScalingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Scaling.schema);
    this.contents = opts?.contents ?? operations.zero(Scaling.schema.contents);
  }

  /** Gets @type {Millimeters}. */
  getMillimeters(): Millimeters {
    return this.contents[0];
  }
  /** Sets @type {Millimeters}. */
  setMillimeters(millimeters: Millimeters): this {
    this.contents[0] = millimeters;
    return this;
  }
  /** Gets @type {Tenths}. */
  getTenths(): Tenths {
    return this.contents[1];
  }
  /** Sets @type {Tenths}. */
  setTenths(tenths: Tenths): this {
    this.contents[1] = tenths;
    return this;
  }
}

export type ConcertScoreAttributes = Record<string, unknown>;

export type ConcertScoreContents = [];

/**
 * The `<concert-score>` element
 *
 * Parent element: `<defaults>`
 *
 * The presence of a `<concert-score>` element indicates that a score is displayed in concert pitch. It is used for
 * scores that contain parts for transposing instruments.
 *
 * A document with a `<concert-score>` element may not contain any `<transpose>` elements that have non-zero values for
 * either the `<diatonic>` or `<chromatic>` elements. Concert scores may include octave transpositions, so `<transpose>`
 * elements with a `<double>` element or a non-zero `<octave-change>` element value are permitted.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/concert-score/}
 */
export class ConcertScore implements XMLElement<'concert-score', ConcertScoreAttributes, ConcertScoreContents> {
  static readonly schema = { name: 'concert-score', attributes: {}, contents: [] } as const;

  readonly schema = ConcertScore.schema;

  attributes: ConcertScoreAttributes;
  contents: ConcertScoreContents;

  constructor(opts?: { attributes?: Partial<ConcertScoreAttributes>; contents?: ConcertScoreContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ConcertScore.schema);
    this.contents = opts?.contents ?? operations.zero(ConcertScore.schema.contents);
  }
}

export type PageHeightAttributes = Record<string, unknown>;

export type PageHeightContents = [number];

/**
 * The `<page-height>` element
 *
 * Parent element: `<page-layout>`
 *
 * The `<page-height>` element specifies the page height in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-height/}
 */
export class PageHeight implements XMLElement<'page-height', PageHeightAttributes, PageHeightContents> {
  static readonly schema = {
    name: 'page-height',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = PageHeight.schema;

  attributes: PageHeightAttributes;
  contents: PageHeightContents;

  constructor(opts?: { attributes?: Partial<PageHeightAttributes>; contents?: PageHeightContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageHeight.schema);
    this.contents = opts?.contents ?? operations.zero(PageHeight.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type PageWidthAttributes = Record<string, unknown>;

export type PageWidthContents = [number];

/**
 * The `<page-width>` element
 *
 * Parent element: `<page-layout>`
 *
 * The `<page-width>` element specifies the page width in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-width/}
 */
export class PageWidth implements XMLElement<'page-width', PageWidthAttributes, PageWidthContents> {
  static readonly schema = {
    name: 'page-width',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = PageWidth.schema;

  attributes: PageWidthAttributes;
  contents: PageWidthContents;

  constructor(opts?: { attributes?: Partial<PageWidthAttributes>; contents?: PageWidthContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageWidth.schema);
    this.contents = opts?.contents ?? operations.zero(PageWidth.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type LeftMarginAttributes = Record<string, unknown>;

export type LeftMarginContents = [number];

/**
 * The `<left-margin>` element
 *
 * Parent elements: `<page-margins>`, `<system-margins>`
 *
 * The `<left-margin>` element specifies the left margin for the parent element in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/left-margin/}
 */
export class LeftMargin implements XMLElement<'left-margin', LeftMarginAttributes, LeftMarginContents> {
  static readonly schema = {
    name: 'left-margin',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'left-margin',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = LeftMargin.schema;

  attributes: LeftMarginAttributes;
  contents: LeftMarginContents;

  constructor(opts?: { attributes?: Partial<LeftMarginAttributes>; contents?: LeftMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LeftMargin.schema);
    this.contents = opts?.contents ?? operations.zero(LeftMargin.schema.contents);
  }

  /** Gets @type {number}. */
  getLeftMargin(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setLeftMargin(leftMargin: number): this {
    this.contents[0] = leftMargin;
    return this;
  }
}

export type RightMarginAttributes = Record<string, unknown>;

export type RightMarginContents = [number];

/**
 * The `<right-margin>` element
 *
 * Parent elements: `<page-margins>`, `<system-margins>`
 *
 * The `<right-margin>` element specifies the right margin for the parent element in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/right-margin/}
 */
export class RightMargin implements XMLElement<'right-margin', RightMarginAttributes, RightMarginContents> {
  static readonly schema = {
    name: 'right-margin',
    attributes: {},
    contents: [{ type: 'label', label: 'value', value: { type: 'float', min: -Infinity, max: Infinity } }],
  } as const;

  readonly schema = RightMargin.schema;

  attributes: RightMarginAttributes;
  contents: RightMarginContents;

  constructor(opts?: { attributes?: Partial<RightMarginAttributes>; contents?: RightMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, RightMargin.schema);
    this.contents = opts?.contents ?? operations.zero(RightMargin.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type TopMarginAttributes = Record<string, unknown>;

export type TopMarginContents = [number];

/**
 * The `<top-margin>` element
 *
 * Parent element: `<page-margins>`
 *
 * The `<top-margin>` element specifies the top page margin in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/top-margin/}
 */
export class TopMargin implements XMLElement<'top-margin', TopMarginAttributes, TopMarginContents> {
  static readonly schema = {
    name: 'top-margin',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'top-margin-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = TopMargin.schema;

  attributes: TopMarginAttributes;
  contents: TopMarginContents;

  constructor(opts?: { attributes?: Partial<TopMarginAttributes>; contents?: TopMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TopMargin.schema);
    this.contents = opts?.contents ?? operations.zero(TopMargin.schema.contents);
  }

  /** Gets @type {number}. */
  getTopMarginValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setTopMarginValue(topMarginValue: number): this {
    this.contents[0] = topMarginValue;
    return this;
  }
}

export type BottomMarginAttributes = Record<string, unknown>;

export type BottomMarginContents = [number];

/**
 * The `<bottom-margin>` element
 *
 * Parent element: `<page-margins>`
 *
 * The `<bottom-margin>` element specifies the bottom page margin in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bottom-margin/}
 */
export class BottomMargin implements XMLElement<'bottom-margin', BottomMarginAttributes, BottomMarginContents> {
  static readonly schema = {
    name: 'bottom-margin',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'bottom-margin',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = BottomMargin.schema;

  attributes: BottomMarginAttributes;
  contents: BottomMarginContents;

  constructor(opts?: { attributes?: Partial<BottomMarginAttributes>; contents?: BottomMarginContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BottomMargin.schema);
    this.contents = opts?.contents ?? operations.zero(BottomMargin.schema.contents);
  }

  /** Gets @type {number}. */
  getBottomMargin(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setBottomMargin(bottomMargin: number): this {
    this.contents[0] = bottomMargin;
    return this;
  }
}

export type PageMarginsAttributes = {
  /**
   * Specifies whether the margins apply to even pages, odd pages, or both. This attribute is not needed when used
   * as part of a `<print>` element. The value is both if omitted when used in the `<defaults>` element.
   */
  type: 'both' | 'even' | 'odd' | null;
};

export type PageMarginsContents = [LeftMargin, RightMargin, TopMargin, BottomMargin];

/**
 * The `<page-margins>` element
 *
 * Parent element: `<page-layout>`
 *
 * The `<page-margins>` element specifies page margins in tenths either for both even and odd pages, or via separate odd
 * and even page number values.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-margins/}
 */
export class PageMargins implements XMLElement<'page-margins', PageMarginsAttributes, PageMarginsContents> {
  static readonly schema = {
    name: 'page-margins',
    attributes: { type: { type: 'optional', value: { type: 'choices', choices: ['both', 'even', 'odd'] } } },
    contents: [
      { type: 'required', value: LeftMargin },
      { type: 'required', value: RightMargin },
      { type: 'required', value: TopMargin },
      { type: 'required', value: BottomMargin },
    ],
  } as const;

  readonly schema = PageMargins.schema;

  attributes: PageMarginsAttributes;
  contents: PageMarginsContents;

  constructor(opts?: { attributes?: Partial<PageMarginsAttributes>; contents?: PageMarginsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageMargins.schema);
    this.contents = opts?.contents ?? operations.zero(PageMargins.schema.contents);
  }
  /** Gets @type {PageMarginsAttributes['type']}. */
  getType(): 'both' | 'even' | 'odd' | null {
    return this.attributes['type'];
  }
  /** Sets @type {PageMarginsAttributes['type']}. */
  setType(type: 'both' | 'even' | 'odd' | null): PageMargins {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {LeftMargin}. */
  getLeftMargin(): LeftMargin {
    return this.contents[0];
  }
  /** Sets @type {LeftMargin}. */
  setLeftMargin(leftMargin: LeftMargin): this {
    this.contents[0] = leftMargin;
    return this;
  }
  /** Gets @type {RightMargin}. */
  getRightMargin(): RightMargin {
    return this.contents[1];
  }
  /** Sets @type {RightMargin}. */
  setRightMargin(rightMargin: RightMargin): this {
    this.contents[1] = rightMargin;
    return this;
  }
  /** Gets @type {TopMargin}. */
  getTopMargin(): TopMargin {
    return this.contents[2];
  }
  /** Sets @type {TopMargin}. */
  setTopMargin(topMargin: TopMargin): this {
    this.contents[2] = topMargin;
    return this;
  }
  /** Gets @type {BottomMargin}. */
  getBottomMargin(): BottomMargin {
    return this.contents[3];
  }
  /** Sets @type {BottomMargin}. */
  setBottomMargin(bottomMargin: BottomMargin): this {
    this.contents[3] = bottomMargin;
    return this;
  }
}

export type PageLayoutAttributes = Record<string, unknown>;

export type PageLayoutContents = [PageHeight | null, PageWidth | null, [] | [PageMargins] | [PageMargins, PageMargins]];

/**
 * The `<page-layout>` element
 *
 * Parent elements: `<defaults>`, `<print>`
 *
 * Page layout can be defined both in score-wide `<defaults>` and in the `<print>` element. If no `<page-layout>`
 * element is present in the `<defaults>` element, default page layout values are chosen by the application.
 *
 * When used in the `<print>` element, the `<page-layout>` element affects the appearance of the current page only. All
 * other pages use the default values as determined by the `<defaults>` element. If any child elements are missing from
 * the `<page-layout>` element in a `<print>` element, the values determined by the <defaults> element are used there
 * as well.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/page-layout/}
 */
export class PageLayout implements XMLElement<'page-layout', PageLayoutAttributes, PageLayoutContents> {
  static readonly schema = {
    name: 'page-layout',
    attributes: {},
    contents: [
      { type: 'optional', value: PageHeight },
      { type: 'optional', value: PageWidth },
      {
        type: 'label',
        label: 'page-margins',
        value: { type: 'choices', choices: [[], [PageMargins], [PageMargins, PageMargins]] },
      },
    ],
  } as const;

  readonly schema = PageLayout.schema;

  attributes: PageLayoutAttributes;
  contents: PageLayoutContents;

  constructor(opts?: { attributes?: Partial<PageLayoutAttributes>; contents?: PageLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PageLayout.schema);
    this.contents = opts?.contents ?? operations.zero(PageLayout.schema.contents);
  }

  /** Gets @type {PageHeight | null}. */
  getPageHeight(): PageHeight | null {
    return this.contents[0];
  }
  /** Sets @type {PageHeight | null}. */
  setPageHeight(pageHeight: PageHeight | null): this {
    this.contents[0] = pageHeight;
    return this;
  }
  /** Gets @type {PageWidth | null}. */
  getPageWidth(): PageWidth | null {
    return this.contents[1];
  }
  /** Sets @type {PageWidth | null}. */
  setPageWidth(pageWidth: PageWidth | null): this {
    this.contents[1] = pageWidth;
    return this;
  }
  /** Gets @type {[] | [PageMargins] | [PageMargins, PageMargins]}. */
  getPageMargins(): [] | [PageMargins] | [PageMargins, PageMargins] {
    return this.contents[2];
  }
  /** Sets @type {[] | [PageMargins] | [PageMargins, PageMargins]}. */
  setPageMargins(pageMargins: [] | [PageMargins] | [PageMargins, PageMargins]): this {
    this.contents[2] = pageMargins;
    return this;
  }
}

export type SystemMarginsAttributes = Record<string, unknown>;

export type SystemMarginsContents = [LeftMargin, RightMargin];

/**
 * The `<system-margins>` element
 *
 * Parent element: `<system-layout>`
 *
 * System margins are relative to the page margins. Positive values indent and negative values reduce the margin size.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/system-margins/}
 */
export class SystemMargins implements XMLElement<'system-margins', SystemMarginsAttributes, SystemMarginsContents> {
  static readonly schema = {
    name: 'system-margins',
    attributes: {},
    contents: [
      { type: 'required', value: LeftMargin },
      { type: 'required', value: RightMargin },
    ],
  } as const;

  readonly schema = SystemMargins.schema;

  attributes: SystemMarginsAttributes;
  contents: SystemMarginsContents;

  constructor(opts?: { attributes?: Partial<SystemMarginsAttributes>; contents?: SystemMarginsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SystemMargins.schema);
    this.contents = opts?.contents ?? operations.zero(SystemMargins.schema.contents);
  }

  /** Gets @type {LeftMargin}. */
  getLeftMargin(): LeftMargin {
    return this.contents[0];
  }
  /** Sets @type {LeftMargin}. */
  setLeftMargin(leftMargin: LeftMargin): this {
    this.contents[0] = leftMargin;
    return this;
  }
  /** Gets @type {RightMargin}. */
  getRightMargin(): RightMargin {
    return this.contents[1];
  }
  /** Sets @type {RightMargin}. */
  setRightMargin(rightMargin: RightMargin): this {
    this.contents[1] = rightMargin;
    return this;
  }
}

export type SystemDistanceAttributes = Record<string, unknown>;

export type SystemDistanceContents = [number];

/**
 * The `<system-distance>` element
 *
 * Parent element: `<system-layout>`
 *
 * The `<system-distance>` is measured from the bottom line of the previous system to the top line of the current
 * system. It is ignored for the first system on a page.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/system-distance/}
 */
export class SystemDistance implements XMLElement<'system-distance', SystemDistanceAttributes, SystemDistanceContents> {
  static readonly schema = {
    name: 'system-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'system-distance-value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = SystemDistance.schema;

  attributes: SystemDistanceAttributes;
  contents: SystemDistanceContents;

  constructor(opts?: { attributes?: Partial<SystemDistanceAttributes>; contents?: SystemDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SystemDistance.schema);
    this.contents = opts?.contents ?? operations.zero(SystemDistance.schema.contents);
  }

  /** Gets @type {number}. */
  getSystemDistanceValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSystemDistanceValue(systemDistanceValue: number): this {
    this.contents[0] = systemDistanceValue;
    return this;
  }
}

export type TopSystemDistanceAttributes = Record<string, unknown>;

export type TopSystemDistanceContents = [number];

/**
 * The `<top-system-distance>` element
 *
 * Parent element: `<system-layout>`
 *
 * The `<top-system-distance>` is measured from the page's top margin to the top line of the first system. It is ignored
 * for all but the first system on a page.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/top-system-distance/}
 */
export class TopSystemDistance
  implements XMLElement<'top-system-distance', TopSystemDistanceAttributes, TopSystemDistanceContents>
{
  static readonly schema = {
    name: 'top-system-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = TopSystemDistance.schema;

  attributes: TopSystemDistanceAttributes;
  contents: TopSystemDistanceContents;

  constructor(opts?: { attributes?: Partial<TopSystemDistanceAttributes>; contents?: TopSystemDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TopSystemDistance.schema);
    this.contents = opts?.contents ?? operations.zero(TopSystemDistance.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type SystemLayoutAttributes = Record<string, unknown>;

export type SystemLayoutContents = [SystemMargins | null, SystemDistance | null, TopSystemDistance | null];

/**
 * The `<system-layout>` element
 *
 * Parent elements: `<defaults>`, `<print>`
 *
 * A system is a group of staves that are read and played simultaneously. The `<system-layout>` element includes left
 * and right margins and the vertical distance from the previous system.
 *
 * Sometimes the sum of measure widths in a system may not equal the system width specified by the layout elements due
 * to roundoff or other errors. The behavior when reading MusicXML files in these cases is application-dependent. For
 * instance, applications may find that the system layout data is more reliable than the sum of the measure widths, and
 * adjust the measure widths accordingly.
 *
 * When used in the `<defaults>` element, the `<system-layout>` element defines a default appearance for all systems in
 * the score. If no `<system-layout>` element is present in the `<defaults>` element, default system layout values are
 * chosen by the application.
 *
 * When used in the `<print>` element, the `<system-layout>` element affects the appearance of the current system only.
 * All other systems use the default values as determined by the `<defaults>` element. If any child elements are missing
 * from the `<system-layout>` element in a `<print>` element, the values determined by the `<defaults>` element are used
 * there as well. This type of `<system-layout>` element need only be read from or written to the first visible part in
 * the score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/system-layout/}
 */
export class SystemLayout implements XMLElement<'system-layout', SystemLayoutAttributes, SystemLayoutContents> {
  static readonly schema = {
    name: 'system-layout',
    attributes: {},
    contents: [
      { type: 'optional', value: SystemMargins },
      { type: 'optional', value: SystemDistance },
      { type: 'optional', value: TopSystemDistance },
    ],
  } as const;

  readonly schema = SystemLayout.schema;

  attributes: SystemLayoutAttributes;
  contents: SystemLayoutContents;

  constructor(opts?: { attributes?: Partial<SystemLayoutAttributes>; contents?: SystemLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SystemLayout.schema);
    this.contents = opts?.contents ?? operations.zero(SystemLayout.schema.contents);
  }

  /** Gets @type {SystemMargins | null}. */
  getSystemMargins(): SystemMargins | null {
    return this.contents[0];
  }
  /** Sets @type {SystemMargins | null}. */
  setSystemMargins(systemMargins: SystemMargins | null): this {
    this.contents[0] = systemMargins;
    return this;
  }
  /** Gets @type {SystemDistance | null}. */
  getSystemDistance(): SystemDistance | null {
    return this.contents[1];
  }
  /** Sets @type {SystemDistance | null}. */
  setSystemDistance(systemDistance: SystemDistance | null): this {
    this.contents[1] = systemDistance;
    return this;
  }
  /** Gets @type {TopSystemDistance | null}. */
  getTopSystemDistance(): TopSystemDistance | null {
    return this.contents[2];
  }
  /** Sets @type {TopSystemDistance | null}. */
  setTopSystemDistance(topSystemDistance: TopSystemDistance | null): this {
    this.contents[2] = topSystemDistance;
    return this;
  }
}

export type StaffDistanceAttributes = Record<string, unknown>;

export type StaffDistanceContents = [number];

/**
 * The `<staff-distance>` element
 *
 * Parent element: `<staff-layout>`
 *
 * The `<staff-distance> element represents the vertical distance from the bottom line of the previous staff in this
 * system to the top line of the current staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-distance/}
 */
export class StaffDistance implements XMLElement<'staff-distance', StaffDistanceAttributes, StaffDistanceContents> {
  static readonly schema = {
    name: 'staff-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = StaffDistance.schema;

  attributes: StaffDistanceAttributes;
  contents: StaffDistanceContents;

  constructor(opts?: { attributes?: Partial<StaffDistanceAttributes>; contents?: StaffDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffDistance.schema);
    this.contents = opts?.contents ?? operations.zero(StaffDistance.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type StaffLayoutAttributes = {
  /**
   * Refers to staff numbers within the part, from top to bottom on the system. A value of 1 is used if not present.
   */
  number: number | null;
};

export type StaffLayoutContents = [StaffDistance | null];

/**
 * The `<defaults>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
export class StaffLayout implements XMLElement<'staff-layout', StaffLayoutAttributes, StaffLayoutContents> {
  static readonly schema = {
    name: 'staff-layout',
    attributes: { number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } } },
    contents: [{ type: 'optional', value: StaffDistance }],
  } as const;

  readonly schema = StaffLayout.schema;

  attributes: StaffLayoutAttributes;
  contents: StaffLayoutContents;

  constructor(opts?: { attributes?: Partial<StaffLayoutAttributes>; contents?: StaffLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffLayout.schema);
    this.contents = opts?.contents ?? operations.zero(StaffLayout.schema.contents);
  }
  /** Gets @type {StaffLayoutAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {StaffLayoutAttributes['number']}. */
  setNumber(number: number | null): StaffLayout {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {StaffDistance | null}. */
  getStaffDistance(): StaffDistance | null {
    return this.contents[0];
  }
  /** Sets @type {StaffDistance | null}. */
  setStaffDistance(staffDistance: StaffDistance | null): this {
    this.contents[0] = staffDistance;
    return this;
  }
}

export type LineWidthAttributes = {
  /**
   * The type of line whose width is being defined.
   */
  type:
    | 'beam'
    | 'bracket'
    | 'dashes'
    | 'enclosure'
    | 'ending'
    | 'extend'
    | 'heavy barline'
    | 'leger'
    | 'light barline'
    | 'octave shift'
    | 'pedal'
    | 'slur middle'
    | 'slur tip'
    | 'staff'
    | 'stem'
    | 'tie middle'
    | 'tie tip'
    | 'tuplet bracket'
    | 'wedge';
};

export type LineWidthContents = [number];

/**
 * The `<line-width>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<line-width>` element indicates the width of a specific line type in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/line-width/}
 */
export class LineWidth implements XMLElement<'line-width', LineWidthAttributes, LineWidthContents> {
  static readonly schema = {
    name: 'line-width',
    attributes: {
      type: {
        type: 'required',
        value: {
          type: 'choices',
          choices: [
            'beam',
            'bracket',
            'dashes',
            'enclosure',
            'ending',
            'extend',
            'heavy barline',
            'leger',
            'light barline',
            'octave shift',
            'pedal',
            'slur middle',
            'slur tip',
            'staff',
            'stem',
            'tie middle',
            'tie tip',
            'tuplet bracket',
            'wedge',
          ],
        },
      },
    },
    contents: [
      {
        type: 'label',
        label: 'line-width',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = LineWidth.schema;

  attributes: LineWidthAttributes;
  contents: LineWidthContents;

  constructor(opts?: { attributes?: Partial<LineWidthAttributes>; contents?: LineWidthContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LineWidth.schema);
    this.contents = opts?.contents ?? operations.zero(LineWidth.schema.contents);
  }
  /** Gets @type {LineWidthAttributes['type']}. */
  getType():
    | 'beam'
    | 'bracket'
    | 'dashes'
    | 'enclosure'
    | 'ending'
    | 'extend'
    | 'heavy barline'
    | 'leger'
    | 'light barline'
    | 'octave shift'
    | 'pedal'
    | 'slur middle'
    | 'slur tip'
    | 'staff'
    | 'stem'
    | 'tie middle'
    | 'tie tip'
    | 'tuplet bracket'
    | 'wedge' {
    return this.attributes['type'];
  }
  /** Sets @type {LineWidthAttributes['type']}. */
  setType(
    type:
      | 'beam'
      | 'bracket'
      | 'dashes'
      | 'enclosure'
      | 'ending'
      | 'extend'
      | 'heavy barline'
      | 'leger'
      | 'light barline'
      | 'octave shift'
      | 'pedal'
      | 'slur middle'
      | 'slur tip'
      | 'staff'
      | 'stem'
      | 'tie middle'
      | 'tie tip'
      | 'tuplet bracket'
      | 'wedge'
  ): LineWidth {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {number}. */
  getLineWidth(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setLineWidth(lineWidth: number): this {
    this.contents[0] = lineWidth;
    return this;
  }
}

export type NoteSizeAttributes = {
  /**
   * The type of note size being defined.
   */
  type: 'cue' | 'grace' | 'grace-cue' | 'large';
};

export type NoteSizeContents = [number];

/**
 * The `<note-size>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<note-size>` element indicates the numeric percentage of the regular note size to use for notes with cue and
 * large size, as defined in the `<type>` element. A value of 100 would be identical to the size of a regular note as
 * defined by the music font.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/note-size/}
 */
export class NoteSize implements XMLElement<'note-size', NoteSizeAttributes, NoteSizeContents> {
  static readonly schema = {
    name: 'note-size',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['cue', 'grace', 'grace-cue', 'large'] } },
    },
    contents: [{ type: 'label', label: 'note-size', value: { type: 'float', min: 0, max: Infinity } }],
  } as const;

  readonly schema = NoteSize.schema;

  attributes: NoteSizeAttributes;
  contents: NoteSizeContents;

  constructor(opts?: { attributes?: Partial<NoteSizeAttributes>; contents?: NoteSizeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NoteSize.schema);
    this.contents = opts?.contents ?? operations.zero(NoteSize.schema.contents);
  }
  /** Gets @type {NoteSizeAttributes['type']}. */
  getType(): 'cue' | 'grace' | 'grace-cue' | 'large' {
    return this.attributes['type'];
  }
  /** Sets @type {NoteSizeAttributes['type']}. */
  setType(type: 'cue' | 'grace' | 'grace-cue' | 'large'): NoteSize {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {number}. */
  getNoteSize(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setNoteSize(noteSize: number): this {
    this.contents[0] = noteSize;
    return this;
  }
}

export type DistanceAttributes = {
  /**
   * The type of distance being defined.
   */
  type: 'beam' | 'hyphen';
};

export type DistanceContents = [number];

/**
 * The `<distance>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<distance>` element represents standard distances between notation elements in tenths.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/distance/}
 */
export class Distance implements XMLElement<'distance', DistanceAttributes, DistanceContents> {
  static readonly schema = {
    name: 'distance',
    attributes: { type: { type: 'required', value: { type: 'choices', choices: ['beam', 'hyphen'] } } },
    contents: [
      {
        type: 'label',
        label: 'distance',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Distance.schema;

  attributes: DistanceAttributes;
  contents: DistanceContents;

  constructor(opts?: { attributes?: Partial<DistanceAttributes>; contents?: DistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Distance.schema);
    this.contents = opts?.contents ?? operations.zero(Distance.schema.contents);
  }
  /** Gets @type {DistanceAttributes['type']}. */
  getType(): 'beam' | 'hyphen' {
    return this.attributes['type'];
  }
  /** Sets @type {DistanceAttributes['type']}. */
  setType(type: 'beam' | 'hyphen'): Distance {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {number}. */
  getDistance(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setDistance(distance: number): this {
    this.contents[0] = distance;
    return this;
  }
}

export type GlyphAttributes = {
  /**
   * The type of glyph that is being defined.
   */
  type:
    | 'quarter-rest'
    | 'g-clef-ottava-bassa'
    | 'c-clef'
    | 'f-clef'
    | 'percussion-clef'
    | 'octave-shift-up-8'
    | 'octave-shift-down-8'
    | 'octave-shift-down-15'
    | 'octave-shift-continue-15'
    | 'octave-shift-down-22'
    | 'octave-shift-up-22'
    | 'octave-shift-continue-22';
};

export type GlyphContents = [string];

/**
 * The `<glyph>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<glyph>` element represents what Standard Music Font Layout (SMuFL) glyph should be used for different
 * variations of symbols that are semantically identical. The type attribute specifies what type of glyph is being
 * defined. The element value specifies what SMuFL canonical glyph name to use, including recommended stylistic
 * alternates.
 *
 * The SMuFL canonical glyph name should match the type. For instance, a type of quarter-rest would use values
 * restQuarter, restQuarterOld, or restQuarterZ. A type of g-clef-ottava-bassa would use values gClef8vb, gClef8vbOld,
 * or gClef8vbCClef. A type of octave-shift-up-8 would use values ottava, ottavaBassa, ottavaBassaBa, ottavaBassaVb, or
 * octaveBassa.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/glyph/}
 */
export class Glyph implements XMLElement<'glyph', GlyphAttributes, GlyphContents> {
  static readonly schema = {
    name: 'glyph',
    attributes: {
      type: {
        type: 'required',
        value: {
          type: 'choices',
          choices: [
            'quarter-rest',
            'g-clef-ottava-bassa',
            'c-clef',
            'f-clef',
            'percussion-clef',
            'octave-shift-up-8',
            'octave-shift-down-8',
            'octave-shift-down-15',
            'octave-shift-continue-15',
            'octave-shift-down-22',
            'octave-shift-up-22',
            'octave-shift-continue-22',
          ],
        },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Glyph.schema;

  attributes: GlyphAttributes;
  contents: GlyphContents;

  constructor(opts?: { attributes?: Partial<GlyphAttributes>; contents?: GlyphContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Glyph.schema);
    this.contents = opts?.contents ?? operations.zero(Glyph.schema.contents);
  }
  /** Gets @type {GlyphAttributes['type']}. */
  getType():
    | 'quarter-rest'
    | 'g-clef-ottava-bassa'
    | 'c-clef'
    | 'f-clef'
    | 'percussion-clef'
    | 'octave-shift-up-8'
    | 'octave-shift-down-8'
    | 'octave-shift-down-15'
    | 'octave-shift-continue-15'
    | 'octave-shift-down-22'
    | 'octave-shift-up-22'
    | 'octave-shift-continue-22' {
    return this.attributes['type'];
  }
  /** Sets @type {GlyphAttributes['type']}. */
  setType(
    type:
      | 'quarter-rest'
      | 'g-clef-ottava-bassa'
      | 'c-clef'
      | 'f-clef'
      | 'percussion-clef'
      | 'octave-shift-up-8'
      | 'octave-shift-down-8'
      | 'octave-shift-down-15'
      | 'octave-shift-continue-15'
      | 'octave-shift-down-22'
      | 'octave-shift-up-22'
      | 'octave-shift-continue-22'
  ): Glyph {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type OtherAppearanceAttributes = {
  /**
   * The appearance type being specified.
   */
  type: string;
};

export type OtherAppearanceContents = [string];

/**
 * The `<other-appearance>` element
 *
 * Parent element: `<appearance>`
 *
 * The `<other-appearance>` element is used to define any graphical settings not yet in the current version of the
 * MusicXML format. This allows extended representation, though without application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-appearance/}
 */
export class OtherAppearance
  implements XMLElement<'other-appearance', OtherAppearanceAttributes, OtherAppearanceContents>
{
  static readonly schema = {
    name: 'other-appearance',
    attributes: { type: { type: 'required', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherAppearance.schema;

  attributes: OtherAppearanceAttributes;
  contents: OtherAppearanceContents;

  constructor(opts?: { attributes?: Partial<OtherAppearanceAttributes>; contents?: OtherAppearanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherAppearance.schema);
    this.contents = opts?.contents ?? operations.zero(OtherAppearance.schema.contents);
  }
  /** Gets @type {OtherAppearanceAttributes['type']}. */
  getType(): string {
    return this.attributes['type'];
  }
  /** Sets @type {OtherAppearanceAttributes['type']}. */
  setType(type: string): OtherAppearance {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type AppearanceAttributes = Record<string, unknown>;

export type AppearanceContents = [
  Array<LineWidth>,
  Array<NoteSize>,
  Array<Distance>,
  Array<Glyph>,
  Array<OtherAppearance>,
];

/**
 * The `<appearance>` element
 *
 * Parent element: `<defaults>`
 *
 * The `<appearance>` element controls general graphical settings for the music's final form appearance on a printed
 * page of display. This includes support for line widths, definitions for note sizes, standard distances between
 * notation elements, and Standard Music Font Layout (SMuFL) glyphs, plus an extension element for other aspects of
 * appearance.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/appearance/}
 */
export class Appearance implements XMLElement<'appearance', AppearanceAttributes, AppearanceContents> {
  static readonly schema = {
    name: 'appearance',
    attributes: {},
    contents: [
      { type: 'label', label: 'line-widths', value: { type: 'zeroOrMore', value: LineWidth } },
      { type: 'label', label: 'note-sizes', value: { type: 'zeroOrMore', value: NoteSize } },
      { type: 'label', label: 'distances', value: { type: 'zeroOrMore', value: Distance } },
      { type: 'label', label: 'glyphs', value: { type: 'zeroOrMore', value: Glyph } },
      { type: 'label', label: 'other-appearances', value: { type: 'zeroOrMore', value: OtherAppearance } },
    ],
  } as const;

  readonly schema = Appearance.schema;

  attributes: AppearanceAttributes;
  contents: AppearanceContents;

  constructor(opts?: { attributes?: Partial<AppearanceAttributes>; contents?: AppearanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Appearance.schema);
    this.contents = opts?.contents ?? operations.zero(Appearance.schema.contents);
  }

  /** Gets @type {Array<LineWidth>}. */
  getLineWidths(): Array<LineWidth> {
    return this.contents[0];
  }
  /** Sets @type {Array<LineWidth>}. */
  setLineWidths(lineWidths: Array<LineWidth>): this {
    this.contents[0] = lineWidths;
    return this;
  }
  /** Gets @type {Array<NoteSize>}. */
  getNoteSizes(): Array<NoteSize> {
    return this.contents[1];
  }
  /** Sets @type {Array<NoteSize>}. */
  setNoteSizes(noteSizes: Array<NoteSize>): this {
    this.contents[1] = noteSizes;
    return this;
  }
  /** Gets @type {Array<Distance>}. */
  getDistances(): Array<Distance> {
    return this.contents[2];
  }
  /** Sets @type {Array<Distance>}. */
  setDistances(distances: Array<Distance>): this {
    this.contents[2] = distances;
    return this;
  }
  /** Gets @type {Array<Glyph>}. */
  getGlyphs(): Array<Glyph> {
    return this.contents[3];
  }
  /** Sets @type {Array<Glyph>}. */
  setGlyphs(glyphs: Array<Glyph>): this {
    this.contents[3] = glyphs;
    return this;
  }
  /** Gets @type {Array<OtherAppearance>}. */
  getOtherAppearances(): Array<OtherAppearance> {
    return this.contents[4];
  }
  /** Sets @type {Array<OtherAppearance>}. */
  setOtherAppearances(otherAppearances: Array<OtherAppearance>): this {
    this.contents[4] = otherAppearances;
    return this;
  }
}

export type MusicFontAttributes = {
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
};

export type MusicFontContents = [];

/**
 * The `<music-font>` element
 *
 * Parent element: `<defaults>`
 *
 * The `<music-font>` element represents the default values for the music font in the score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/music-font/}
 */
export class MusicFont implements XMLElement<'music-font', MusicFontAttributes, MusicFontContents> {
  static readonly schema = {
    name: 'music-font',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [],
  } as const;

  readonly schema = MusicFont.schema;

  attributes: MusicFontAttributes;
  contents: MusicFontContents;

  constructor(opts?: { attributes?: Partial<MusicFontAttributes>; contents?: MusicFontContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MusicFont.schema);
    this.contents = opts?.contents ?? operations.zero(MusicFont.schema.contents);
  }
  /** Gets @type {MusicFontAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {MusicFontAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): MusicFont {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {MusicFontAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {MusicFontAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): MusicFont {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {MusicFontAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {MusicFontAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): MusicFont {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {MusicFontAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {MusicFontAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): MusicFont {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
}

export type WordFontAttributes = {
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
};

export type WordFontContents = [];

/**
 * The `<defaults>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
export class WordFont implements XMLElement<'word-font', WordFontAttributes, WordFontContents> {
  static readonly schema = {
    name: 'word-font',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [],
  } as const;

  readonly schema = WordFont.schema;

  attributes: WordFontAttributes;
  contents: WordFontContents;

  constructor(opts?: { attributes?: Partial<WordFontAttributes>; contents?: WordFontContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WordFont.schema);
    this.contents = opts?.contents ?? operations.zero(WordFont.schema.contents);
  }
  /** Gets @type {WordFontAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {WordFontAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): WordFont {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {WordFontAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {WordFontAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): WordFont {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {WordFontAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {WordFontAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): WordFont {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {WordFontAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {WordFontAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): WordFont {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
}

export type LyricFontAttributes = {
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The lyric name for which this is the default, corresponding to the name attribute in the `<lyric>` element.
   */
  name: string | null;
  /**
   * The lyric number for which this is the default, corresponding to the number attribute in the `<lyric>` element.
   */
  number: string | null;
};

export type LyricFontContents = [];

/**
 * The `<defaults>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
export class LyricFont implements XMLElement<'lyric-font', LyricFontAttributes, LyricFontContents> {
  static readonly schema = {
    name: 'lyric-font',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      name: { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = LyricFont.schema;

  attributes: LyricFontAttributes;
  contents: LyricFontContents;

  constructor(opts?: { attributes?: Partial<LyricFontAttributes>; contents?: LyricFontContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LyricFont.schema);
    this.contents = opts?.contents ?? operations.zero(LyricFont.schema.contents);
  }
  /** Gets @type {LyricFontAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {LyricFontAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): LyricFont {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {LyricFontAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {LyricFontAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): LyricFont {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {LyricFontAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {LyricFontAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): LyricFont {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {LyricFontAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {LyricFontAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): LyricFont {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {LyricFontAttributes['name']}. */
  getName(): string | null {
    return this.attributes['name'];
  }
  /** Sets @type {LyricFontAttributes['name']}. */
  setName(name: string | null): LyricFont {
    this.attributes['name'] = name;
    return this;
  }
  /** Gets @type {LyricFontAttributes['number']}. */
  getNumber(): string | null {
    return this.attributes['number'];
  }
  /** Sets @type {LyricFontAttributes['number']}. */
  setNumber(number: string | null): LyricFont {
    this.attributes['number'] = number;
    return this;
  }
}

export type LyricLanguageAttributes = {
  /**
   * The default language for the specified lyric name and number.
   */
  'xml:lang': string;
  /**
   * The lyric name for which this is the default, corresponding to the name attribute in the `<lyric>` element.
   */
  name: string | null;
  /**
   * The lyric number for which this is the default, corresponding to the number attribute in the `<lyric>` element.
   */
  number: string | null;
};

export type LyricLanguageContents = [];

/**
 * The `<lyric-language>` element
 *
 * Parent element: `<defaults>`
 *
 * The `<lyric-language>` element specifies the default language for a particular name and number of lyric.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/lyric-language/}
 */
export class LyricLanguage implements XMLElement<'lyric-language', LyricLanguageAttributes, LyricLanguageContents> {
  static readonly schema = {
    name: 'lyric-language',
    attributes: {
      'xml:lang': { type: 'required', value: { type: 'string' } },
      name: { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = LyricLanguage.schema;

  attributes: LyricLanguageAttributes;
  contents: LyricLanguageContents;

  constructor(opts?: { attributes?: Partial<LyricLanguageAttributes>; contents?: LyricLanguageContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LyricLanguage.schema);
    this.contents = opts?.contents ?? operations.zero(LyricLanguage.schema.contents);
  }
  /** Gets @type {LyricLanguageAttributes['xml:lang']}. */
  getXmlLang(): string {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {LyricLanguageAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string): LyricLanguage {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {LyricLanguageAttributes['name']}. */
  getName(): string | null {
    return this.attributes['name'];
  }
  /** Sets @type {LyricLanguageAttributes['name']}. */
  setName(name: string | null): LyricLanguage {
    this.attributes['name'] = name;
    return this;
  }
  /** Gets @type {LyricLanguageAttributes['number']}. */
  getNumber(): string | null {
    return this.attributes['number'];
  }
  /** Sets @type {LyricLanguageAttributes['number']}. */
  setNumber(number: string | null): LyricLanguage {
    this.attributes['number'] = number;
    return this;
  }
}

export type DefaultsAttributes = Record<string, unknown>;

export type DefaultsContents = [
  Scaling | null,
  ConcertScore | null,
  PageLayout | null,
  SystemLayout | null,
  Array<StaffLayout>,
  Appearance | null,
  MusicFont | null,
  WordFont | null,
  Array<LyricFont>,
  Array<LyricLanguage>,
];

/**
 * The `<defautls>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<defaults>` element specifies score-wide defaults for scaling; whether or not the file is a concert score;
 * layout; and default values for the music font, word font, lyric font, and lyric language. Except for the
 * `<concert-score>` element, if any defaults are missing, the choice of what to use is determined by the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/defaults/}
 */
export class Defaults implements XMLElement<'defaults', DefaultsAttributes, DefaultsContents> {
  static readonly schema = {
    name: 'defaults',
    attributes: {},
    contents: [
      { type: 'optional', value: Scaling },
      { type: 'optional', value: ConcertScore },
      { type: 'optional', value: PageLayout },
      { type: 'optional', value: SystemLayout },
      { type: 'label', label: 'staff-layouts', value: { type: 'zeroOrMore', value: StaffLayout } },
      { type: 'optional', value: Appearance },
      { type: 'optional', value: MusicFont },
      { type: 'optional', value: WordFont },
      { type: 'label', label: 'lyric-fonts', value: { type: 'zeroOrMore', value: LyricFont } },
      { type: 'label', label: 'lyric-languages', value: { type: 'zeroOrMore', value: LyricLanguage } },
    ],
  } as const;

  readonly schema = Defaults.schema;

  attributes: DefaultsAttributes;
  contents: DefaultsContents;

  constructor(opts?: { attributes?: Partial<DefaultsAttributes>; contents?: DefaultsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Defaults.schema);
    this.contents = opts?.contents ?? operations.zero(Defaults.schema.contents);
  }

  /** Gets @type {Scaling | null}. */
  getScaling(): Scaling | null {
    return this.contents[0];
  }
  /** Sets @type {Scaling | null}. */
  setScaling(scaling: Scaling | null): this {
    this.contents[0] = scaling;
    return this;
  }
  /** Gets @type {ConcertScore | null}. */
  getConcertScore(): ConcertScore | null {
    return this.contents[1];
  }
  /** Sets @type {ConcertScore | null}. */
  setConcertScore(concertScore: ConcertScore | null): this {
    this.contents[1] = concertScore;
    return this;
  }
  /** Gets @type {PageLayout | null}. */
  getPageLayout(): PageLayout | null {
    return this.contents[2];
  }
  /** Sets @type {PageLayout | null}. */
  setPageLayout(pageLayout: PageLayout | null): this {
    this.contents[2] = pageLayout;
    return this;
  }
  /** Gets @type {SystemLayout | null}. */
  getSystemLayout(): SystemLayout | null {
    return this.contents[3];
  }
  /** Sets @type {SystemLayout | null}. */
  setSystemLayout(systemLayout: SystemLayout | null): this {
    this.contents[3] = systemLayout;
    return this;
  }
  /** Gets @type {Array<StaffLayout>}. */
  getStaffLayouts(): Array<StaffLayout> {
    return this.contents[4];
  }
  /** Sets @type {Array<StaffLayout>}. */
  setStaffLayouts(staffLayouts: Array<StaffLayout>): this {
    this.contents[4] = staffLayouts;
    return this;
  }
  /** Gets @type {Appearance | null}. */
  getAppearance(): Appearance | null {
    return this.contents[5];
  }
  /** Sets @type {Appearance | null}. */
  setAppearance(appearance: Appearance | null): this {
    this.contents[5] = appearance;
    return this;
  }
  /** Gets @type {MusicFont | null}. */
  getMusicFont(): MusicFont | null {
    return this.contents[6];
  }
  /** Sets @type {MusicFont | null}. */
  setMusicFont(musicFont: MusicFont | null): this {
    this.contents[6] = musicFont;
    return this;
  }
  /** Gets @type {WordFont | null}. */
  getWordFont(): WordFont | null {
    return this.contents[7];
  }
  /** Sets @type {WordFont | null}. */
  setWordFont(wordFont: WordFont | null): this {
    this.contents[7] = wordFont;
    return this;
  }
  /** Gets @type {Array<LyricFont>}. */
  getLyricFonts(): Array<LyricFont> {
    return this.contents[8];
  }
  /** Sets @type {Array<LyricFont>}. */
  setLyricFonts(lyricFonts: Array<LyricFont>): this {
    this.contents[8] = lyricFonts;
    return this;
  }
  /** Gets @type {Array<LyricLanguage>}. */
  getLyricLanguages(): Array<LyricLanguage> {
    return this.contents[9];
  }
  /** Sets @type {Array<LyricLanguage>}. */
  setLyricLanguages(lyricLanguages: Array<LyricLanguage>): this {
    this.contents[9] = lyricLanguages;
    return this;
  }
}

export type CreditTypeAttributes = Record<string, unknown>;

export type CreditTypeContents = [string];

/**
 * The `<credit-type>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-type>` element indicates the purpose behind a credit. Multiple types of data may be combined in a single
 * credit, so multiple elements may be used. Standard values include:
 *
 * - page number
 * - title
 * - subtitle
 * - composer
 * - arranger
 * - lyricist
 * - rights
 * - part name
 *
 * Other values may also be used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-type/}
 */
export class CreditType implements XMLElement<'credit-type', CreditTypeAttributes, CreditTypeContents> {
  static readonly schema = {
    name: 'credit-type',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = CreditType.schema;

  attributes: CreditTypeAttributes;
  contents: CreditTypeContents;

  constructor(opts?: { attributes?: Partial<CreditTypeAttributes>; contents?: CreditTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditType.schema);
    this.contents = opts?.contents ?? operations.zero(CreditType.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type LinkAttributes = {
  /**
   * The href attribute provides the data that allows an application to find a remote resource or resource fragment.
   * See the [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-locators)
   */
  'xlink:href': string;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the start of the
   * entire current measure, at either the left barline or the start of the system. Positive x is right and negative
   * x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * The element attribute specifies an element type for a descendant of the next sibling element that is not a
   * `<link>` or `<bookmark>` element. When not present, the `<bookmark>` or `<link>` element refers to the next
   * sibling element in the MusicXML file.
   */
  element: string | null;
  /**
   * The name of this link.
   */
  name: string | null;
  /**
   * The position attribute specifies the position of the descendant element specified by the element attribute,
   * where the first position is 1. The position attribute is ignored if the element attribute is not present.
   *
   * For instance, an element value of "beam" and a position value of "2" defines the `<link>` or `<bookmark>` to
   * refer to the second beam descendant of the next sibling element that is not a `<link>` or `<bookmark>` element.
   * This is equivalent to an XPath test of [.//beam[2]] done in the context of the sibling element.
   */
  position: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down. It should be interpreted
   * in the context of the placement attribute if that is present.
   */
  'relative-y': number | null;
  /**
   * The actuate attribute is used to communicate the desired timing of traversal from the starting resource to the
   * ending resource. The default value is onRequest. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-behaviors)
   */
  'xlink:actuate': 'none' | 'onRequest' | 'onLoad' | 'other' | null;
  /**
   * The role attribute indicates a property of the link. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-semantics)
   */
  'xlink:role': string | null;
  /**
   * The show attribute is used to communicate the desired presentation of the ending resource on traversal from the
   * starting resource. The default value is replace. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-behaviors)
   */
  'xlink:show': 'none' | 'new' | 'replace' | 'embed' | 'other' | null;
  /**
   * The title attribute describes the meaning of a link or resource in a human-readable fashion. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-semantics)
   */
  'xlink:title': string | null;
  /**
   * The type attribute identifies XLink element types. In MusicXML, the value is always simple. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-types)
   */
  'xlink:type': 'simple' | null;
};

export type LinkContents = [];

/**
 * The `<link>` element
 *
 * Parent elements: `<credit>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<link>` element serves as an outgoing simple XLink. If a relative link is used within a document that is part of
 * a compressed MusicXML file, the link is relative to the root folder of the zip file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/link/}
 */
export class Link implements XMLElement<'link', LinkAttributes, LinkContents> {
  static readonly schema = {
    name: 'link',
    attributes: {
      'xlink:href': { type: 'required', value: { type: 'string' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      element: { type: 'optional', value: { type: 'string' } },
      name: { type: 'optional', value: { type: 'string' } },
      position: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'xlink:actuate': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
      },
      'xlink:role': { type: 'optional', value: { type: 'string' } },
      'xlink:show': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
      },
      'xlink:title': { type: 'optional', value: { type: 'string' } },
      'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
    },
    contents: [],
  } as const;

  readonly schema = Link.schema;

  attributes: LinkAttributes;
  contents: LinkContents;

  constructor(opts?: { attributes?: Partial<LinkAttributes>; contents?: LinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Link.schema);
    this.contents = opts?.contents ?? operations.zero(Link.schema.contents);
  }
  /** Gets @type {LinkAttributes['xlink:href']}. */
  getXlinkHref(): string {
    return this.attributes['xlink:href'];
  }
  /** Sets @type {LinkAttributes['xlink:href']}. */
  setXlinkHref(xlinkHref: string): Link {
    this.attributes['xlink:href'] = xlinkHref;
    return this;
  }
  /** Gets @type {LinkAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {LinkAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Link {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {LinkAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {LinkAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Link {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {LinkAttributes['element']}. */
  getElement(): string | null {
    return this.attributes['element'];
  }
  /** Sets @type {LinkAttributes['element']}. */
  setElement(element: string | null): Link {
    this.attributes['element'] = element;
    return this;
  }
  /** Gets @type {LinkAttributes['name']}. */
  getName(): string | null {
    return this.attributes['name'];
  }
  /** Sets @type {LinkAttributes['name']}. */
  setName(name: string | null): Link {
    this.attributes['name'] = name;
    return this;
  }
  /** Gets @type {LinkAttributes['position']}. */
  getPosition(): number | null {
    return this.attributes['position'];
  }
  /** Sets @type {LinkAttributes['position']}. */
  setPosition(position: number | null): Link {
    this.attributes['position'] = position;
    return this;
  }
  /** Gets @type {LinkAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {LinkAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Link {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {LinkAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {LinkAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Link {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {LinkAttributes['xlink:actuate']}. */
  getXlinkActuate(): 'none' | 'onRequest' | 'onLoad' | 'other' | null {
    return this.attributes['xlink:actuate'];
  }
  /** Sets @type {LinkAttributes['xlink:actuate']}. */
  setXlinkActuate(xlinkActuate: 'none' | 'onRequest' | 'onLoad' | 'other' | null): Link {
    this.attributes['xlink:actuate'] = xlinkActuate;
    return this;
  }
  /** Gets @type {LinkAttributes['xlink:role']}. */
  getXlinkRole(): string | null {
    return this.attributes['xlink:role'];
  }
  /** Sets @type {LinkAttributes['xlink:role']}. */
  setXlinkRole(xlinkRole: string | null): Link {
    this.attributes['xlink:role'] = xlinkRole;
    return this;
  }
  /** Gets @type {LinkAttributes['xlink:show']}. */
  getXlinkShow(): 'none' | 'new' | 'replace' | 'embed' | 'other' | null {
    return this.attributes['xlink:show'];
  }
  /** Sets @type {LinkAttributes['xlink:show']}. */
  setXlinkShow(xlinkShow: 'none' | 'new' | 'replace' | 'embed' | 'other' | null): Link {
    this.attributes['xlink:show'] = xlinkShow;
    return this;
  }
  /** Gets @type {LinkAttributes['xlink:title']}. */
  getXlinkTitle(): string | null {
    return this.attributes['xlink:title'];
  }
  /** Sets @type {LinkAttributes['xlink:title']}. */
  setXlinkTitle(xlinkTitle: string | null): Link {
    this.attributes['xlink:title'] = xlinkTitle;
    return this;
  }
  /** Gets @type {LinkAttributes['xlink:type']}. */
  getXlinkType(): 'simple' | null {
    return this.attributes['xlink:type'];
  }
  /** Sets @type {LinkAttributes['xlink:type']}. */
  setXlinkType(xlinkType: 'simple' | null): Link {
    this.attributes['xlink:type'] = xlinkType;
    return this;
  }
}

export type BookmarkAttributes = {
  /**
   * The identifier for this bookmark, unique within this document.
   */
  id: string;
  /**
   * The element attribute specifies an element type for a descendant of the next sibling element that is not a
   * `<link>` or `<bookmark>` element. When not present, the `<bookmark>` or `<link>` element refers to the next
   * sibling element in the MusicXML file.
   */
  element: string | null;
  /**
   * The name for this bookmark.
   */
  name: string | null;
  /**
   * The position attribute specifies the position of the descendant element specified by the element attribute,
   * where the first position is 1. The position attribute is ignored if the element attribute is not present.
   *
   * For instance, an element value of "beam" and a position value of "2" defines the `<link>` or `<bookmark>` to
   * refer to the second beam descendant of the next sibling element that is not a <link> or <bookmark> element.
   * This is equivalent to an XPath test of [.//beam[2]] done in the context of the sibling element.
   */
  position: number | null;
};

export type BookmarkContents = [];

/**
 * The `<bookmark>` element
 *
 * Parent elements: `<credit>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<bookmark>` element serves as a well-defined target for an incoming simple XLink.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bookmark/}
 */
export class Bookmark implements XMLElement<'bookmark', BookmarkAttributes, BookmarkContents> {
  static readonly schema = {
    name: 'bookmark',
    attributes: {
      id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      element: { type: 'optional', value: { type: 'string' } },
      name: { type: 'optional', value: { type: 'string' } },
      position: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Bookmark.schema;

  attributes: BookmarkAttributes;
  contents: BookmarkContents;

  constructor(opts?: { attributes?: Partial<BookmarkAttributes>; contents?: BookmarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bookmark.schema);
    this.contents = opts?.contents ?? operations.zero(Bookmark.schema.contents);
  }
  /** Gets @type {BookmarkAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {BookmarkAttributes['id']}. */
  setId(id: string): Bookmark {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {BookmarkAttributes['element']}. */
  getElement(): string | null {
    return this.attributes['element'];
  }
  /** Sets @type {BookmarkAttributes['element']}. */
  setElement(element: string | null): Bookmark {
    this.attributes['element'] = element;
    return this;
  }
  /** Gets @type {BookmarkAttributes['name']}. */
  getName(): string | null {
    return this.attributes['name'];
  }
  /** Sets @type {BookmarkAttributes['name']}. */
  setName(name: string | null): Bookmark {
    this.attributes['name'] = name;
    return this;
  }
  /** Gets @type {BookmarkAttributes['position']}. */
  getPosition(): number | null {
    return this.attributes['position'];
  }
  /** Sets @type {BookmarkAttributes['position']}. */
  setPosition(position: number | null): Bookmark {
    this.attributes['position'] = position;
    return this;
  }
}

export type CreditImageAttributes = {
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Indicates horizontal alignment to the left, center, or right of the image. Default is implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Used to size and scale an image. The image should be scaled independently in X and Y if both height and width
   * are specified. If only height is specified, the image should be scaled proportionally to fit in the specified Y
   * dimension.
   */
  height: number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The URL for the image file.
   */
  source: string | null;
  /**
   * The MIME type for the image file format. Typical choices include application/postscript, image/gif, image/jpeg,
   * image/png, and image/tiff.
   */
  type: string | null;
  /**
   * Indicates vertical alignment to the top, middle, or bottom of the image. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | null;
  /**
   * Used to size and scale an image. The image should be scaled independently in X and Y if both height and width
   * are specified. If only width is specified, the image should be scaled proportionally to fit in the specified X
   * dimension.
   */
  width: number | null;
};

export type CreditImageContents = [];

/**
 * The `<credit-image>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-image>` element is similar to the `<image>` element for a `<direction>`. However, since the `<credit>`
 * is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand
 * corner of the page.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-image/}
 */
export class CreditImage implements XMLElement<'credit-image', CreditImageAttributes, CreditImageContents> {
  static readonly schema = {
    name: 'credit-image',
    attributes: {
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      height: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      source: { type: 'optional', value: { type: 'string' } },
      type: { type: 'optional', value: { type: 'string' } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = CreditImage.schema;

  attributes: CreditImageAttributes;
  contents: CreditImageContents;

  constructor(opts?: { attributes?: Partial<CreditImageAttributes>; contents?: CreditImageContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditImage.schema);
    this.contents = opts?.contents ?? operations.zero(CreditImage.schema.contents);
  }
  /** Gets @type {CreditImageAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {CreditImageAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): CreditImage {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {CreditImageAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {CreditImageAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): CreditImage {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {CreditImageAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {CreditImageAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): CreditImage {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {CreditImageAttributes['height']}. */
  getHeight(): number | null {
    return this.attributes['height'];
  }
  /** Sets @type {CreditImageAttributes['height']}. */
  setHeight(height: number | null): CreditImage {
    this.attributes['height'] = height;
    return this;
  }
  /** Gets @type {CreditImageAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {CreditImageAttributes['id']}. */
  setId(id: string | null): CreditImage {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {CreditImageAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {CreditImageAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): CreditImage {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {CreditImageAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {CreditImageAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): CreditImage {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {CreditImageAttributes['source']}. */
  getSource(): string | null {
    return this.attributes['source'];
  }
  /** Sets @type {CreditImageAttributes['source']}. */
  setSource(source: string | null): CreditImage {
    this.attributes['source'] = source;
    return this;
  }
  /** Gets @type {CreditImageAttributes['type']}. */
  getType(): string | null {
    return this.attributes['type'];
  }
  /** Sets @type {CreditImageAttributes['type']}. */
  setType(type: string | null): CreditImage {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {CreditImageAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {CreditImageAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | null): CreditImage {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {CreditImageAttributes['width']}. */
  getWidth(): number | null {
    return this.attributes['width'];
  }
  /** Sets @type {CreditImageAttributes['width']}. */
  setWidth(width: number | null): CreditImage {
    this.attributes['width'] = width;
    return this;
  }
}

export type CreditWordsAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  /**
   * Specifies the language used in the element content. It is Italian ("it") if not specified.
   */
  'xml:lang': string | null;
  /**
   * Indicates whether white space should be preserved by applications.
   */
  'xml:space': 'default' | 'preserve' | null;
};

export type CreditWordsContents = [string];

/**
 * The `<credit-words>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-words>` element is similar to the `<words>` element for a `<direction>`. However, since the `<credit>`
 * is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand
 * corner of the page. The enclosure is none if not specified.
 *
 * By default, a series of `<credit-words>` and `<credit-symbol>` elements within a single `<credit>` element follow one
 * another in sequence visually. Non-positional formatting attributes are carried over from the previous element by
 * default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-words/}
 */
export class CreditWords implements XMLElement<'credit-words', CreditWordsAttributes, CreditWordsContents> {
  static readonly schema = {
    name: 'credit-words',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = CreditWords.schema;

  attributes: CreditWordsAttributes;
  contents: CreditWordsContents;

  constructor(opts?: { attributes?: Partial<CreditWordsAttributes>; contents?: CreditWordsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditWords.schema);
    this.contents = opts?.contents ?? operations.zero(CreditWords.schema.contents);
  }
  /** Gets @type {CreditWordsAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {CreditWordsAttributes['color']}. */
  setColor(color: string | null): CreditWords {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {CreditWordsAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): CreditWords {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {CreditWordsAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): CreditWords {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {CreditWordsAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): CreditWords {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {CreditWordsAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): CreditWords {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {CreditWordsAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): CreditWords {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {CreditWordsAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): CreditWords {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {CreditWordsAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): CreditWords {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {CreditWordsAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): CreditWords {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {CreditWordsAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): CreditWords {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {CreditWordsAttributes['id']}. */
  setId(id: string | null): CreditWords {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {CreditWordsAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): CreditWords {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {CreditWordsAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): CreditWords {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {CreditWordsAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): CreditWords {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {CreditWordsAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): CreditWords {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {CreditWordsAttributes['overline']}. */
  setOverline(overline: number | null): CreditWords {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {CreditWordsAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): CreditWords {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {CreditWordsAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): CreditWords {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {CreditWordsAttributes['rotation']}. */
  setRotation(rotation: number | null): CreditWords {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {CreditWordsAttributes['underline']}. */
  setUnderline(underline: number | null): CreditWords {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {CreditWordsAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): CreditWords {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {CreditWordsAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): CreditWords {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {CreditWordsAttributes['xml:space']}. */
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  /** Sets @type {CreditWordsAttributes['xml:space']}. */
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): CreditWords {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type CreditSymbolAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type CreditSymbolContents = [string];

/**
 * The `<credit-symbol>` element
 *
 * Parent element: `<credit>`
 *
 * The `<credit-symbol>` element is similar to the `<symbol>` element for a `<direction>`. However, since the `<credit>`
 * is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand
 * corner of the page. The enclosure is none if not specified.
 *
 * By default, a series of `<credit-words>` and `<credit-symbol>` elements within a single `<credit>` element follow one
 * another in sequence visually. Non-positional formatting attributes are carried over from the previous element by
 * default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit-symbol/}
 */
export class CreditSymbol implements XMLElement<'credit-symbol', CreditSymbolAttributes, CreditSymbolContents> {
  static readonly schema = {
    name: 'credit-symbol',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = CreditSymbol.schema;

  attributes: CreditSymbolAttributes;
  contents: CreditSymbolContents;

  constructor(opts?: { attributes?: Partial<CreditSymbolAttributes>; contents?: CreditSymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CreditSymbol.schema);
    this.contents = opts?.contents ?? operations.zero(CreditSymbol.schema.contents);
  }
  /** Gets @type {CreditSymbolAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {CreditSymbolAttributes['color']}. */
  setColor(color: string | null): CreditSymbol {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {CreditSymbolAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): CreditSymbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {CreditSymbolAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): CreditSymbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {CreditSymbolAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): CreditSymbol {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {CreditSymbolAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): CreditSymbol {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {CreditSymbolAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): CreditSymbol {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {CreditSymbolAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): CreditSymbol {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {CreditSymbolAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): CreditSymbol {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {CreditSymbolAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): CreditSymbol {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {CreditSymbolAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): CreditSymbol {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {CreditSymbolAttributes['id']}. */
  setId(id: string | null): CreditSymbol {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {CreditSymbolAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): CreditSymbol {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {CreditSymbolAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): CreditSymbol {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {CreditSymbolAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): CreditSymbol {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {CreditSymbolAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): CreditSymbol {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {CreditSymbolAttributes['overline']}. */
  setOverline(overline: number | null): CreditSymbol {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {CreditSymbolAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): CreditSymbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {CreditSymbolAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): CreditSymbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {CreditSymbolAttributes['rotation']}. */
  setRotation(rotation: number | null): CreditSymbol {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {CreditSymbolAttributes['underline']}. */
  setUnderline(underline: number | null): CreditSymbol {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {CreditSymbolAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {CreditSymbolAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): CreditSymbol {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type CreditToken = [
  CreditWords | CreditSymbol,
  Array<[Array<Link>, Array<Bookmark>, CreditWords | CreditSymbol]>,
];

export type CreditAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies the page number where the `<credit>` should appear. This is an integer value that starts with 1 for
   * the first page. Its value is 1 if not specified. Since credits occur before the music, these page numbers do
   * not refer to the page numbering specified by the `<print>` element's page-number attribute.
   */
  page: number | null;
};

export type CreditContents = [Array<CreditType>, Array<Link>, Array<Bookmark>, CreditImage | CreditToken];

/**
 * The `<credit>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<credit>` element represents the appearance of the title, composer, arranger, lyricist, copyright, dedication,
 * and other text, symbols, and graphics that commonly appear on the first page of a score. The `<credit-words>`,
 * `<credit-symbol>`, and `<credit-image>` elements are similar to the `<words>`, `<symbol>`, and `<image>` elements for
 * directions. However, since the credit is not part of a measure, the default-x and default-y attributes adjust the
 * origin relative to the bottom left-hand corner of the page. The enclosure for `<credit-words>` and `<credit-symbol>`
 * is none if not specified.
 *
 * By default, a series of `<credit-words>` and `<credit-symbol>` elements within a single `<credit>` element follow one
 * another in sequence visually. Non-positional formatting attributes are carried over from the previous element by
 * default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/credit/}
 */
export class Credit implements XMLElement<'credit', CreditAttributes, CreditContents> {
  static readonly schema = {
    name: 'credit',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      page: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      { type: 'label', label: 'credit-types', value: { type: 'zeroOrMore', value: CreditType } },
      { type: 'label', label: 'links', value: { type: 'zeroOrMore', value: Link } },
      { type: 'label', label: 'bookmarks', value: { type: 'zeroOrMore', value: Bookmark } },
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'choices',
          choices: [
            CreditImage,
            {
              type: 'label',
              label: 'credit-token',
              value: [
                { type: 'choices', choices: [CreditWords, CreditSymbol] },
                {
                  type: 'zeroOrMore',
                  value: [
                    { type: 'zeroOrMore', value: Link },
                    { type: 'zeroOrMore', value: Bookmark },
                    { type: 'choices', choices: [CreditWords, CreditSymbol] },
                  ],
                },
              ],
            },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Credit.schema;

  attributes: CreditAttributes;
  contents: CreditContents;

  constructor(opts?: { attributes?: Partial<CreditAttributes>; contents?: CreditContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Credit.schema);
    this.contents = opts?.contents ?? operations.zero(Credit.schema.contents);
  }
  /** Gets @type {CreditAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {CreditAttributes['id']}. */
  setId(id: string | null): Credit {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {CreditAttributes['page']}. */
  getPage(): number | null {
    return this.attributes['page'];
  }
  /** Sets @type {CreditAttributes['page']}. */
  setPage(page: number | null): Credit {
    this.attributes['page'] = page;
    return this;
  }
  /** Gets @type {Array<CreditType>}. */
  getCreditTypes(): Array<CreditType> {
    return this.contents[0];
  }
  /** Sets @type {Array<CreditType>}. */
  setCreditTypes(creditTypes: Array<CreditType>): this {
    this.contents[0] = creditTypes;
    return this;
  }
  /** Gets @type {Array<Link>}. */
  getLinks(): Array<Link> {
    return this.contents[1];
  }
  /** Sets @type {Array<Link>}. */
  setLinks(links: Array<Link>): this {
    this.contents[1] = links;
    return this;
  }
  /** Gets @type {Array<Bookmark>}. */
  getBookmarks(): Array<Bookmark> {
    return this.contents[2];
  }
  /** Sets @type {Array<Bookmark>}. */
  setBookmarks(bookmarks: Array<Bookmark>): this {
    this.contents[2] = bookmarks;
    return this;
  }
  /** Gets @type {CreditImage | CreditToken}. */
  getValue(): CreditImage | CreditToken {
    return this.contents[3];
  }
  /** Sets @type {CreditImage | CreditToken}. */
  setValue(value: CreditImage | CreditToken): this {
    this.contents[3] = value;
    return this;
  }
}

export type GroupNameAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the start of the
   * entire current measure, at either the left barline or the start of the system. Positive x is right and negative
   * x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the `<offset>` element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down. It should be interpreted
   * in the context of the placement attribute if that is present.
   */
  'relative-y': number | null;
};

export type GroupNameContents = [string];

/**
 * The `<group-name>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-name>` element describes the name of a <part-group> element. The formatting attributes are deprecated as
 * of Version 2.0 in favor of the new `<group-name-display>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-name/}
 */
export class GroupName implements XMLElement<'group-name', GroupNameAttributes, GroupNameContents> {
  static readonly schema = {
    name: 'group-name',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = GroupName.schema;

  attributes: GroupNameAttributes;
  contents: GroupNameContents;

  constructor(opts?: { attributes?: Partial<GroupNameAttributes>; contents?: GroupNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupName.schema);
    this.contents = opts?.contents ?? operations.zero(GroupName.schema.contents);
  }
  /** Gets @type {GroupNameAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {GroupNameAttributes['color']}. */
  setColor(color: string | null): GroupName {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {GroupNameAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {GroupNameAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): GroupName {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {GroupNameAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {GroupNameAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): GroupName {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {GroupNameAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {GroupNameAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): GroupName {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {GroupNameAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {GroupNameAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): GroupName {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {GroupNameAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {GroupNameAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): GroupName {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {GroupNameAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {GroupNameAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): GroupName {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {GroupNameAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {GroupNameAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): GroupName {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {GroupNameAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {GroupNameAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): GroupName {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {GroupNameAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {GroupNameAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): GroupName {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type DisplayTextAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  /**
   * Specifies the language used in the element content. It is Italian ("it") if not specified.
   */
  'xml:lang': string | null;
  /**
   * Indicates whether white space should be preserved by applications.
   */
  'xml:space': 'default' | 'preserve' | null;
};

export type DisplayTextContents = [string | null];

/**
 * The `<display-text>` element
 *
 * Parent elements: `<group-abbreviation-display>`, `<group-name-display>`, `<notehead-text>`,
 * `<part-abbreviation-display>`, `<part-name-display>`
 *
 * The `<display-text>` element is used for exact formatting of multi-font text in element in display elements such as
 * `<part-name-display>`. The enclosure attribute is none if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/display-text/}
 */
export class DisplayText implements XMLElement<'display-text', DisplayTextAttributes, DisplayTextContents> {
  static readonly schema = {
    name: 'display-text',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = DisplayText.schema;

  attributes: DisplayTextAttributes;
  contents: DisplayTextContents;

  constructor(opts?: { attributes?: Partial<DisplayTextAttributes>; contents?: DisplayTextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DisplayText.schema);
    this.contents = opts?.contents ?? operations.zero(DisplayText.schema.contents);
  }
  /** Gets @type {DisplayTextAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DisplayTextAttributes['color']}. */
  setColor(color: string | null): DisplayText {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DisplayTextAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DisplayText {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DisplayTextAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DisplayText {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {DisplayTextAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): DisplayText {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {DisplayTextAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): DisplayText {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DisplayTextAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DisplayText {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DisplayTextAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DisplayText {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DisplayTextAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DisplayText {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DisplayTextAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DisplayText {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {DisplayTextAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): DisplayText {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {DisplayTextAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): DisplayText {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {DisplayTextAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): DisplayText {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {DisplayTextAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): DisplayText {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {DisplayTextAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): DisplayText {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {DisplayTextAttributes['overline']}. */
  setOverline(overline: number | null): DisplayText {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DisplayTextAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DisplayText {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DisplayTextAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DisplayText {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {DisplayTextAttributes['rotation']}. */
  setRotation(rotation: number | null): DisplayText {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {DisplayTextAttributes['underline']}. */
  setUnderline(underline: number | null): DisplayText {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {DisplayTextAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): DisplayText {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {DisplayTextAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): DisplayText {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {DisplayTextAttributes['xml:space']}. */
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  /** Sets @type {DisplayTextAttributes['xml:space']}. */
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): DisplayText {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  /** Gets @type {string | null}. */
  getText(): string | null {
    return this.contents[0];
  }
  /** Sets @type {string | null}. */
  setText(text: string | null): this {
    this.contents[0] = text;
    return this;
  }
}

export type AccidentalTextAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Specifies the exact Standard Music Font Layout (SMuFL) accidental character, using its SMuFL canonical glyph
   * name.
   */
  smufl: string | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  /**
   * Specifies the language used in the element content. It is Italian ("it") if not specified.
   */
  'xml:lang': string | null;
  /**
   * Indicates whether white space should be preserved by applications.
   */
  'xml:space': 'default' | 'preserve' | null;
};

export type AccidentalTextContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron',
];

/**
 * The `<accidental-text>` element
 *
 * Parent elements: `<group-abbreviation-display>`, `<group-name-display>`, `<notehead-text>`,
 * `<part-abbreviation-display>`, `<part-name-display>`
 *
 * The `<accidental-text>` element is used for exact formatting of accidentals in display elements such as
 * `<part-name-display>`. The enclosure attribute is none if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-name-display/}
 */
export class AccidentalText implements XMLElement<'accidental-text', AccidentalTextAttributes, AccidentalTextContents> {
  static readonly schema = {
    name: 'accidental-text',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'accidental-value',
        value: {
          type: 'choices',
          choices: [
            'other',
            'sharp',
            'natural',
            'flat',
            'double-sharp',
            'sharp-sharp',
            'flat-flat',
            'natural-sharp',
            'natural-flat',
            'quarter-flat',
            'quarter-sharp',
            'three-quarters-flat',
            'three-quarters-sharp',
            'sharp-down',
            'sharp-up',
            'natural-down',
            'natural-up',
            'flat-down',
            'flat-up',
            'double-sharp-down',
            'double-sharp-up',
            'flat-flat-down',
            'flat-flat-up',
            'arrow-down',
            'arrow-up',
            'triple-sharp',
            'triple-flat',
            'slash-quarter-sharp',
            'slash-sharp',
            'slash-flat',
            'double-slash-flat',
            'sharp-1',
            'sharp-2',
            'sharp-3',
            'sharp-5',
            'flat-1',
            'flat-2',
            'flat-3',
            'flat-4',
            'sori',
            'koron',
          ],
        },
      },
    ],
  } as const;

  readonly schema = AccidentalText.schema;

  attributes: AccidentalTextAttributes;
  contents: AccidentalTextContents;

  constructor(opts?: { attributes?: Partial<AccidentalTextAttributes>; contents?: AccidentalTextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccidentalText.schema);
    this.contents = opts?.contents ?? operations.zero(AccidentalText.schema.contents);
  }
  /** Gets @type {AccidentalTextAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {AccidentalTextAttributes['color']}. */
  setColor(color: string | null): AccidentalText {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {AccidentalTextAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): AccidentalText {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {AccidentalTextAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): AccidentalText {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {AccidentalTextAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): AccidentalText {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {AccidentalTextAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): AccidentalText {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {AccidentalTextAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): AccidentalText {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {AccidentalTextAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): AccidentalText {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {AccidentalTextAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): AccidentalText {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {AccidentalTextAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): AccidentalText {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {AccidentalTextAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): AccidentalText {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {AccidentalTextAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): AccidentalText {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {AccidentalTextAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): AccidentalText {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {AccidentalTextAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): AccidentalText {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {AccidentalTextAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): AccidentalText {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {AccidentalTextAttributes['overline']}. */
  setOverline(overline: number | null): AccidentalText {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {AccidentalTextAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): AccidentalText {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {AccidentalTextAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): AccidentalText {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {AccidentalTextAttributes['rotation']}. */
  setRotation(rotation: number | null): AccidentalText {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {AccidentalTextAttributes['smufl']}. */
  setSmufl(smufl: string | null): AccidentalText {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {AccidentalTextAttributes['underline']}. */
  setUnderline(underline: number | null): AccidentalText {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {AccidentalTextAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): AccidentalText {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {AccidentalTextAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): AccidentalText {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {AccidentalTextAttributes['xml:space']}. */
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  /** Sets @type {AccidentalTextAttributes['xml:space']}. */
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): AccidentalText {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): this {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type GroupNameDisplayAttributes = {
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
};

export type GroupNameDisplayContents = [Array<DisplayText | AccidentalText>];

/**
 * The `<group-name-display>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-name-display>` element is used for exact formatting of multi-font text in group names to the left of the
 * system. The print-object attribute can be used to determine what, if anything, is printed at the start of each
 * system.
 *
 * Formatting specified in the `<group-name-display>` element overrides formatting specified in the `<group-name>`
 * element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-name-display/}
 */
export class GroupNameDisplay
  implements XMLElement<'group-name-display', GroupNameDisplayAttributes, GroupNameDisplayContents>
{
  static readonly schema = {
    name: 'group-name-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = GroupNameDisplay.schema;

  attributes: GroupNameDisplayAttributes;
  contents: GroupNameDisplayContents;

  constructor(opts?: { attributes?: Partial<GroupNameDisplayAttributes>; contents?: GroupNameDisplayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupNameDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(GroupNameDisplay.schema.contents);
  }
  /** Gets @type {GroupNameDisplayAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {GroupNameDisplayAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): GroupNameDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {Array<DisplayText | AccidentalText>}. */
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  /** Sets @type {Array<DisplayText | AccidentalText>}. */
  setTexts(texts: Array<DisplayText | AccidentalText>): this {
    this.contents[0] = texts;
    return this;
  }
}

export type GroupAbbreviationAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type GroupAbbreviationContents = [string];

/**
 * The `<group-abbreviation>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-abbreviation>` element describes the abbreviation of a `<part-group>` element. The formatting attributes
 * are deprecated as of Version 2.0 in favor of the new `<group-abbreviation-display>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-abbreviation/}
 */
export class GroupAbbreviation
  implements XMLElement<'group-abbreviation', GroupAbbreviationAttributes, GroupAbbreviationContents>
{
  static readonly schema = {
    name: 'group-abbreviation',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = GroupAbbreviation.schema;

  attributes: GroupAbbreviationAttributes;
  contents: GroupAbbreviationContents;

  constructor(opts?: { attributes?: Partial<GroupAbbreviationAttributes>; contents?: GroupAbbreviationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupAbbreviation.schema);
    this.contents = opts?.contents ?? operations.zero(GroupAbbreviation.schema.contents);
  }
  /** Gets @type {GroupAbbreviationAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {GroupAbbreviationAttributes['color']}. */
  setColor(color: string | null): GroupAbbreviation {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {GroupAbbreviationAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): GroupAbbreviation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {GroupAbbreviationAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): GroupAbbreviation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {GroupAbbreviationAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): GroupAbbreviation {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {GroupAbbreviationAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): GroupAbbreviation {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {GroupAbbreviationAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): GroupAbbreviation {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {GroupAbbreviationAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): GroupAbbreviation {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {GroupAbbreviationAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): GroupAbbreviation {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {GroupAbbreviationAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): GroupAbbreviation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {GroupAbbreviationAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {GroupAbbreviationAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): GroupAbbreviation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type GroupAbbreviationDisplayAttributes = {
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
};

export type GroupAbbreviationDisplayContents = [Array<DisplayText | AccidentalText>];

/**
 * The `<group-abbreviation-display> element`
 *
 * Parent element: `<part-group>`
 *
 * The `<group-abbreviation-display> element is used for exact formatting of multi-font text in group abbreviations to
 * the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the
 * start of each system.`
 *
 * Formatting specified in the `<group-abbreviation-display> element overrides formatting specified in the
 * `<group-abbreviation> element.`
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-abbreviation-display/}
 */
export class GroupAbbreviationDisplay
  implements
    XMLElement<'group-abbreviation-display', GroupAbbreviationDisplayAttributes, GroupAbbreviationDisplayContents>
{
  static readonly schema = {
    name: 'group-abbreviation-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = GroupAbbreviationDisplay.schema;

  attributes: GroupAbbreviationDisplayAttributes;
  contents: GroupAbbreviationDisplayContents;

  constructor(opts?: {
    attributes?: Partial<GroupAbbreviationDisplayAttributes>;
    contents?: GroupAbbreviationDisplayContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupAbbreviationDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(GroupAbbreviationDisplay.schema.contents);
  }
  /** Gets @type {GroupAbbreviationDisplayAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {GroupAbbreviationDisplayAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): GroupAbbreviationDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {Array<DisplayText | AccidentalText>}. */
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  /** Sets @type {Array<DisplayText | AccidentalText>}. */
  setTexts(texts: Array<DisplayText | AccidentalText>): this {
    this.contents[0] = texts;
    return this;
  }
}

export type GroupSymbolAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type GroupSymbolContents = ['none' | 'brace' | 'bracket' | 'line' | 'square'];

/**
 * The `<group-symbol>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-symbol>` element indicates how the symbol for a group is indicated in the score. It is none if not
 * specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-symbol/}
 */
export class GroupSymbol implements XMLElement<'group-symbol', GroupSymbolAttributes, GroupSymbolContents> {
  static readonly schema = {
    name: 'group-symbol',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'group-symbol-value',
          value: { type: 'choices', choices: ['none', 'brace', 'bracket', 'line', 'square'] },
        },
      },
    ],
  } as const;

  readonly schema = GroupSymbol.schema;

  attributes: GroupSymbolAttributes;
  contents: GroupSymbolContents;

  constructor(opts?: { attributes?: Partial<GroupSymbolAttributes>; contents?: GroupSymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupSymbol.schema);
    this.contents = opts?.contents ?? operations.zero(GroupSymbol.schema.contents);
  }
  /** Gets @type {GroupSymbolAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {GroupSymbolAttributes['color']}. */
  setColor(color: string | null): GroupSymbol {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {GroupSymbolAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {GroupSymbolAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): GroupSymbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {GroupSymbolAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {GroupSymbolAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): GroupSymbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {GroupSymbolAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {GroupSymbolAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): GroupSymbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {GroupSymbolAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {GroupSymbolAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): GroupSymbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
  getGroupSymbolValue(): 'none' | 'brace' | 'bracket' | 'line' | 'square' {
    return this.contents[0];
  }
  /** Sets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
  setGroupSymbolValue(groupSymbolValue: 'none' | 'brace' | 'bracket' | 'line' | 'square'): this {
    this.contents[0] = groupSymbolValue;
    return this;
  }
}

export type GroupBarlineAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
};

export type GroupBarlineContents = ['yes' | 'no' | 'Mensurstrich'];

/**
 * The `<group-barline>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-barline>` element indicates if the group should have common barlines.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-barline/}
 */
export class GroupBarline implements XMLElement<'group-barline', GroupBarlineAttributes, GroupBarlineContents> {
  static readonly schema = {
    name: 'group-barline',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'group-barline-value',
          value: { type: 'choices', choices: ['yes', 'no', 'Mensurstrich'] },
        },
      },
    ],
  } as const;

  readonly schema = GroupBarline.schema;

  attributes: GroupBarlineAttributes;
  contents: GroupBarlineContents;

  constructor(opts?: { attributes?: Partial<GroupBarlineAttributes>; contents?: GroupBarlineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupBarline.schema);
    this.contents = opts?.contents ?? operations.zero(GroupBarline.schema.contents);
  }
  /** Gets @type {GroupBarlineAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {GroupBarlineAttributes['color']}. */
  setColor(color: string | null): GroupBarline {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {'yes' | 'no' | 'Mensurstrich'}. */
  getGroupBarlineValue(): 'yes' | 'no' | 'Mensurstrich' {
    return this.contents[0];
  }
  /** Sets @type {'yes' | 'no' | 'Mensurstrich'}. */
  setGroupBarlineValue(groupBarlineValue: 'yes' | 'no' | 'Mensurstrich'): this {
    this.contents[0] = groupBarlineValue;
    return this;
  }
}

export type GroupTimeAttributes = Record<string, unknown>;

export type GroupTimeContents = [];

/**
 * The `<group-time>` element
 *
 * Parent element: `<part-group>`
 *
 * The `<group-time>` element indicates that the displayed time signatures should stretch across all parts and staves in
 * the group.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-time/}
 */
export class GroupTime implements XMLElement<'group-time', GroupTimeAttributes, GroupTimeContents> {
  static readonly schema = { name: 'group-time', attributes: {}, contents: [] } as const;

  readonly schema = GroupTime.schema;

  attributes: GroupTimeAttributes;
  contents: GroupTimeContents;

  constructor(opts?: { attributes?: Partial<GroupTimeAttributes>; contents?: GroupTimeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupTime.schema);
    this.contents = opts?.contents ?? operations.zero(GroupTime.schema.contents);
  }
}

export type FootnoteAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<part-group>` element, the
   * origin is changed relative to the start of the first measure on the system. Otherwise, the origin is changed
   * relative to the left-hand side of the note or the musical position within the bar. Positive x is right and
   * negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  /**
   * Specifies the language used in the element content. It is Italian ("it") if not specified.
   */
  'xml:lang': string | null;
  /**
   * Indicates whether white space should be preserved by applications.
   */
  'xml:space': 'default' | 'preserve' | null;
};

export type FootnoteContents = [string];

/**
 * The `<footnote>` element
 *
 * Parent elements: `<attributes>`, `<backup>`, `<barline>`, `<direction>`, `<figure>`, `<figured-bass>`, `<forward>`,
 * `<harmony>`, `<lyric>`, `<notations>`, `<note>`, `<part-group>`
 *
 * The `<footnote>` element specifies editorial information that appears in footnotes in the printed score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/footnote/}
 */
export class Footnote implements XMLElement<'footnote', FootnoteAttributes, FootnoteContents> {
  static readonly schema = {
    name: 'footnote',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Footnote.schema;

  attributes: FootnoteAttributes;
  contents: FootnoteContents;

  constructor(opts?: { attributes?: Partial<FootnoteAttributes>; contents?: FootnoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Footnote.schema);
    this.contents = opts?.contents ?? operations.zero(Footnote.schema.contents);
  }
  /** Gets @type {FootnoteAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FootnoteAttributes['color']}. */
  setColor(color: string | null): Footnote {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FootnoteAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FootnoteAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Footnote {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FootnoteAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FootnoteAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Footnote {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FootnoteAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {FootnoteAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Footnote {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {FootnoteAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {FootnoteAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Footnote {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {FootnoteAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FootnoteAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Footnote {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FootnoteAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FootnoteAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Footnote {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FootnoteAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FootnoteAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Footnote {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FootnoteAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FootnoteAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Footnote {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FootnoteAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {FootnoteAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Footnote {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {FootnoteAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {FootnoteAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): Footnote {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {FootnoteAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {FootnoteAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): Footnote {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {FootnoteAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {FootnoteAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): Footnote {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {FootnoteAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {FootnoteAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): Footnote {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {FootnoteAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {FootnoteAttributes['overline']}. */
  setOverline(overline: number | null): Footnote {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {FootnoteAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FootnoteAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Footnote {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FootnoteAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FootnoteAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Footnote {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {FootnoteAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {FootnoteAttributes['rotation']}. */
  setRotation(rotation: number | null): Footnote {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {FootnoteAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {FootnoteAttributes['underline']}. */
  setUnderline(underline: number | null): Footnote {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {FootnoteAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {FootnoteAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Footnote {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {FootnoteAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {FootnoteAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): Footnote {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {FootnoteAttributes['xml:space']}. */
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  /** Sets @type {FootnoteAttributes['xml:space']}. */
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): Footnote {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type LevelAttributes = {
  /**
   * Specifies whether or not brackets are put around a symbol for an editorial indication. If not specified, it is
   * left to application defaults.
   */
  bracket: 'yes' | 'no' | null;
  /**
   * Specifies whether or not parentheses are put around a symbol for an editorial indication. If not specified, it
   * is left to application defaults.
   */
  parentheses: 'yes' | 'no' | null;
  /**
   * If the reference attribute is yes, this indicates editorial information that is for display only and should not
   * affect playback. For instance, a modern edition of older music may set reference="yes" on the attributes
   * containing the music's original clef, key, and time signature. It is no if not specified.
   */
  reference: 'yes' | 'no' | null;
  /**
   * Specifies the symbol size to use for an editorial indication. If not specified, it is left to application
   * defaults.
   */
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
  /**
   * Indicates whether the editorial information applies to the start of a series of symbols, the end of a series of
   * symbols, or a single symbol. It is single if not specified for compatibility with earlier MusicXML versions.
   */
  type: 'start' | 'stop' | 'single' | null;
};

export type LevelContents = [string];

/**
 * The `<level>` element
 *
 * Parent elements: `<attributes>`, `<backup>`, `<barline>`, `<direction>`, `<figure>`, `<figured-bass>`, `<forward>`,
 * `<harmony>`, `<lyric>`, `<notations>`, `<note>`, `<part-group>`
 *
 * The `<level>` element is used to specify editorial information for different MusicXML elements. The content contains
 * identifying and/or descriptive text about the editorial status of the parent element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/level/}
 */
export class Level implements XMLElement<'level', LevelAttributes, LevelContents> {
  static readonly schema = {
    name: 'level',
    attributes: {
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      reference: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Level.schema;

  attributes: LevelAttributes;
  contents: LevelContents;

  constructor(opts?: { attributes?: Partial<LevelAttributes>; contents?: LevelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Level.schema);
    this.contents = opts?.contents ?? operations.zero(Level.schema.contents);
  }
  /** Gets @type {LevelAttributes['bracket']}. */
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  /** Sets @type {LevelAttributes['bracket']}. */
  setBracket(bracket: 'yes' | 'no' | null): Level {
    this.attributes['bracket'] = bracket;
    return this;
  }
  /** Gets @type {LevelAttributes['parentheses']}. */
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  /** Sets @type {LevelAttributes['parentheses']}. */
  setParentheses(parentheses: 'yes' | 'no' | null): Level {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  /** Gets @type {LevelAttributes['reference']}. */
  getReference(): 'yes' | 'no' | null {
    return this.attributes['reference'];
  }
  /** Sets @type {LevelAttributes['reference']}. */
  setReference(reference: 'yes' | 'no' | null): Level {
    this.attributes['reference'] = reference;
    return this;
  }
  /** Gets @type {LevelAttributes['size']}. */
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  /** Sets @type {LevelAttributes['size']}. */
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Level {
    this.attributes['size'] = size;
    return this;
  }
  /** Gets @type {LevelAttributes['type']}. */
  getType(): 'start' | 'stop' | 'single' | null {
    return this.attributes['type'];
  }
  /** Sets @type {LevelAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'single' | null): Level {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type PartGroupAttributes = {
  /**
   * Indicates the start or stop of the `<part-group>`.
   */
  type: 'start' | 'stop';
  /**
   * Distinguishes overlapping and nested `<part-group>` elements, not a sequence of `<part-group>` elements. The
   * default value is 1.
   */
  number: string | null;
};

export type PartGroupContents = [
  GroupName | null,
  GroupNameDisplay | null,
  GroupAbbreviation | null,
  GroupAbbreviationDisplay | null,
  GroupSymbol | null,
  GroupBarline | null,
  GroupTime | null,
  Footnote | null,
  Level | null,
];

/**
 * The `<part-list>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<part-list>` element identifies the different musical parts in this document. Each part has an ID that is used
 * later within the musical data. Since parts may be encoded separately and combined later, identification elements are
 * present at both the score and `<score-part>` levels.
 *
 * There must be at least one `<score-part>`, combined as desired with `<part-group>` elements that indicate braces and
 * brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the
 * `<part-list>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-list/}
 */
export class PartGroup implements XMLElement<'part-group', PartGroupAttributes, PartGroupContents> {
  static readonly schema = {
    name: 'part-group',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'optional', value: GroupName },
      { type: 'optional', value: GroupNameDisplay },
      { type: 'optional', value: GroupAbbreviation },
      { type: 'optional', value: GroupAbbreviationDisplay },
      { type: 'optional', value: GroupSymbol },
      { type: 'optional', value: GroupBarline },
      { type: 'optional', value: GroupTime },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = PartGroup.schema;

  attributes: PartGroupAttributes;
  contents: PartGroupContents;

  constructor(opts?: { attributes?: Partial<PartGroupAttributes>; contents?: PartGroupContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartGroup.schema);
    this.contents = opts?.contents ?? operations.zero(PartGroup.schema.contents);
  }
  /** Gets @type {PartGroupAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {PartGroupAttributes['type']}. */
  setType(type: 'start' | 'stop'): PartGroup {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {PartGroupAttributes['number']}. */
  getNumber(): string | null {
    return this.attributes['number'];
  }
  /** Sets @type {PartGroupAttributes['number']}. */
  setNumber(number: string | null): PartGroup {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {GroupName | null}. */
  getGroupName(): GroupName | null {
    return this.contents[0];
  }
  /** Sets @type {GroupName | null}. */
  setGroupName(groupName: GroupName | null): this {
    this.contents[0] = groupName;
    return this;
  }
  /** Gets @type {GroupNameDisplay | null}. */
  getGroupNameDisplay(): GroupNameDisplay | null {
    return this.contents[1];
  }
  /** Sets @type {GroupNameDisplay | null}. */
  setGroupNameDisplay(groupNameDisplay: GroupNameDisplay | null): this {
    this.contents[1] = groupNameDisplay;
    return this;
  }
  /** Gets @type {GroupAbbreviation | null}. */
  getGroupAbbreviation(): GroupAbbreviation | null {
    return this.contents[2];
  }
  /** Sets @type {GroupAbbreviation | null}. */
  setGroupAbbreviation(groupAbbreviation: GroupAbbreviation | null): this {
    this.contents[2] = groupAbbreviation;
    return this;
  }
  /** Gets @type {GroupAbbreviationDisplay | null}. */
  getGroupAbbreviationDisplay(): GroupAbbreviationDisplay | null {
    return this.contents[3];
  }
  /** Sets @type {GroupAbbreviationDisplay | null}. */
  setGroupAbbreviationDisplay(groupAbbreviationDisplay: GroupAbbreviationDisplay | null): this {
    this.contents[3] = groupAbbreviationDisplay;
    return this;
  }
  /** Gets @type {GroupSymbol | null}. */
  getGroupSymbol(): GroupSymbol | null {
    return this.contents[4];
  }
  /** Sets @type {GroupSymbol | null}. */
  setGroupSymbol(groupSymbol: GroupSymbol | null): this {
    this.contents[4] = groupSymbol;
    return this;
  }
  /** Gets @type {GroupBarline | null}. */
  getGroupBarline(): GroupBarline | null {
    return this.contents[5];
  }
  /** Sets @type {GroupBarline | null}. */
  setGroupBarline(groupBarline: GroupBarline | null): this {
    this.contents[5] = groupBarline;
    return this;
  }
  /** Gets @type {GroupTime | null}. */
  getGroupTime(): GroupTime | null {
    return this.contents[6];
  }
  /** Sets @type {GroupTime | null}. */
  setGroupTime(groupTime: GroupTime | null): this {
    this.contents[6] = groupTime;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[7];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[7] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[8];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[8] = level;
    return this;
  }
}

export type InstrumentLinkAttributes = {
  /**
   * Refers to a `<score-instrument>` id attribute.
   */
  id: string;
};

export type InstrumentLinkContents = [];

/**
 * The `<instrument-link>` element
 *
 * Parent element: `<part-link>`
 *
 * Multiple `<part-link>` elements can link a condensed part within a score file to multiple MusicXML parts files. For
 * example, a "Clarinet 1 and 2" part in a score file could link to separate "Clarinet 1" and "Clarinet 2" part files.
 * The `<instrument-link>` element distinguishes which of the `<score-instrument>`s within a `<score-part>` are in which part file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-link/}
 */
export class InstrumentLink implements XMLElement<'instrument-link', InstrumentLinkAttributes, InstrumentLinkContents> {
  static readonly schema = {
    name: 'instrument-link',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [],
  } as const;

  readonly schema = InstrumentLink.schema;

  attributes: InstrumentLinkAttributes;
  contents: InstrumentLinkContents;

  constructor(opts?: { attributes?: Partial<InstrumentLinkAttributes>; contents?: InstrumentLinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentLink.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentLink.schema.contents);
  }
  /** Gets @type {InstrumentLinkAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {InstrumentLinkAttributes['id']}. */
  setId(id: string): InstrumentLink {
    this.attributes['id'] = id;
    return this;
  }
}

export type GroupLinkAttributes = Record<string, unknown>;

export type GroupLinkContents = [string];

/**
 * The `<group-link>` element
 *
 * Parent element: `<part-link>`
 *
 * Multiple `<part-link>` elements can reference different types of linked documents, such as parts and condensed score.
 * The optional `<group-link>` elements identify the groups used in the linked document. The content of a `<group-link>`
 * element should match the content of a `<group>` element in the linked document.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group-link/}
 */
export class GroupLink implements XMLElement<'group-link', GroupLinkAttributes, GroupLinkContents> {
  static readonly schema = {
    name: 'group-link',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = GroupLink.schema;

  attributes: GroupLinkAttributes;
  contents: GroupLinkContents;

  constructor(opts?: { attributes?: Partial<GroupLinkAttributes>; contents?: GroupLinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, GroupLink.schema);
    this.contents = opts?.contents ?? operations.zero(GroupLink.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type PartLinkAttributes = {
  /**
   * The href attribute provides the data that allows an application to find a remote resource or resource fragment.
   * See the [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-locators)
   */
  'xlink:href': string;
  /**
   * The actuate attribute is used to communicate the desired timing of traversal from the starting resource to the
   * ending resource. The default value is onRequest. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-behaviors)
   */
  'xlink:actuate': 'none' | 'onRequest' | 'onLoad' | 'other' | null;
  /**
   * The role attribute indicates a property of the link. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-semantics)
   */
  'xlink:role': string | null;
  /**
   * The show attribute is used to communicate the desired presentation of the ending resource on traversal from the
   * starting resource. The default value is replace. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-behaviors)
   */
  'xlink:show': 'none' | 'new' | 'replace' | 'embed' | 'other' | null;
  /**
   * The title attribute describes the meaning of a link or resource in a human-readable fashion. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-semantics)
   */
  'xlink:title': string | null;
  /**
   * The type attribute identifies XLink element types. In MusicXML, the value is always simple. See the
   * [definition in the XML Linking Language recommendation.](https://www.w3.org/TR/xlink11/#link-types)
   */
  'xlink:type': 'simple' | null;
};

export type PartLinkContents = [Array<InstrumentLink>, Array<GroupLink>];

/**
 * The `<part-link>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<part-link>` element allows MusicXML data for both score and parts to be contained within a single compressed
 * MusicXML file. It links a `<score-part>` from a score document to MusicXML documents that contain parts data. In the
 * case of a single compressed MusicXML file, the link href values are paths that are relative to the root folder of the
 * zip file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-link/}
 */
export class PartLink implements XMLElement<'part-link', PartLinkAttributes, PartLinkContents> {
  static readonly schema = {
    name: 'part-link',
    attributes: {
      'xlink:href': { type: 'required', value: { type: 'string' } },
      'xlink:actuate': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'onRequest', 'onLoad', 'other'] },
      },
      'xlink:role': { type: 'optional', value: { type: 'string' } },
      'xlink:show': {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'new', 'replace', 'embed', 'other'] },
      },
      'xlink:title': { type: 'optional', value: { type: 'string' } },
      'xlink:type': { type: 'optional', value: { type: 'choices', choices: ['simple'] } },
    },
    contents: [
      { type: 'label', label: 'instrument-links', value: { type: 'zeroOrMore', value: InstrumentLink } },
      { type: 'label', label: 'group-links', value: { type: 'zeroOrMore', value: GroupLink } },
    ],
  } as const;

  readonly schema = PartLink.schema;

  attributes: PartLinkAttributes;
  contents: PartLinkContents;

  constructor(opts?: { attributes?: Partial<PartLinkAttributes>; contents?: PartLinkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartLink.schema);
    this.contents = opts?.contents ?? operations.zero(PartLink.schema.contents);
  }
  /** Gets @type {PartLinkAttributes['xlink:href']}. */
  getXlinkHref(): string {
    return this.attributes['xlink:href'];
  }
  /** Sets @type {PartLinkAttributes['xlink:href']}. */
  setXlinkHref(xlinkHref: string): PartLink {
    this.attributes['xlink:href'] = xlinkHref;
    return this;
  }
  /** Gets @type {PartLinkAttributes['xlink:actuate']}. */
  getXlinkActuate(): 'none' | 'onRequest' | 'onLoad' | 'other' | null {
    return this.attributes['xlink:actuate'];
  }
  /** Sets @type {PartLinkAttributes['xlink:actuate']}. */
  setXlinkActuate(xlinkActuate: 'none' | 'onRequest' | 'onLoad' | 'other' | null): PartLink {
    this.attributes['xlink:actuate'] = xlinkActuate;
    return this;
  }
  /** Gets @type {PartLinkAttributes['xlink:role']}. */
  getXlinkRole(): string | null {
    return this.attributes['xlink:role'];
  }
  /** Sets @type {PartLinkAttributes['xlink:role']}. */
  setXlinkRole(xlinkRole: string | null): PartLink {
    this.attributes['xlink:role'] = xlinkRole;
    return this;
  }
  /** Gets @type {PartLinkAttributes['xlink:show']}. */
  getXlinkShow(): 'none' | 'new' | 'replace' | 'embed' | 'other' | null {
    return this.attributes['xlink:show'];
  }
  /** Sets @type {PartLinkAttributes['xlink:show']}. */
  setXlinkShow(xlinkShow: 'none' | 'new' | 'replace' | 'embed' | 'other' | null): PartLink {
    this.attributes['xlink:show'] = xlinkShow;
    return this;
  }
  /** Gets @type {PartLinkAttributes['xlink:title']}. */
  getXlinkTitle(): string | null {
    return this.attributes['xlink:title'];
  }
  /** Sets @type {PartLinkAttributes['xlink:title']}. */
  setXlinkTitle(xlinkTitle: string | null): PartLink {
    this.attributes['xlink:title'] = xlinkTitle;
    return this;
  }
  /** Gets @type {PartLinkAttributes['xlink:type']}. */
  getXlinkType(): 'simple' | null {
    return this.attributes['xlink:type'];
  }
  /** Sets @type {PartLinkAttributes['xlink:type']}. */
  setXlinkType(xlinkType: 'simple' | null): PartLink {
    this.attributes['xlink:type'] = xlinkType;
    return this;
  }
  /** Gets @type {Array<InstrumentLink>}. */
  getInstrumentLinks(): Array<InstrumentLink> {
    return this.contents[0];
  }
  /** Sets @type {Array<InstrumentLink>}. */
  setInstrumentLinks(instrumentLinks: Array<InstrumentLink>): this {
    this.contents[0] = instrumentLinks;
    return this;
  }
  /** Gets @type {Array<GroupLink>}. */
  getGroupLinks(): Array<GroupLink> {
    return this.contents[1];
  }
  /** Sets @type {Array<GroupLink>}. */
  setGroupLinks(groupLinks: Array<GroupLink>): this {
    this.contents[1] = groupLinks;
    return this;
  }
}

export type PartNameAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of
   * the staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the `<offset>` element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down. It should be interpreted
   * in the context of the placement attribute if that is present.
   */
  'relative-y': number | null;
};

export type PartNameContents = [string];

/**
 * The `<part-name>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<part-name>` and `<part-abbreviation>` elements describe the name and abbreviation of a `<score-part>` element,
 * respectively. Formatting attributes for these elements were deprecated in Version 2.0 in favor of the
 * `<part-name-display>` and `<part-abbreviation-display>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-name/}
 */
export class PartName implements XMLElement<'part-name', PartNameAttributes, PartNameContents> {
  static readonly schema = {
    name: 'part-name',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PartName.schema;

  attributes: PartNameAttributes;
  contents: PartNameContents;

  constructor(opts?: { attributes?: Partial<PartNameAttributes>; contents?: PartNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartName.schema);
    this.contents = opts?.contents ?? operations.zero(PartName.schema.contents);
  }
  /** Gets @type {PartNameAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PartNameAttributes['color']}. */
  setColor(color: string | null): PartName {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PartNameAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PartNameAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): PartName {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PartNameAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PartNameAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): PartName {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PartNameAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PartNameAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): PartName {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PartNameAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PartNameAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PartName {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PartNameAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PartNameAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PartName {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PartNameAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PartNameAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PartName {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PartNameAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {PartNameAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): PartName {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {PartNameAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {PartNameAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): PartName {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {PartNameAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PartNameAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): PartName {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PartNameAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PartNameAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): PartName {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type PartNameDisplayAttributes = {
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
};

export type PartNameDisplayContents = [Array<DisplayText | AccidentalText>];

/**
 * The `<part-name-display>` element
 *
 * Parent elements: `<print>`, `<score-part>`
 *
 * The `<part-name-display>` element is used for exact formatting of multi-font text in part names to the left of the
 * system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system.
 *
 * Formatting specified in the `<part-name-display>` element overrides formatting specified in the <part-name> element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-name-display/}
 */
export class PartNameDisplay
  implements XMLElement<'part-name-display', PartNameDisplayAttributes, PartNameDisplayContents>
{
  static readonly schema = {
    name: 'part-name-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = PartNameDisplay.schema;

  attributes: PartNameDisplayAttributes;
  contents: PartNameDisplayContents;

  constructor(opts?: { attributes?: Partial<PartNameDisplayAttributes>; contents?: PartNameDisplayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartNameDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(PartNameDisplay.schema.contents);
  }
  /** Gets @type {PartNameDisplayAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {PartNameDisplayAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): PartNameDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {Array<DisplayText | AccidentalText>}. */
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  /** Sets @type {Array<DisplayText | AccidentalText>}. */
  setTexts(texts: Array<DisplayText | AccidentalText>): this {
    this.contents[0] = texts;
    return this;
  }
}

export type PartAbbreviationAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type PartAbbreviationContents = [string];

/**
 * The `<part-abbreviation>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<part-name>` and `<part-abbreviation>` elements describe the name and abbreviation of a `<score-part>` element,
 * respectively. Formatting attributes for these elements were deprecated in Version 2.0 in favor of the
 * `<part-name-display>` and `<part-abbreviation-display>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-abbreviation/}
 */
export class PartAbbreviation
  implements XMLElement<'part-abbreviation', PartAbbreviationAttributes, PartAbbreviationContents>
{
  static readonly schema = {
    name: 'part-abbreviation',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PartAbbreviation.schema;

  attributes: PartAbbreviationAttributes;
  contents: PartAbbreviationContents;

  constructor(opts?: { attributes?: Partial<PartAbbreviationAttributes>; contents?: PartAbbreviationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartAbbreviation.schema);
    this.contents = opts?.contents ?? operations.zero(PartAbbreviation.schema.contents);
  }
  /** Gets @type {PartAbbreviationAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PartAbbreviationAttributes['color']}. */
  setColor(color: string | null): PartAbbreviation {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PartAbbreviationAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): PartAbbreviation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PartAbbreviationAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): PartAbbreviation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PartAbbreviationAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): PartAbbreviation {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PartAbbreviationAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PartAbbreviation {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PartAbbreviationAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PartAbbreviation {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PartAbbreviationAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PartAbbreviation {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {PartAbbreviationAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): PartAbbreviation {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {PartAbbreviationAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): PartAbbreviation {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PartAbbreviationAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): PartAbbreviation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PartAbbreviationAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PartAbbreviationAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): PartAbbreviation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type PartAbbreviationDisplayAttributes = {
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
};

export type PartAbbreviationDisplayContents = [Array<DisplayText | AccidentalText>];

/**
 * The `<part-abbreviation-display>` element
 *
 * Parent elements: `<print>`, `<score-part>`
 *
 * The `<part-abbreviation-display>` element is used for exact formatting of multi-font text in part abbreviations to
 * the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the
 * start of each system.
 *
 * Formatting specified in the `<part-abbreviation-display>` element overrides formatting specified in the
 * `<part-abbreviation>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-abbreviation-display/}
 */
export class PartAbbreviationDisplay
  implements
    XMLElement<'part-abbreviation-display', PartAbbreviationDisplayAttributes, PartAbbreviationDisplayContents>
{
  static readonly schema = {
    name: 'part-abbreviation-display',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'texts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [DisplayText, AccidentalText] } },
      },
    ],
  } as const;

  readonly schema = PartAbbreviationDisplay.schema;

  attributes: PartAbbreviationDisplayAttributes;
  contents: PartAbbreviationDisplayContents;

  constructor(opts?: {
    attributes?: Partial<PartAbbreviationDisplayAttributes>;
    contents?: PartAbbreviationDisplayContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartAbbreviationDisplay.schema);
    this.contents = opts?.contents ?? operations.zero(PartAbbreviationDisplay.schema.contents);
  }
  /** Gets @type {PartAbbreviationDisplayAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {PartAbbreviationDisplayAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): PartAbbreviationDisplay {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {Array<DisplayText | AccidentalText>}. */
  getTexts(): Array<DisplayText | AccidentalText> {
    return this.contents[0];
  }
  /** Sets @type {Array<DisplayText | AccidentalText>}. */
  setTexts(texts: Array<DisplayText | AccidentalText>): this {
    this.contents[0] = texts;
    return this;
  }
}

export type GroupAttributes = Record<string, unknown>;

export type GroupContents = [string];

/**
 * The `<group>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<group>` element allows the use of different versions of the part for different purposes. Typical values include
 * score, parts, sound, and data. Ordering information can be derived from the ordering within a MusicXML score or opus.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/group/}
 */
export class Group implements XMLElement<'group', GroupAttributes, GroupContents> {
  static readonly schema = {
    name: 'group',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Group.schema;

  attributes: GroupAttributes;
  contents: GroupContents;

  constructor(opts?: { attributes?: Partial<GroupAttributes>; contents?: GroupContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Group.schema);
    this.contents = opts?.contents ?? operations.zero(Group.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type InstrumentNameAttributes = Record<string, unknown>;

export type InstrumentNameContents = [string];

/**
 * The `<instrument-name>` element
 *
 * Parent element: `<score-instrument>`
 *
 * The `<instrument-name>` element is typically used within a software application, rather than appearing on the printed
 * page of a score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-name/}
 */
export class InstrumentName implements XMLElement<'instrument-name', InstrumentNameAttributes, InstrumentNameContents> {
  static readonly schema = {
    name: 'instrument-name',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = InstrumentName.schema;

  attributes: InstrumentNameAttributes;
  contents: InstrumentNameContents;

  constructor(opts?: { attributes?: Partial<InstrumentNameAttributes>; contents?: InstrumentNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentName.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentName.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type InstrumentAbbreviationAttributes = Record<string, unknown>;

export type InstrumentAbbreviationContents = [string];

/**
 * The `<instrument-abbreviation>` element
 *
 * Parent element: `<score-instrument>`
 *
 * The `<instrument-abbreviation>` element is typically used within a software application, rather than appearing on the
 * printed page of a score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-abbreviation/}
 */
export class InstrumentAbbreviation
  implements XMLElement<'instrument-abbreviation', InstrumentAbbreviationAttributes, InstrumentAbbreviationContents>
{
  static readonly schema = {
    name: 'instrument-abbreviation',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = InstrumentAbbreviation.schema;

  attributes: InstrumentAbbreviationAttributes;
  contents: InstrumentAbbreviationContents;

  constructor(opts?: {
    attributes?: Partial<InstrumentAbbreviationAttributes>;
    contents?: InstrumentAbbreviationContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentAbbreviation.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentAbbreviation.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type InstrumentSoundAttributes = Record<string, unknown>;

export type InstrumentSoundContents = [string];

/**
 * The `<instrument-sound>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<instrument-sound>` element describes the default timbre of the `<score-instrument>`. This description is
 * independent of a particular virtual or MIDI instrument specification and allows playback to be shared more easily
 * between applications and libraries.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-sound/}
 */
export class InstrumentSound
  implements XMLElement<'instrument-sound', InstrumentSoundAttributes, InstrumentSoundContents>
{
  static readonly schema = {
    name: 'instrument-sound',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = InstrumentSound.schema;

  attributes: InstrumentSoundAttributes;
  contents: InstrumentSoundContents;

  constructor(opts?: { attributes?: Partial<InstrumentSoundAttributes>; contents?: InstrumentSoundContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentSound.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentSound.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type SoloAttributes = Record<string, unknown>;

export type SoloContents = [];

/**
 * The `<solo>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<solo>` element is present if performance is intended by a solo instrument.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/solo/}
 */
export class Solo implements XMLElement<'solo', SoloAttributes, SoloContents> {
  static readonly schema = { name: 'solo', attributes: {}, contents: [] } as const;

  readonly schema = Solo.schema;

  attributes: SoloAttributes;
  contents: SoloContents;

  constructor(opts?: { attributes?: Partial<SoloAttributes>; contents?: SoloContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Solo.schema);
    this.contents = opts?.contents ?? operations.zero(Solo.schema.contents);
  }
}

export type EnsembleAttributes = Record<string, unknown>;

export type EnsembleContents = ['' | number];

/**
 * The `<ensemble>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<ensemble>` element is present if performance is intended by an ensemble such as an orchestral section. The text
 * of the `<ensemble>` element contains the size of the section, or is empty if the ensemble size is not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ensemble/}
 */
export class Ensemble implements XMLElement<'ensemble', EnsembleAttributes, EnsembleContents> {
  static readonly schema = {
    name: 'ensemble',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'size',
        value: { type: 'required', value: { type: 'choices', choices: ['', { type: 'int', min: 1, max: Infinity }] } },
      },
    ],
  } as const;

  readonly schema = Ensemble.schema;

  attributes: EnsembleAttributes;
  contents: EnsembleContents;

  constructor(opts?: { attributes?: Partial<EnsembleAttributes>; contents?: EnsembleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ensemble.schema);
    this.contents = opts?.contents ?? operations.zero(Ensemble.schema.contents);
  }

  /** Gets @type {'' | number}. */
  getSize(): '' | number {
    return this.contents[0];
  }
  /** Sets @type {'' | number}. */
  setSize(size: '' | number): this {
    this.contents[0] = size;
    return this;
  }
}

export type VirtualLibraryAttributes = Record<string, unknown>;

export type VirtualLibraryContents = [string];

/**
 * The `<virtual-library>` element
 *
 * Parent element: `<virtual-instrument>`
 *
 * The `<virtual-library>` element indicates the virtual instrument library name.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/virtual-library/}
 */
export class VirtualLibrary implements XMLElement<'virtual-library', VirtualLibraryAttributes, VirtualLibraryContents> {
  static readonly schema = {
    name: 'virtual-library',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = VirtualLibrary.schema;

  attributes: VirtualLibraryAttributes;
  contents: VirtualLibraryContents;

  constructor(opts?: { attributes?: Partial<VirtualLibraryAttributes>; contents?: VirtualLibraryContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VirtualLibrary.schema);
    this.contents = opts?.contents ?? operations.zero(VirtualLibrary.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type VirtualNameAttributes = Record<string, unknown>;

export type VirtualNameContents = [string];

/**
 * The `<virtual-name>` element
 *
 * Parent element: `<virtual-instrument>`
 *
 * The `<virtual-name>` element indicates the library-specific name for the virtual instrument.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/virtual-name/}
 */
export class VirtualName implements XMLElement<'virtual-name', VirtualNameAttributes, VirtualNameContents> {
  static readonly schema = {
    name: 'virtual-name',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = VirtualName.schema;

  attributes: VirtualNameAttributes;
  contents: VirtualNameContents;

  constructor(opts?: { attributes?: Partial<VirtualNameAttributes>; contents?: VirtualNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VirtualName.schema);
    this.contents = opts?.contents ?? operations.zero(VirtualName.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type VirtualInstrumentAttributes = Record<string, unknown>;

export type VirtualInstrumentContents = [VirtualLibrary | null, VirtualName | null];

/**
 * The `<virtual-instrument>` element
 *
 * Parent elements: `<instrument-change>`, `<score-instrument>`
 *
 * The `<virtual-instrument>` element defines a specific virtual instrument used for an `<instrument sound>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/virtual-instrument/}
 */
export class VirtualInstrument
  implements XMLElement<'virtual-instrument', VirtualInstrumentAttributes, VirtualInstrumentContents>
{
  static readonly schema = {
    name: 'virtual-instrument',
    attributes: {},
    contents: [
      { type: 'optional', value: VirtualLibrary },
      { type: 'optional', value: VirtualName },
    ],
  } as const;

  readonly schema = VirtualInstrument.schema;

  attributes: VirtualInstrumentAttributes;
  contents: VirtualInstrumentContents;

  constructor(opts?: { attributes?: Partial<VirtualInstrumentAttributes>; contents?: VirtualInstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VirtualInstrument.schema);
    this.contents = opts?.contents ?? operations.zero(VirtualInstrument.schema.contents);
  }

  /** Gets @type {VirtualLibrary | null}. */
  getVirtualLibrary(): VirtualLibrary | null {
    return this.contents[0];
  }
  /** Sets @type {VirtualLibrary | null}. */
  setVirtualLibrary(virtualLibrary: VirtualLibrary | null): this {
    this.contents[0] = virtualLibrary;
    return this;
  }
  /** Gets @type {VirtualName | null}. */
  getVirtualName(): VirtualName | null {
    return this.contents[1];
  }
  /** Sets @type {VirtualName | null}. */
  setVirtualName(virtualName: VirtualName | null): this {
    this.contents[1] = virtualName;
    return this;
  }
}

export type ScoreInstrumentAttributes = {
  /**
   * An identifier for this `<score-instrument>` that is unique to this document.
   */
  id: string;
};

export type ScoreInstrumentContents = [
  InstrumentName,
  InstrumentAbbreviation | null,
  InstrumentSound | null,
  Array<Solo | Ensemble>,
  VirtualInstrument | null,
];

/**
 * Parent element: `<score-part>`
 *
 * The `<score-instrument>` element represents a single instrument within a `<score-part>`. As with the `<score-part>`
 * element, each `<score-instrument>` has a required ID attribute, a name, and an optional abbreviation.
 *
 * A `<score-instrument>` element is also required if the score specifies MIDI 1.0 channels, banks, or programs. An
 * initial `<midi-instrument>` assignment can also be made here. MusicXML software should be able to automatically
 * assign reasonable channels and instruments without these elements in simple cases, such as where part names match
 * General MIDI instrument names.
 *
 * The `<score-instrument>` element can also distinguish multiple instruments of the same type that are on the same
 * part, such as Clarinet 1 and Clarinet 2 instruments within a Clarinets 1 and 2 part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-instrument/}
 */
export class ScoreInstrument
  implements XMLElement<'score-instrument', ScoreInstrumentAttributes, ScoreInstrumentContents>
{
  static readonly schema = {
    name: 'score-instrument',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      { type: 'required', value: InstrumentName },
      { type: 'optional', value: InstrumentAbbreviation },
      { type: 'optional', value: InstrumentSound },
      {
        type: 'label',
        label: 'instrument-types',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Solo, Ensemble] } },
      },
      { type: 'optional', value: VirtualInstrument },
    ],
  } as const;

  readonly schema = ScoreInstrument.schema;

  attributes: ScoreInstrumentAttributes;
  contents: ScoreInstrumentContents;

  constructor(opts?: { attributes?: Partial<ScoreInstrumentAttributes>; contents?: ScoreInstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScoreInstrument.schema);
    this.contents = opts?.contents ?? operations.zero(ScoreInstrument.schema.contents);
  }
  /** Gets @type {ScoreInstrumentAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {ScoreInstrumentAttributes['id']}. */
  setId(id: string): ScoreInstrument {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {InstrumentName}. */
  getInstrumentName(): InstrumentName {
    return this.contents[0];
  }
  /** Sets @type {InstrumentName}. */
  setInstrumentName(instrumentName: InstrumentName): this {
    this.contents[0] = instrumentName;
    return this;
  }
  /** Gets @type {InstrumentAbbreviation | null}. */
  getInstrumentAbbreviation(): InstrumentAbbreviation | null {
    return this.contents[1];
  }
  /** Sets @type {InstrumentAbbreviation | null}. */
  setInstrumentAbbreviation(instrumentAbbreviation: InstrumentAbbreviation | null): this {
    this.contents[1] = instrumentAbbreviation;
    return this;
  }
  /** Gets @type {InstrumentSound | null}. */
  getInstrumentSound(): InstrumentSound | null {
    return this.contents[2];
  }
  /** Sets @type {InstrumentSound | null}. */
  setInstrumentSound(instrumentSound: InstrumentSound | null): this {
    this.contents[2] = instrumentSound;
    return this;
  }
  /** Gets @type {Array<Solo | Ensemble>}. */
  getInstrumentTypes(): Array<Solo | Ensemble> {
    return this.contents[3];
  }
  /** Sets @type {Array<Solo | Ensemble>}. */
  setInstrumentTypes(instrumentTypes: Array<Solo | Ensemble>): this {
    this.contents[3] = instrumentTypes;
    return this;
  }
  /** Gets @type {VirtualInstrument | null}. */
  getVirtualInstrument(): VirtualInstrument | null {
    return this.contents[4];
  }
  /** Sets @type {VirtualInstrument | null}. */
  setVirtualInstrument(virtualInstrument: VirtualInstrument | null): this {
    this.contents[4] = virtualInstrument;
    return this;
  }
}

export type PlayerAttributes = {
  /**
   * An identifier for this `<player>` that is unique within this document.
   */
  id: string;
};

export type PlayerContents = [];

/**
 * The `<player>` element
 *
 * Parent element: `<score-part>`
 *
 * The `<player>` element allows for multiple players per `<score-part>` for use in listening applications. One player
 * may play multiple instruments, while a single instrument may include multiple players in divisi sections.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/player/}
 */
export class Player implements XMLElement<'player', PlayerAttributes, PlayerContents> {
  static readonly schema = {
    name: 'player',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [],
  } as const;

  readonly schema = Player.schema;

  attributes: PlayerAttributes;
  contents: PlayerContents;

  constructor(opts?: { attributes?: Partial<PlayerAttributes>; contents?: PlayerContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Player.schema);
    this.contents = opts?.contents ?? operations.zero(Player.schema.contents);
  }
  /** Gets @type {PlayerAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {PlayerAttributes['id']}. */
  setId(id: string): Player {
    this.attributes['id'] = id;
    return this;
  }
}

export type MidiDeviceAttributes = {
  /**
   * Refers to the `<score-instrument>` assigned to this device. If missing, the device assignment affects all
   * `<score-instrument>` elements in the `<score-part>`.
   */
  id: string | null;
  /**
   * A number from 1 to 16 that can be used with the unofficial MIDI 1.0 port (or cable) meta event.
   */
  port: number | null;
};

export type MidiDeviceContents = [string];

/**
 * The `<midi-device>` element
 *
 * Parent elements: `<score-part>`, `<sound>`
 *
 * The `<midi-device>` element corresponds to the DeviceName meta event in Standard MIDI Files. Unlike the DeviceName
 * meta event, there can be multiple `<midi-device>` elements per MusicXML part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-device/}
 */
export class MidiDevice implements XMLElement<'midi-device', MidiDeviceAttributes, MidiDeviceContents> {
  static readonly schema = {
    name: 'midi-device',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      port: { type: 'optional', value: { type: 'label', label: 'midi16', value: { type: 'int', min: 1, max: 16 } } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = MidiDevice.schema;

  attributes: MidiDeviceAttributes;
  contents: MidiDeviceContents;

  constructor(opts?: { attributes?: Partial<MidiDeviceAttributes>; contents?: MidiDeviceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiDevice.schema);
    this.contents = opts?.contents ?? operations.zero(MidiDevice.schema.contents);
  }
  /** Gets @type {MidiDeviceAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {MidiDeviceAttributes['id']}. */
  setId(id: string | null): MidiDevice {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {MidiDeviceAttributes['midi16']}. */
  getMidi16(): number | null {
    return this.attributes['port'];
  }
  /** Sets @type {MidiDeviceAttributes['midi16']}. */
  setMidi16(midi16: number | null): MidiDevice {
    this.attributes['port'] = midi16;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MidiChannelAttributes = Record<string, unknown>;

export type MidiChannelContents = [number];

/**
 * The `<midi-channel>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-channel>` element specifies a MIDI 1.0 channel numbers ranging from 1 to 16.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-channel/}
 */
export class MidiChannel implements XMLElement<'midi-channel', MidiChannelAttributes, MidiChannelContents> {
  static readonly schema = {
    name: 'midi-channel',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi16', value: { type: 'int', min: 1, max: 16 } } },
    ],
  } as const;

  readonly schema = MidiChannel.schema;

  attributes: MidiChannelAttributes;
  contents: MidiChannelContents;

  constructor(opts?: { attributes?: Partial<MidiChannelAttributes>; contents?: MidiChannelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiChannel.schema);
    this.contents = opts?.contents ?? operations.zero(MidiChannel.schema.contents);
  }

  /** Gets @type {number}. */
  getMidi16(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setMidi16(midi16: number): this {
    this.contents[0] = midi16;
    return this;
  }
}

export type MidiNameAttributes = Record<string, unknown>;

export type MidiNameContents = [string];

/**
 * The `<midi-name>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-name>` element corresponds to a ProgramName meta-event within a Standard MIDI File.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-name/}
 */
export class MidiName implements XMLElement<'midi-name', MidiNameAttributes, MidiNameContents> {
  static readonly schema = {
    name: 'midi-name',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = MidiName.schema;

  attributes: MidiNameAttributes;
  contents: MidiNameContents;

  constructor(opts?: { attributes?: Partial<MidiNameAttributes>; contents?: MidiNameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiName.schema);
    this.contents = opts?.contents ?? operations.zero(MidiName.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MidiBankAttributes = Record<string, unknown>;

export type MidiBankContents = [number];

/**
 * The `<midi-bank>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-bank>` element specifies a MIDI 1.0 bank number ranging from 1 to 16,384.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-bank/}
 */
export class MidiBank implements XMLElement<'midi-bank', MidiBankAttributes, MidiBankContents> {
  static readonly schema = {
    name: 'midi-bank',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi16384', value: { type: 'int', min: 1, max: 16384 } } },
    ],
  } as const;

  readonly schema = MidiBank.schema;

  attributes: MidiBankAttributes;
  contents: MidiBankContents;

  constructor(opts?: { attributes?: Partial<MidiBankAttributes>; contents?: MidiBankContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiBank.schema);
    this.contents = opts?.contents ?? operations.zero(MidiBank.schema.contents);
  }

  /** Gets @type {number}. */
  getMidi16384(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setMidi16384(midi16384: number): this {
    this.contents[0] = midi16384;
    return this;
  }
}

export type MidiProgramAttributes = Record<string, unknown>;

export type MidiProgramContents = [number];

/**
 * The `<midi-program>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<midi-program>` element specifies a MIDI 1.0 program number ranging from 1 to 128.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-program/}
 */
export class MidiProgram implements XMLElement<'midi-program', MidiProgramAttributes, MidiProgramContents> {
  static readonly schema = {
    name: 'midi-program',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi128', value: { type: 'int', min: 1, max: 128 } } },
    ],
  } as const;

  readonly schema = MidiProgram.schema;

  attributes: MidiProgramAttributes;
  contents: MidiProgramContents;

  constructor(opts?: { attributes?: Partial<MidiProgramAttributes>; contents?: MidiProgramContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiProgram.schema);
    this.contents = opts?.contents ?? operations.zero(MidiProgram.schema.contents);
  }

  /** Gets @type {number}. */
  getMidi128(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setMidi128(midi128: number): this {
    this.contents[0] = midi128;
    return this;
  }
}

export type MidiUnpitchedAttributes = Record<string, unknown>;

export type MidiUnpitchedContents = [number];

/**
 * The `<midi-unpitched>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * For unpitched instruments, the `<midi-unpitched>` element specifies a MIDI 1.0 note number ranging from 1 to 128. It
 * is usually used with MIDI banks for percussion. Note that MIDI 1.0 note numbers are generally specified from 0 to 127
 * rather than the 1 to 128 numbering used in this element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-unpitched/}
 */
export class MidiUnpitched implements XMLElement<'midi-unpitched', MidiUnpitchedAttributes, MidiUnpitchedContents> {
  static readonly schema = {
    name: 'midi-unpitched',
    attributes: {},
    contents: [
      { type: 'required', value: { type: 'label', label: 'midi128', value: { type: 'int', min: 1, max: 128 } } },
    ],
  } as const;

  readonly schema = MidiUnpitched.schema;

  attributes: MidiUnpitchedAttributes;
  contents: MidiUnpitchedContents;

  constructor(opts?: { attributes?: Partial<MidiUnpitchedAttributes>; contents?: MidiUnpitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiUnpitched.schema);
    this.contents = opts?.contents ?? operations.zero(MidiUnpitched.schema.contents);
  }

  /** Gets @type {number}. */
  getMidi128(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setMidi128(midi128: number): this {
    this.contents[0] = midi128;
    return this;
  }
}

export type VolumeAttributes = Record<string, unknown>;

export type VolumeContents = [number];

/**
 * The `<volume>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<volume>` element value is a percentage of the maximum ranging from 0 to 100, with decimal values allowed. This
 * corresponds to a scaling value for the MIDI 1.0 channel volume controller.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/volume/}
 */
export class Volume implements XMLElement<'volume', VolumeAttributes, VolumeContents> {
  static readonly schema = {
    name: 'volume',
    attributes: {},
    contents: [
      { type: 'label', label: 'volume', value: { type: 'required', value: { type: 'float', min: 0, max: 100 } } },
    ],
  } as const;

  readonly schema = Volume.schema;

  attributes: VolumeAttributes;
  contents: VolumeContents;

  constructor(opts?: { attributes?: Partial<VolumeAttributes>; contents?: VolumeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Volume.schema);
    this.contents = opts?.contents ?? operations.zero(Volume.schema.contents);
  }

  /** Gets @type {number}. */
  getVolume(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setVolume(volume: number): this {
    this.contents[0] = volume;
    return this;
  }
}

export type PanAttributes = Record<string, unknown>;

export type PanContents = [number];

/**
 * The `<pan>` element
 *
 * Parent element: `<midi-instrument>`\
 *
 * The `<pan>` and `<elevation>` elements allow placing of sound in a 3-D space relative to the listener. Both are
 * expressed in degrees ranging from -180 to 180. For pan, 0 is straight ahead, -90 is hard left, 90 is hard right, and
 * -180 and 180 are directly behind the listener.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pan/}
 */
export class Pan implements XMLElement<'pan', PanAttributes, PanContents> {
  static readonly schema = {
    name: 'pan',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'float', min: -180, max: 180 } } },
    ],
  } as const;

  readonly schema = Pan.schema;

  attributes: PanAttributes;
  contents: PanContents;

  constructor(opts?: { attributes?: Partial<PanAttributes>; contents?: PanContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pan.schema);
    this.contents = opts?.contents ?? operations.zero(Pan.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type ElevationAttributes = Record<string, unknown>;

export type ElevationContents = [number];

/**
 * The `<elevation>` element
 *
 * Parent element: `<midi-instrument>`
 *
 * The `<elevation>` and `<pan>` elements allow placing of sound in a 3-D space relative to the listener. Both are
 * expressed in degrees ranging from -180 to 180. For `<elevation>`, 0 is level with the listener, 90 is directly above,
 * and -90 is directly below.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/elevation/}
 */
export class Elevation implements XMLElement<'elevation', ElevationAttributes, ElevationContents> {
  static readonly schema = {
    name: 'elevation',
    attributes: {},
    contents: [
      { type: 'label', label: 'elevation', value: { type: 'required', value: { type: 'float', min: -180, max: 180 } } },
    ],
  } as const;

  readonly schema = Elevation.schema;

  attributes: ElevationAttributes;
  contents: ElevationContents;

  constructor(opts?: { attributes?: Partial<ElevationAttributes>; contents?: ElevationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Elevation.schema);
    this.contents = opts?.contents ?? operations.zero(Elevation.schema.contents);
  }

  /** Gets @type {number}. */
  getElevation(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setElevation(elevation: number): this {
    this.contents[0] = elevation;
    return this;
  }
}

export type MidiInstrumentAttributes = {
  /**
   * Refers to the `<score-instrument>` element affected by the change.
   */
  id: string;
};

export type MidiInstrumentContents = [
  MidiChannel | null,
  MidiName | null,
  MidiBank | null,
  MidiProgram | null,
  MidiUnpitched | null,
  Volume | null,
  Pan | null,
  Elevation | null,
];

/**
 * The `<midi-instrument>` element
 *
 * Parent elements: `<score-part>`, `<sound>`
 *
 * The `<midi-instrument>` element defines MIDI 1.0 instrument playback. The `<midi-instrument>` element can be a part
 * of either the `<score-instrument>` element at the start of a part, or the <sound>` element within a part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/midi-instrument/}
 */
export class MidiInstrument implements XMLElement<'midi-instrument', MidiInstrumentAttributes, MidiInstrumentContents> {
  static readonly schema = {
    name: 'midi-instrument',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      { type: 'optional', value: MidiChannel },
      { type: 'optional', value: MidiName },
      { type: 'optional', value: MidiBank },
      { type: 'optional', value: MidiProgram },
      { type: 'optional', value: MidiUnpitched },
      { type: 'optional', value: Volume },
      { type: 'optional', value: Pan },
      { type: 'optional', value: Elevation },
    ],
  } as const;

  readonly schema = MidiInstrument.schema;

  attributes: MidiInstrumentAttributes;
  contents: MidiInstrumentContents;

  constructor(opts?: { attributes?: Partial<MidiInstrumentAttributes>; contents?: MidiInstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MidiInstrument.schema);
    this.contents = opts?.contents ?? operations.zero(MidiInstrument.schema.contents);
  }
  /** Gets @type {MidiInstrumentAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {MidiInstrumentAttributes['id']}. */
  setId(id: string): MidiInstrument {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {MidiChannel | null}. */
  getMidiChannel(): MidiChannel | null {
    return this.contents[0];
  }
  /** Sets @type {MidiChannel | null}. */
  setMidiChannel(midiChannel: MidiChannel | null): this {
    this.contents[0] = midiChannel;
    return this;
  }
  /** Gets @type {MidiName | null}. */
  getMidiName(): MidiName | null {
    return this.contents[1];
  }
  /** Sets @type {MidiName | null}. */
  setMidiName(midiName: MidiName | null): this {
    this.contents[1] = midiName;
    return this;
  }
  /** Gets @type {MidiBank | null}. */
  getMidiBank(): MidiBank | null {
    return this.contents[2];
  }
  /** Sets @type {MidiBank | null}. */
  setMidiBank(midiBank: MidiBank | null): this {
    this.contents[2] = midiBank;
    return this;
  }
  /** Gets @type {MidiProgram | null}. */
  getMidiProgram(): MidiProgram | null {
    return this.contents[3];
  }
  /** Sets @type {MidiProgram | null}. */
  setMidiProgram(midiProgram: MidiProgram | null): this {
    this.contents[3] = midiProgram;
    return this;
  }
  /** Gets @type {MidiUnpitched | null}. */
  getMidiUnpitched(): MidiUnpitched | null {
    return this.contents[4];
  }
  /** Sets @type {MidiUnpitched | null}. */
  setMidiUnpitched(midiUnpitched: MidiUnpitched | null): this {
    this.contents[4] = midiUnpitched;
    return this;
  }
  /** Gets @type {Volume | null}. */
  getVolume(): Volume | null {
    return this.contents[5];
  }
  /** Sets @type {Volume | null}. */
  setVolume(volume: Volume | null): this {
    this.contents[5] = volume;
    return this;
  }
  /** Gets @type {Pan | null}. */
  getPan(): Pan | null {
    return this.contents[6];
  }
  /** Sets @type {Pan | null}. */
  setPan(pan: Pan | null): this {
    this.contents[6] = pan;
    return this;
  }
  /** Gets @type {Elevation | null}. */
  getElevation(): Elevation | null {
    return this.contents[7];
  }
  /** Sets @type {Elevation | null}. */
  setElevation(elevation: Elevation | null): this {
    this.contents[7] = elevation;
    return this;
  }
}

export type ScorePartAttributes = {
  /**
   *
   */
  id: string;
};

export type ScorePartContents = [
  Identification | null,
  Array<PartLink>,
  PartName,
  PartNameDisplay | null,
  PartAbbreviation | null,
  PartAbbreviationDisplay | null,
  Array<Group>,
  Array<ScoreInstrument>,
  Array<Player>,
  Array<MidiDevice | MidiInstrument>,
];

/**
 * The `<score-part>` element
 *
 * Parent element: `<part-list>`
 *
 * The `<score-part>` element collects part-wide information for each part in a score. Often each MusicXML part
 * corresponds to a track in a Standard MIDI Format 1 file. In this case, the `<midi-device>` element is used to make a
 * MIDI device or port assignment for the given track or specific MIDI instruments. Initial `<midi-instrument>`
 * assignments may be made here as well.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-part/}
 */
export class ScorePart implements XMLElement<'score-part', ScorePartAttributes, ScorePartContents> {
  static readonly schema = {
    name: 'score-part',
    attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
    contents: [
      { type: 'optional', value: Identification },
      { type: 'label', label: 'part-links', value: { type: 'zeroOrMore', value: PartLink } },
      { type: 'required', value: PartName },
      { type: 'optional', value: PartNameDisplay },
      { type: 'optional', value: PartAbbreviation },
      { type: 'optional', value: PartAbbreviationDisplay },
      { type: 'label', label: 'groups', value: { type: 'zeroOrMore', value: Group } },
      { type: 'label', label: 'score-instruments', value: { type: 'zeroOrMore', value: ScoreInstrument } },
      { type: 'label', label: 'players', value: { type: 'zeroOrMore', value: Player } },
      {
        type: 'label',
        label: 'midis',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [MidiDevice, MidiInstrument] } },
      },
    ],
  } as const;

  readonly schema = ScorePart.schema;

  attributes: ScorePartAttributes;
  contents: ScorePartContents;

  constructor(opts?: { attributes?: Partial<ScorePartAttributes>; contents?: ScorePartContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScorePart.schema);
    this.contents = opts?.contents ?? operations.zero(ScorePart.schema.contents);
  }
  /** Gets @type {ScorePartAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {ScorePartAttributes['id']}. */
  setId(id: string): ScorePart {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Identification | null}. */
  getIdentification(): Identification | null {
    return this.contents[0];
  }
  /** Sets @type {Identification | null}. */
  setIdentification(identification: Identification | null): this {
    this.contents[0] = identification;
    return this;
  }
  /** Gets @type {Array<PartLink>}. */
  getPartLinks(): Array<PartLink> {
    return this.contents[1];
  }
  /** Sets @type {Array<PartLink>}. */
  setPartLinks(partLinks: Array<PartLink>): this {
    this.contents[1] = partLinks;
    return this;
  }
  /** Gets @type {PartName}. */
  getPartName(): PartName {
    return this.contents[2];
  }
  /** Sets @type {PartName}. */
  setPartName(partName: PartName): this {
    this.contents[2] = partName;
    return this;
  }
  /** Gets @type {PartNameDisplay | null}. */
  getPartNameDisplay(): PartNameDisplay | null {
    return this.contents[3];
  }
  /** Sets @type {PartNameDisplay | null}. */
  setPartNameDisplay(partNameDisplay: PartNameDisplay | null): this {
    this.contents[3] = partNameDisplay;
    return this;
  }
  /** Gets @type {PartAbbreviation | null}. */
  getPartAbbreviation(): PartAbbreviation | null {
    return this.contents[4];
  }
  /** Sets @type {PartAbbreviation | null}. */
  setPartAbbreviation(partAbbreviation: PartAbbreviation | null): this {
    this.contents[4] = partAbbreviation;
    return this;
  }
  /** Gets @type {PartAbbreviationDisplay | null}. */
  getPartAbbreviationDisplay(): PartAbbreviationDisplay | null {
    return this.contents[5];
  }
  /** Sets @type {PartAbbreviationDisplay | null}. */
  setPartAbbreviationDisplay(partAbbreviationDisplay: PartAbbreviationDisplay | null): this {
    this.contents[5] = partAbbreviationDisplay;
    return this;
  }
  /** Gets @type {Array<Group>}. */
  getGroups(): Array<Group> {
    return this.contents[6];
  }
  /** Sets @type {Array<Group>}. */
  setGroups(groups: Array<Group>): this {
    this.contents[6] = groups;
    return this;
  }
  /** Gets @type {Array<ScoreInstrument>}. */
  getScoreInstruments(): Array<ScoreInstrument> {
    return this.contents[7];
  }
  /** Sets @type {Array<ScoreInstrument>}. */
  setScoreInstruments(scoreInstruments: Array<ScoreInstrument>): this {
    this.contents[7] = scoreInstruments;
    return this;
  }
  /** Gets @type {Array<Player>}. */
  getPlayers(): Array<Player> {
    return this.contents[8];
  }
  /** Sets @type {Array<Player>}. */
  setPlayers(players: Array<Player>): this {
    this.contents[8] = players;
    return this;
  }
  /** Gets @type {Array<MidiDevice | MidiInstrument>}. */
  getMidis(): Array<MidiDevice | MidiInstrument> {
    return this.contents[9];
  }
  /** Sets @type {Array<MidiDevice | MidiInstrument>}. */
  setMidis(midis: Array<MidiDevice | MidiInstrument>): this {
    this.contents[9] = midis;
    return this;
  }
}

export type PartListAttributes = Record<string, unknown>;

export type PartListContents = [Array<PartGroup>, ScorePart, Array<PartGroup | ScorePart>];

/**
 * The `<part-list>` element
 *
 * Parent elements: `<score-partwise version="4.0">`, `<score-timewise>`
 *
 * The `<part-list>` element identifies the different musical parts in this document. Each part has an ID that is used
 * later within the musical data. Since parts may be encoded separately and combined later, identification elements are
 * present at both the score and <score-part> levels.
 *
 * There must be at least one `<score-part>`, combined as desired with `<part-group>` elements that indicate braces and
 * brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the
 * `<part-list>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-list/}
 */
export class PartList implements XMLElement<'part-list', PartListAttributes, PartListContents> {
  static readonly schema = {
    name: 'part-list',
    attributes: {},
    contents: [
      { type: 'label', label: 'part-groups', value: { type: 'zeroOrMore', value: PartGroup } },
      { type: 'required', value: ScorePart },
      {
        type: 'label',
        label: 'parts',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [PartGroup, ScorePart] } },
      },
    ],
  } as const;

  readonly schema = PartList.schema;

  attributes: PartListAttributes;
  contents: PartListContents;

  constructor(opts?: { attributes?: Partial<PartListAttributes>; contents?: PartListContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartList.schema);
    this.contents = opts?.contents ?? operations.zero(PartList.schema.contents);
  }

  /** Gets @type {Array<PartGroup>}. */
  getPartGroups(): Array<PartGroup> {
    return this.contents[0];
  }
  /** Sets @type {Array<PartGroup>}. */
  setPartGroups(partGroups: Array<PartGroup>): this {
    this.contents[0] = partGroups;
    return this;
  }
  /** Gets @type {ScorePart}. */
  getScorePart(): ScorePart {
    return this.contents[1];
  }
  /** Sets @type {ScorePart}. */
  setScorePart(scorePart: ScorePart): this {
    this.contents[1] = scorePart;
    return this;
  }
  /** Gets @type {Array<PartGroup | ScorePart>}. */
  getParts(): Array<PartGroup | ScorePart> {
    return this.contents[2];
  }
  /** Sets @type {Array<PartGroup | ScorePart>}. */
  setParts(parts: Array<PartGroup | ScorePart>): this {
    this.contents[2] = parts;
    return this;
  }
}

export type ChordAttributes = Record<string, unknown>;

export type ChordContents = [];

/**
 * The `<chord>` element
 *
 * Parent element: `<note>`
 *
 * The `<chord>` element indicates that this note is an additional chord tone with the preceding note.
 *
 * The `<duration>` of a `<chord>` note does not move the musical position within a `<measure>`. That is done by the
 * `<duration>` of the first preceding note without a `<chord>` element. Thus the `<duration>` of a `<chord>` note
 * cannot be longer than the preceding note.
 *
 * In most cases the `<duration>` will be the same as the preceding note. However it can be shorter in situations such
 * as multiple stops for string instruments. Here is an example from Mozart's Concerto No. 3 for Violin, K. 216:
 *
 * If these first three notes are represented as a chord, the quarter notes must be the ones with the `<chord>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/chord/}
 */
export class Chord implements XMLElement<'chord', ChordAttributes, ChordContents> {
  static readonly schema = { name: 'chord', attributes: {}, contents: [] } as const;

  readonly schema = Chord.schema;

  attributes: ChordAttributes;
  contents: ChordContents;

  constructor(opts?: { attributes?: Partial<ChordAttributes>; contents?: ChordContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Chord.schema);
    this.contents = opts?.contents ?? operations.zero(Chord.schema.contents);
  }
}

export type StepAttributes = Record<string, unknown>;

export type StepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

/**
 * The `<step>` element
 *
 * Parent element: `<pitch>`
 *
 * The `<step>` element represents a step of the diatonic scale, represented using the English letters A through G.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/step/}
 */
export class Step implements XMLElement<'step', StepAttributes, StepContents> {
  static readonly schema = {
    name: 'step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = Step.schema;

  attributes: StepAttributes;
  contents: StepContents;

  constructor(opts?: { attributes?: Partial<StepAttributes>; contents?: StepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Step.schema);
    this.contents = opts?.contents ?? operations.zero(Step.schema.contents);
  }

  /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): this {
    this.contents[0] = step;
    return this;
  }
}

export type AlterAttributes = Record<string, unknown>;

export type AlterContents = [number];

/**
 * The `<alter>` element
 *
 * Parent element: `<pitch>`
 *
 * The `<alter> element represents chromatic alteration in number of semitones (e.g., -1 for flat, 1 for sharp). Decimal
 * values like 0.5 (quarter tone sharp) are used for microtones.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/alter/}
 */
export class Alter implements XMLElement<'alter', AlterAttributes, AlterContents> {
  static readonly schema = {
    name: 'alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Alter.schema;

  attributes: AlterAttributes;
  contents: AlterContents;

  constructor(opts?: { attributes?: Partial<AlterAttributes>; contents?: AlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Alter.schema);
    this.contents = opts?.contents ?? operations.zero(Alter.schema.contents);
  }

  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type OctaveAttributes = Record<string, unknown>;

export type OctaveContents = [number];

/**
 * The `<octave>` element
 *
 * Parent element: `<pitch>`
 *
 * Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/octave/}
 */
export class Octave implements XMLElement<'octave', OctaveAttributes, OctaveContents> {
  static readonly schema = {
    name: 'octave',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = Octave.schema;

  attributes: OctaveAttributes;
  contents: OctaveContents;

  constructor(opts?: { attributes?: Partial<OctaveAttributes>; contents?: OctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Octave.schema);
    this.contents = opts?.contents ?? operations.zero(Octave.schema.contents);
  }

  /** Gets @type {number}. */
  getOctave(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setOctave(octave: number): this {
    this.contents[0] = octave;
    return this;
  }
}

export type PitchAttributes = Record<string, unknown>;

export type PitchContents = [Step, Alter | null, Octave];

/**
 * The `<pitch>` element
 *
 * Parent element: `<note>`
 *
 * Pitch is represented as a combination of the step of the diatonic scale, the chromatic alteration, and the octave.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pitch/}
 */
export class Pitch implements XMLElement<'pitch', PitchAttributes, PitchContents> {
  static readonly schema = {
    name: 'pitch',
    attributes: {},
    contents: [
      { type: 'required', value: Step },
      { type: 'optional', value: Alter },
      { type: 'required', value: Octave },
    ],
  } as const;

  readonly schema = Pitch.schema;

  attributes: PitchAttributes;
  contents: PitchContents;

  constructor(opts?: { attributes?: Partial<PitchAttributes>; contents?: PitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pitch.schema);
    this.contents = opts?.contents ?? operations.zero(Pitch.schema.contents);
  }

  /** Gets @type {Step}. */
  getStep(): Step {
    return this.contents[0];
  }
  /** Sets @type {Step}. */
  setStep(step: Step): this {
    this.contents[0] = step;
    return this;
  }
  /** Gets @type {Alter | null}. */
  getAlter(): Alter | null {
    return this.contents[1];
  }
  /** Sets @type {Alter | null}. */
  setAlter(alter: Alter | null): this {
    this.contents[1] = alter;
    return this;
  }
  /** Gets @type {Octave}. */
  getOctave(): Octave {
    return this.contents[2];
  }
  /** Sets @type {Octave}. */
  setOctave(octave: Octave): this {
    this.contents[2] = octave;
    return this;
  }
}

export type DisplayStepAttributes = Record<string, unknown>;

export type DisplayStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

/**
 * The `<display-step>` element
 *
 * Parent elements: `<rest>`, `<unpitched>`
 *
 * The `<display-step>` and `<display-octave>` elements are used to place `<rest>` and `<unpitched>` elements on the
 * staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is
 * used, the `<display-step>` and `<display-octave>` elements are interpreted as if in treble clef, with a G in octave
 * 4 on line 2.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/display-step/}
 */
export class DisplayStep implements XMLElement<'display-step', DisplayStepAttributes, DisplayStepContents> {
  static readonly schema = {
    name: 'display-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = DisplayStep.schema;

  attributes: DisplayStepAttributes;
  contents: DisplayStepContents;

  constructor(opts?: { attributes?: Partial<DisplayStepAttributes>; contents?: DisplayStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DisplayStep.schema);
    this.contents = opts?.contents ?? operations.zero(DisplayStep.schema.contents);
  }

  /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): this {
    this.contents[0] = step;
    return this;
  }
}

export type DisplayOctaveAttributes = Record<string, unknown>;

export type DisplayOctaveContents = [number];

/**
 * The `<display-octave>` element
 *
 * Parent elements: `<rest>`, `<unpitched>`
 *
 * The `<display-step>` and `<display-octave>` elements are used to place `<rest>` and `<unpitched>` elements on the
 * staff without implying that these elements have pitch. Positioning follows the current clef. If percussion clef is
 * used, the `<display-step>` and `<display-octave>` elements are interpreted as if in treble clef, with a G in octave
 * 4 on line 2.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/display-octave/}
 */
export class DisplayOctave implements XMLElement<'display-octave', DisplayOctaveAttributes, DisplayOctaveContents> {
  static readonly schema = {
    name: 'display-octave',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = DisplayOctave.schema;

  attributes: DisplayOctaveAttributes;
  contents: DisplayOctaveContents;

  constructor(opts?: { attributes?: Partial<DisplayOctaveAttributes>; contents?: DisplayOctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DisplayOctave.schema);
    this.contents = opts?.contents ?? operations.zero(DisplayOctave.schema.contents);
  }

  /** Gets @type {number}. */
  getOctave(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setOctave(octave: number): this {
    this.contents[0] = octave;
    return this;
  }
}

export type UnpitchedAttributes = Record<string, unknown>;

export type UnpitchedContents = [DisplayStep, DisplayOctave];

/**
 * The `<unpitched>` element
 *
 * Parent element: `<note>`
 *
 * The `<unpitched>` element represents notes that are notated on the staff but lack definite pitch, such as unpitched
 * percussion and speaking voice. If the child elements are not present, the note is placed on the middle line of the
 * staff. This is generally used with a one-line staff. Notes in percussion clef should always use an `<unpitched>`
 * element rather than a `<pitch>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/unpitched/}
 */
export class Unpitched implements XMLElement<'unpitched', UnpitchedAttributes, UnpitchedContents> {
  static readonly schema = {
    name: 'unpitched',
    attributes: {},
    contents: [
      { type: 'required', value: DisplayStep },
      { type: 'required', value: DisplayOctave },
    ],
  } as const;

  readonly schema = Unpitched.schema;

  attributes: UnpitchedAttributes;
  contents: UnpitchedContents;

  constructor(opts?: { attributes?: Partial<UnpitchedAttributes>; contents?: UnpitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Unpitched.schema);
    this.contents = opts?.contents ?? operations.zero(Unpitched.schema.contents);
  }

  /** Gets @type {DisplayStep}. */
  getDisplayStep(): DisplayStep {
    return this.contents[0];
  }
  /** Sets @type {DisplayStep}. */
  setDisplayStep(displayStep: DisplayStep): this {
    this.contents[0] = displayStep;
    return this;
  }
  /** Gets @type {DisplayOctave}. */
  getDisplayOctave(): DisplayOctave {
    return this.contents[1];
  }
  /** Sets @type {DisplayOctave}. */
  setDisplayOctave(displayOctave: DisplayOctave): this {
    this.contents[1] = displayOctave;
    return this;
  }
}

export type RestAttributes = {
  /**
   * If yes, this indicates this is a complete measure rest.
   */
  measure: 'yes' | 'no' | null;
};

export type RestContents = [[DisplayStep, DisplayOctave] | null];

/**
 * The `<rest>` element
 *
 * Parent element: `<note>
 *
 * The `<rest> element indicates notated rests or silences. A `<rest> element is usually empty, but placement on the
 * staff can be specified using `<display-step>` and `<display-octave>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rest/}
 */
export class Rest implements XMLElement<'rest', RestAttributes, RestContents> {
  static readonly schema = {
    name: 'rest',
    attributes: { measure: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'optional',
        value: {
          type: 'label',
          label: 'value',
          value: [
            { type: 'required', value: DisplayStep },
            { type: 'required', value: DisplayOctave },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Rest.schema;

  attributes: RestAttributes;
  contents: RestContents;

  constructor(opts?: { attributes?: Partial<RestAttributes>; contents?: RestContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rest.schema);
    this.contents = opts?.contents ?? operations.zero(Rest.schema.contents);
  }
  /** Gets @type {RestAttributes['measure']}. */
  getMeasure(): 'yes' | 'no' | null {
    return this.attributes['measure'];
  }
  /** Sets @type {RestAttributes['measure']}. */
  setMeasure(measure: 'yes' | 'no' | null): Rest {
    this.attributes['measure'] = measure;
    return this;
  }
  /** Gets @type {[DisplayStep, DisplayOctave] | null}. */
  getValue(): [DisplayStep, DisplayOctave] | null {
    return this.contents[0];
  }
  /** Sets @type {[DisplayStep, DisplayOctave] | null}. */
  setValue(value: [DisplayStep, DisplayOctave] | null): this {
    this.contents[0] = value;
    return this;
  }
}

export type DurationAttributes = Record<string, unknown>;

export type DurationContents = [number];

/**
 * The `<duration>` element
 *
 * Parent elements: `<backup>`, `<figured-bass>`, `<forward>`, `<note>`
 *
 * Duration is a positive number specified in division units. The `<duration>` element represents the intended duration
 * vs. the notated duration (for instance, differences in dotted notes in Baroque-era music). Differences in duration
 * specific to an interpretation or performance should be represented using the `<note>` element's attack and release
 * attributes.
 *
 * The `<duration>` element moves the musical position when used in `<backup>` elements, `<forward>` elements, and
 * `<note>` elements that do not contain a `<chord>` child element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/duration/}
 */
export class Duration implements XMLElement<'duration', DurationAttributes, DurationContents> {
  static readonly schema = {
    name: 'duration',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'positive-divisions', value: { type: 'float', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Duration.schema;

  attributes: DurationAttributes;
  contents: DurationContents;

  constructor(opts?: { attributes?: Partial<DurationAttributes>; contents?: DurationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Duration.schema);
    this.contents = opts?.contents ?? operations.zero(Duration.schema.contents);
  }

  /** Gets @type {number}. */
  getPositiveDivisions(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setPositiveDivisions(positiveDivisions: number): this {
    this.contents[0] = positiveDivisions;
    return this;
  }
}

export type TieAttributes = {
  /**
   * Indicates if this is the start or stop of the tie.
   */
  type: 'start' | 'stop';
  /**
   * Indicates which particular times to apply a `<tie>` element through a repeated section.
   */
  'time-only': string | null;
};

export type TieContents = [];

/**
 * The `<tie>` element
 *
 * Parent element: `<note>`
 *
 * The `<tie>` element indicates that a tie begins or ends with this note. The `<tie>` element indicates sound; the
 * `<tied>` element indicates notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tie/}
 */
export class Tie implements XMLElement<'tie', TieAttributes, TieContents> {
  static readonly schema = {
    name: 'tie',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Tie.schema;

  attributes: TieAttributes;
  contents: TieContents;

  constructor(opts?: { attributes?: Partial<TieAttributes>; contents?: TieContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tie.schema);
    this.contents = opts?.contents ?? operations.zero(Tie.schema.contents);
  }
  /** Gets @type {TieAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {TieAttributes['type']}. */
  setType(type: 'start' | 'stop'): Tie {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {TieAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {TieAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): Tie {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type CueAttributes = Record<string, unknown>;

export type CueContents = [];

/**
 * The `<cue>` element
 *
 * Parent element: `<note>`
 *
 * The `<cue>` element indicates the presence of a cue note. In MusicXML, a cue note is a silent note with no playback.
 * Normal notes that play can be specified as cue size using the `<type>` element. A cue note that is specified as full
 * size using the `<type>` element will still remain silent.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/cue/}
 */
export class Cue implements XMLElement<'cue', CueAttributes, CueContents> {
  static readonly schema = { name: 'cue', attributes: {}, contents: [] } as const;

  readonly schema = Cue.schema;

  attributes: CueAttributes;
  contents: CueContents;

  constructor(opts?: { attributes?: Partial<CueAttributes>; contents?: CueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Cue.schema);
    this.contents = opts?.contents ?? operations.zero(Cue.schema.contents);
  }
}

export type GraceAttributes = {
  /**
   * Indicates to make time, not steal time, for grace note playback. The units are in real-time divisions for the
   * grace note.
   */
  'make-time': number | null;
  /**
   * The value is yes for slashed grace notes and no if no slash is present.
   */
  slash: 'yes' | 'no' | null;
  /**
   * Indicates the percentage of time to steal from the following note for the grace note playback, as for
   * appoggiaturas.
   */
  'steal-time-following': number | null;
  /**
   * The steal-time-previous attribute indicates the percentage of time to steal from the previous note for the
   * grace note playback.
   */
  'steal-time-previous': number | null;
};

export type GraceContents = [];

/**
 * The `<grace>` element
 *
 * Parent element: `<note>`
 *
 * The `<grace>` element indicates the presence of a grace note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/grace/}
 */
export class Grace implements XMLElement<'grace', GraceAttributes, GraceContents> {
  static readonly schema = {
    name: 'grace',
    attributes: {
      'make-time': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'steal-time-following': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'steal-time-previous': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
    },
    contents: [],
  } as const;

  readonly schema = Grace.schema;

  attributes: GraceAttributes;
  contents: GraceContents;

  constructor(opts?: { attributes?: Partial<GraceAttributes>; contents?: GraceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Grace.schema);
    this.contents = opts?.contents ?? operations.zero(Grace.schema.contents);
  }
  /** Gets @type {GraceAttributes['make-time']}. */
  getMakeTime(): number | null {
    return this.attributes['make-time'];
  }
  /** Sets @type {GraceAttributes['make-time']}. */
  setMakeTime(makeTime: number | null): Grace {
    this.attributes['make-time'] = makeTime;
    return this;
  }
  /** Gets @type {GraceAttributes['slash']}. */
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  /** Sets @type {GraceAttributes['slash']}. */
  setSlash(slash: 'yes' | 'no' | null): Grace {
    this.attributes['slash'] = slash;
    return this;
  }
  /** Gets @type {GraceAttributes['steal-time-following']}. */
  getStealTimeFollowing(): number | null {
    return this.attributes['steal-time-following'];
  }
  /** Sets @type {GraceAttributes['steal-time-following']}. */
  setStealTimeFollowing(stealTimeFollowing: number | null): Grace {
    this.attributes['steal-time-following'] = stealTimeFollowing;
    return this;
  }
  /** Gets @type {GraceAttributes['steal-time-previous']}. */
  getStealTimePrevious(): number | null {
    return this.attributes['steal-time-previous'];
  }
  /** Sets @type {GraceAttributes['steal-time-previous']}. */
  setStealTimePrevious(stealTimePrevious: number | null): Grace {
    this.attributes['steal-time-previous'] = stealTimePrevious;
    return this;
  }
}

export type InstrumentAttributes = {
  /**
   * An IDREF back to the `<score-instrument>` id attribute.
   */
  id: string;
};

export type InstrumentContents = [];

/**
 * The `<instrument>` element
 *
 * Parent element: `<note>`
 *
 * The `<instrument>` element distinguishes between `<score-instrument>` elements in a `<score-part>`. If multiple
 * `<score-instrument>` elements are specified in a `<score-part>`, there should be an `<instrument>` element for each
 * note in the `<part>`. Notes that are shared between multiple `<score-instrument>`s can have more than one
 * `<instrument>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument/}
 */
export class Instrument implements XMLElement<'instrument', InstrumentAttributes, InstrumentContents> {
  static readonly schema = {
    name: 'instrument',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [],
  } as const;

  readonly schema = Instrument.schema;

  attributes: InstrumentAttributes;
  contents: InstrumentContents;

  constructor(opts?: { attributes?: Partial<InstrumentAttributes>; contents?: InstrumentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Instrument.schema);
    this.contents = opts?.contents ?? operations.zero(Instrument.schema.contents);
  }
  /** Gets @type {InstrumentAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {InstrumentAttributes['id']}. */
  setId(id: string): Instrument {
    this.attributes['id'] = id;
    return this;
  }
}

export type VoiceAttributes = Record<string, unknown>;

export type VoiceContents = [string];

/**
 * The `<voice>` element
 *
 * Parent elements: `<direction>`, `<forward>`, `<note>`
 *
 * A voice is a sequence of musical events (e.g. notes, chords, rests) that proceeds linearly in time. The `<voice>`
 * element is used to distinguish between multiple voices in individual parts.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/voice/}
 */
export class Voice implements XMLElement<'voice', VoiceAttributes, VoiceContents> {
  static readonly schema = {
    name: 'voice',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Voice.schema;

  attributes: VoiceAttributes;
  contents: VoiceContents;

  constructor(opts?: { attributes?: Partial<VoiceAttributes>; contents?: VoiceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Voice.schema);
    this.contents = opts?.contents ?? operations.zero(Voice.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type TypeAttributes = {
  /**
   * Indicates full, cue, grace-cue, or large size. If not specified, the value is full for regular notes, grace-cue
   * for notes that contain both `<grace>` and `<cue>` elements, and cue for notes that contain either a `<cue>` or
   * a `<grace>` element, but not both.
   */
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
};

export type TypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima',
];

/**
 * The `<type>` element
 *
 * Parent element: `<note>`
 *
 * The `<type>` element indicates the graphic note type. Values range from 1024th to maxima.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/type/}
 */
export class Type implements XMLElement<'type', TypeAttributes, TypeContents> {
  static readonly schema = {
    name: 'type',
    attributes: {
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Type.schema;

  attributes: TypeAttributes;
  contents: TypeContents;

  constructor(opts?: { attributes?: Partial<TypeAttributes>; contents?: TypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Type.schema);
    this.contents = opts?.contents ?? operations.zero(Type.schema.contents);
  }
  /** Gets @type {TypeAttributes['size']}. */
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  /** Sets @type {TypeAttributes['size']}. */
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Type {
    this.attributes['size'] = size;
    return this;
  }
  /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): this {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type DotAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies whether the dot should appear above or below the staff line. It is ignored for notes that appear on a
   * staff space.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type DotContents = [];

/**
 * The `<dot>` element
 *
 * Parent element: `<note>`
 *
 * One `<dot>` element is used for each dot of prolongation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/dot/}
 */
export class Dot implements XMLElement<'dot', DotAttributes, DotContents> {
  static readonly schema = {
    name: 'dot',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Dot.schema;

  attributes: DotAttributes;
  contents: DotContents;

  constructor(opts?: { attributes?: Partial<DotAttributes>; contents?: DotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Dot.schema);
    this.contents = opts?.contents ?? operations.zero(Dot.schema.contents);
  }
  /** Gets @type {DotAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DotAttributes['color']}. */
  setColor(color: string | null): Dot {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DotAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DotAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Dot {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DotAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DotAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Dot {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DotAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DotAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Dot {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DotAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DotAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Dot {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DotAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DotAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Dot {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DotAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DotAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Dot {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DotAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DotAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Dot {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DotAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DotAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Dot {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DotAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DotAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Dot {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type AccidentalAttributes = {
  /**
   * Specifies whether or not brackets are put around a symbol for an editorial indication. If not specified, it is
   * left to application defaults.
   */
  bracket: 'yes' | 'no' | null;
  /**
   * If yes, indicates that this is a cautionary accidental. The value is no if not present.
   */
  cautionary: 'yes' | 'no' | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * If yes, indicates that this is an editorial accidental. The value is no if not present.
   */
  editorial: 'yes' | 'no' | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies whether or not parentheses are put around a symbol for an editorial indication. If not specified, it
   * is left to application defaults.
   */
  parentheses: 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Specifies the symbol size to use for an editorial indication. If not specified, it is left to application
   * defaults.
   */
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
  /**
   * References a specific Standard Music Font Layout (SMuFL) accidental glyph. This is used both with the other
   * accidental value and for disambiguating cases where a single MusicXML accidental value could be represented by
   * multiple SMuFL glyphs.
   */
  smufl: string | null;
};

export type AccidentalContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron',
];

/**
 * The `<accidental>` element
 *
 * Parent element: `<note>`
 *
 * The `<accidental>` element represents actual notated accidentals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accidental/}
 */
export class Accidental implements XMLElement<'accidental', AccidentalAttributes, AccidentalContents> {
  static readonly schema = {
    name: 'accidental',
    attributes: {
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      cautionary: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      editorial: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'accidental-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'sharp',
              'natural',
              'flat',
              'double-sharp',
              'sharp-sharp',
              'flat-flat',
              'natural-sharp',
              'natural-flat',
              'quarter-flat',
              'quarter-sharp',
              'three-quarters-flat',
              'three-quarters-sharp',
              'sharp-down',
              'sharp-up',
              'natural-down',
              'natural-up',
              'flat-down',
              'flat-up',
              'double-sharp-down',
              'double-sharp-up',
              'flat-flat-down',
              'flat-flat-up',
              'arrow-down',
              'arrow-up',
              'triple-sharp',
              'triple-flat',
              'slash-quarter-sharp',
              'slash-sharp',
              'slash-flat',
              'double-slash-flat',
              'sharp-1',
              'sharp-2',
              'sharp-3',
              'sharp-5',
              'flat-1',
              'flat-2',
              'flat-3',
              'flat-4',
              'sori',
              'koron',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Accidental.schema;

  attributes: AccidentalAttributes;
  contents: AccidentalContents;

  constructor(opts?: { attributes?: Partial<AccidentalAttributes>; contents?: AccidentalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Accidental.schema);
    this.contents = opts?.contents ?? operations.zero(Accidental.schema.contents);
  }
  /** Gets @type {AccidentalAttributes['bracket']}. */
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  /** Sets @type {AccidentalAttributes['bracket']}. */
  setBracket(bracket: 'yes' | 'no' | null): Accidental {
    this.attributes['bracket'] = bracket;
    return this;
  }
  /** Gets @type {AccidentalAttributes['cautionary']}. */
  getCautionary(): 'yes' | 'no' | null {
    return this.attributes['cautionary'];
  }
  /** Sets @type {AccidentalAttributes['cautionary']}. */
  setCautionary(cautionary: 'yes' | 'no' | null): Accidental {
    this.attributes['cautionary'] = cautionary;
    return this;
  }
  /** Gets @type {AccidentalAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {AccidentalAttributes['color']}. */
  setColor(color: string | null): Accidental {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {AccidentalAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {AccidentalAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Accidental {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {AccidentalAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {AccidentalAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Accidental {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {AccidentalAttributes['editorial']}. */
  getEditorial(): 'yes' | 'no' | null {
    return this.attributes['editorial'];
  }
  /** Sets @type {AccidentalAttributes['editorial']}. */
  setEditorial(editorial: 'yes' | 'no' | null): Accidental {
    this.attributes['editorial'] = editorial;
    return this;
  }
  /** Gets @type {AccidentalAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {AccidentalAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Accidental {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {AccidentalAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {AccidentalAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Accidental {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {AccidentalAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {AccidentalAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Accidental {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {AccidentalAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {AccidentalAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Accidental {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {AccidentalAttributes['parentheses']}. */
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  /** Sets @type {AccidentalAttributes['parentheses']}. */
  setParentheses(parentheses: 'yes' | 'no' | null): Accidental {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  /** Gets @type {AccidentalAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {AccidentalAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Accidental {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {AccidentalAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {AccidentalAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Accidental {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {AccidentalAttributes['size']}. */
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  /** Sets @type {AccidentalAttributes['size']}. */
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Accidental {
    this.attributes['size'] = size;
    return this;
  }
  /** Gets @type {AccidentalAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {AccidentalAttributes['smufl']}. */
  setSmufl(smufl: string | null): Accidental {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): this {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type ActualNotesAttributes = Record<string, unknown>;

export type ActualNotesContents = [number];

/**
 * The `<actual-notes>` element
 *
 * Parent element: `<time-modification>`
 *
 * The `<actual-notes>` element describes how many notes are played in the time usually occupied by the number in the
 * `<normal-notes>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/actual-notes/}
 */
export class ActualNotes implements XMLElement<'actual-notes', ActualNotesAttributes, ActualNotesContents> {
  static readonly schema = {
    name: 'actual-notes',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = ActualNotes.schema;

  attributes: ActualNotesAttributes;
  contents: ActualNotesContents;

  constructor(opts?: { attributes?: Partial<ActualNotesAttributes>; contents?: ActualNotesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ActualNotes.schema);
    this.contents = opts?.contents ?? operations.zero(ActualNotes.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type NormalNotesAttributes = Record<string, unknown>;

export type NormalNotesContents = [number];

/**
 * The `<normal-notes>` element
 *
 * Parent element: `<time-modification>`
 *
 * The `<normal-notes>` element describes how many notes are usually played in the time occupied by the number in the
 * `<actual-notes>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/normal-notes/}
 */
export class NormalNotes implements XMLElement<'normal-notes', NormalNotesAttributes, NormalNotesContents> {
  static readonly schema = {
    name: 'normal-notes',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = NormalNotes.schema;

  attributes: NormalNotesAttributes;
  contents: NormalNotesContents;

  constructor(opts?: { attributes?: Partial<NormalNotesAttributes>; contents?: NormalNotesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NormalNotes.schema);
    this.contents = opts?.contents ?? operations.zero(NormalNotes.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type NormalTypeAttributes = Record<string, unknown>;

export type NormalTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima',
];

/**
 * The `<normal-type>` element
 *
 * Parent element: `<time-modification>`
 *
 * If the type associated with the number in the `<normal-notes>` element is different than the current note type
 * (e.g., a quarter note within an eighth note triplet), then the `<normal-notes>` type (e.g. eighth) is specified in
 * the `<normal-type>` and `<normal-dot>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/normal-type/}
 */
export class NormalType implements XMLElement<'normal-type', NormalTypeAttributes, NormalTypeContents> {
  static readonly schema = {
    name: 'normal-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = NormalType.schema;

  attributes: NormalTypeAttributes;
  contents: NormalTypeContents;

  constructor(opts?: { attributes?: Partial<NormalTypeAttributes>; contents?: NormalTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NormalType.schema);
    this.contents = opts?.contents ?? operations.zero(NormalType.schema.contents);
  }

  /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): this {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type NormalDotAttributes = Record<string, unknown>;

export type NormalDotContents = [];

/**
 * The `<normal-dot>` element
 *
 * Parent element: `<time-modification>`
 *
 * The `<normal-dot>` element is used to specify dotted normal tuplet types.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/normal-dot/}
 */
export class NormalDot implements XMLElement<'normal-dot', NormalDotAttributes, NormalDotContents> {
  static readonly schema = { name: 'normal-dot', attributes: {}, contents: [] } as const;

  readonly schema = NormalDot.schema;

  attributes: NormalDotAttributes;
  contents: NormalDotContents;

  constructor(opts?: { attributes?: Partial<NormalDotAttributes>; contents?: NormalDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NormalDot.schema);
    this.contents = opts?.contents ?? operations.zero(NormalDot.schema.contents);
  }
}

export type TimeModificationAttributes = Record<string, unknown>;

export type TimeModificationContents = [ActualNotes, NormalNotes, [NormalType, Array<NormalDot>] | null];

/**
 * The `<time-modification>` element
 *
 * Parent element: `<note>`
 *
 * Time modification indicates tuplets, double-note tremolos, and other durational changes. A `<time-modification>`
 * element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note
 * type represented by the `<type>` and `<dot>` elements. Nested tuplets and other notations that use more detailed
 * information need both the `<time-modification>` and `<tuplet>` elements to be represented accurately.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/time-modification/}
 */
export class TimeModification
  implements XMLElement<'time-modification', TimeModificationAttributes, TimeModificationContents>
{
  static readonly schema = {
    name: 'time-modification',
    attributes: {},
    contents: [
      { type: 'required', value: ActualNotes },
      { type: 'required', value: NormalNotes },
      {
        type: 'label',
        label: 'normal',
        value: {
          type: 'optional',
          value: [
            { type: 'required', value: NormalType },
            { type: 'zeroOrMore', value: NormalDot },
          ],
        },
      },
    ],
  } as const;

  readonly schema = TimeModification.schema;

  attributes: TimeModificationAttributes;
  contents: TimeModificationContents;

  constructor(opts?: { attributes?: Partial<TimeModificationAttributes>; contents?: TimeModificationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TimeModification.schema);
    this.contents = opts?.contents ?? operations.zero(TimeModification.schema.contents);
  }

  /** Gets @type {ActualNotes}. */
  getActualNotes(): ActualNotes {
    return this.contents[0];
  }
  /** Sets @type {ActualNotes}. */
  setActualNotes(actualNotes: ActualNotes): this {
    this.contents[0] = actualNotes;
    return this;
  }
  /** Gets @type {NormalNotes}. */
  getNormalNotes(): NormalNotes {
    return this.contents[1];
  }
  /** Sets @type {NormalNotes}. */
  setNormalNotes(normalNotes: NormalNotes): this {
    this.contents[1] = normalNotes;
    return this;
  }
  /** Gets @type {[NormalType, Array<NormalDot>] | null}. */
  getNormal(): [NormalType, Array<NormalDot>] | null {
    return this.contents[2];
  }
  /** Sets @type {[NormalType, Array<NormalDot>] | null}. */
  setNormal(normal: [NormalType, Array<NormalDot>] | null): this {
    this.contents[2] = normal;
    return this;
  }
}

export type StemAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type StemContents = ['none' | 'down' | 'up' | 'double'];

/**
 * The `<stem>` element
 *
 * Parent element: `<note>`
 *
 * Values for the `<stem>` element can be down, up, none, or double. A `<stem>` element associated with a `<rest>`
 * refers to a stemlet.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stem/}
 */
export class Stem implements XMLElement<'stem', StemAttributes, StemContents> {
  static readonly schema = {
    name: 'stem',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      { type: 'label', label: 'stem-value', value: { type: 'choices', choices: ['none', 'down', 'up', 'double'] } },
    ],
  } as const;

  readonly schema = Stem.schema;

  attributes: StemAttributes;
  contents: StemContents;

  constructor(opts?: { attributes?: Partial<StemAttributes>; contents?: StemContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stem.schema);
    this.contents = opts?.contents ?? operations.zero(Stem.schema.contents);
  }
  /** Gets @type {StemAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StemAttributes['color']}. */
  setColor(color: string | null): Stem {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StemAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StemAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Stem {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StemAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StemAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Stem {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StemAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StemAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Stem {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StemAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StemAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Stem {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {'none' | 'down' | 'up' | 'double'}. */
  getStemValue(): 'none' | 'down' | 'up' | 'double' {
    return this.contents[0];
  }
  /** Sets @type {'none' | 'down' | 'up' | 'double'}. */
  setStemValue(stemValue: 'none' | 'down' | 'up' | 'double'): this {
    this.contents[0] = stemValue;
    return this;
  }
}

export type NoteheadAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the appearance of enclosed shapes from the default of hollow for half notes and longer, and filled
   * otherwise.
   */
  filled: 'yes' | 'no' | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * If yes, the notehead is parenthesized. It is no if not specified.
   */
  parentheses: 'yes' | 'no' | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type NoteheadContents = [
  | 'other'
  | 'arrow down'
  | 'arrow up'
  | 'back slashed'
  | 'circle dot'
  | 'circle-x'
  | 'circled'
  | 'cluster'
  | 'cross'
  | 'diamond'
  | 'do'
  | 'fa'
  | 'fa up'
  | 'inverted triangle'
  | 'la'
  | 'left triangle'
  | 'mi'
  | 'none'
  | 'normal'
  | 're'
  | 'rectangle'
  | 'slash'
  | 'slashed'
  | 'so'
  | 'square'
  | 'ti'
  | 'triangle'
  | 'x',
];

/**
 * The `<notehead>` element
 *
 * Parent element: `<note>`
 *
 * The `<notehead>` element indicates shapes other than the open and closed ovals associated with note durations.
 *
 * The smufl attribute can be used to specify a particular notehead, allowing application interoperability without
 * requiring every Standard Music Font Layout (SMuFL) glyph to have a MusicXML element equivalent. This attribute can be
 * used either with the other value, or to refine a specific notehead value such as cluster.
 *
 * Noteheads in the SMuFL Note name noteheads and Note name noteheads supplement ranges
 * (U+E150–U+E1AF and U+EEE0–U+EEFF) should not use the smufl attribute or the other value, but instead use the
 * `<notehead-text>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/notehead/}
 */
export class Notehead implements XMLElement<'notehead', NoteheadAttributes, NoteheadContents> {
  static readonly schema = {
    name: 'notehead',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      filled: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'notehead-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'arrow down',
              'arrow up',
              'back slashed',
              'circle dot',
              'circle-x',
              'circled',
              'cluster',
              'cross',
              'diamond',
              'do',
              'fa',
              'fa up',
              'inverted triangle',
              'la',
              'left triangle',
              'mi',
              'none',
              'normal',
              're',
              'rectangle',
              'slash',
              'slashed',
              'so',
              'square',
              'ti',
              'triangle',
              'x',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Notehead.schema;

  attributes: NoteheadAttributes;
  contents: NoteheadContents;

  constructor(opts?: { attributes?: Partial<NoteheadAttributes>; contents?: NoteheadContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Notehead.schema);
    this.contents = opts?.contents ?? operations.zero(Notehead.schema.contents);
  }
  /** Gets @type {NoteheadAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {NoteheadAttributes['color']}. */
  setColor(color: string | null): Notehead {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {NoteheadAttributes['filled']}. */
  getFilled(): 'yes' | 'no' | null {
    return this.attributes['filled'];
  }
  /** Sets @type {NoteheadAttributes['filled']}. */
  setFilled(filled: 'yes' | 'no' | null): Notehead {
    this.attributes['filled'] = filled;
    return this;
  }
  /** Gets @type {NoteheadAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {NoteheadAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Notehead {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {NoteheadAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {NoteheadAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Notehead {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {NoteheadAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {NoteheadAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Notehead {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {NoteheadAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {NoteheadAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Notehead {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {NoteheadAttributes['parentheses']}. */
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  /** Sets @type {NoteheadAttributes['parentheses']}. */
  setParentheses(parentheses: 'yes' | 'no' | null): Notehead {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  /** Gets @type {NoteheadAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {NoteheadAttributes['smufl']}. */
  setSmufl(smufl: string | null): Notehead {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'other' | 'arrow down' | 'arrow up' | 'back slashed' | 'circle dot' | 'circle-x' | 'circled' | 'cluster' | 'cross' | 'diamond' | 'do' | 'fa' | 'fa up' | 'inverted triangle' | 'la' | 'left triangle' | 'mi' | 'none' | 'normal' | 're' | 'rectangle' | 'slash' | 'slashed' | 'so' | 'square' | 'ti' | 'triangle' | 'x'}. */
  getNoteheadValue():
    | 'other'
    | 'arrow down'
    | 'arrow up'
    | 'back slashed'
    | 'circle dot'
    | 'circle-x'
    | 'circled'
    | 'cluster'
    | 'cross'
    | 'diamond'
    | 'do'
    | 'fa'
    | 'fa up'
    | 'inverted triangle'
    | 'la'
    | 'left triangle'
    | 'mi'
    | 'none'
    | 'normal'
    | 're'
    | 'rectangle'
    | 'slash'
    | 'slashed'
    | 'so'
    | 'square'
    | 'ti'
    | 'triangle'
    | 'x' {
    return this.contents[0];
  }
  /** Sets @type {'other' | 'arrow down' | 'arrow up' | 'back slashed' | 'circle dot' | 'circle-x' | 'circled' | 'cluster' | 'cross' | 'diamond' | 'do' | 'fa' | 'fa up' | 'inverted triangle' | 'la' | 'left triangle' | 'mi' | 'none' | 'normal' | 're' | 'rectangle' | 'slash' | 'slashed' | 'so' | 'square' | 'ti' | 'triangle' | 'x'}. */
  setNoteheadValue(
    noteheadValue:
      | 'other'
      | 'arrow down'
      | 'arrow up'
      | 'back slashed'
      | 'circle dot'
      | 'circle-x'
      | 'circled'
      | 'cluster'
      | 'cross'
      | 'diamond'
      | 'do'
      | 'fa'
      | 'fa up'
      | 'inverted triangle'
      | 'la'
      | 'left triangle'
      | 'mi'
      | 'none'
      | 'normal'
      | 're'
      | 'rectangle'
      | 'slash'
      | 'slashed'
      | 'so'
      | 'square'
      | 'ti'
      | 'triangle'
      | 'x'
  ): this {
    this.contents[0] = noteheadValue;
    return this;
  }
}

export type NoteheadTextAttributes = Record<string, unknown>;

export type NoteheadTextContents = [Array<[DisplayText, AccidentalText]>];

/**
 * The `<notehead-text>` element
 *
 * Parent element: `<note>`
 *
 * The `<notehead-text>` element represents text that is displayed inside a notehead, as is done in some educational
 * music. It is not needed for the numbers used in tablature or jianpu notation. The presence of a TAB or jianpu clefs\
 * is sufficient to indicate that numbers are used. The `<display-text>` and `<accidental-text>` elements allow display
 * of fully formatted text and accidentals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/notehead-text/}
 */
export class NoteheadText implements XMLElement<'notehead-text', NoteheadTextAttributes, NoteheadTextContents> {
  static readonly schema = {
    name: 'notehead-text',
    attributes: {},
    contents: [{ type: 'label', label: 'texts', value: { type: 'oneOrMore', value: [DisplayText, AccidentalText] } }],
  } as const;

  readonly schema = NoteheadText.schema;

  attributes: NoteheadTextAttributes;
  contents: NoteheadTextContents;

  constructor(opts?: { attributes?: Partial<NoteheadTextAttributes>; contents?: NoteheadTextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NoteheadText.schema);
    this.contents = opts?.contents ?? operations.zero(NoteheadText.schema.contents);
  }

  /** Gets @type {Array<[DisplayText, AccidentalText]>}. */
  getTexts(): Array<[DisplayText, AccidentalText]> {
    return this.contents[0];
  }
  /** Sets @type {Array<[DisplayText, AccidentalText]>}. */
  setTexts(texts: Array<[DisplayText, AccidentalText]>): this {
    this.contents[0] = texts;
    return this;
  }
}

export type StaffAttributes = Record<string, unknown>;

export type StaffContents = [number];

/**
 * The `<staff>` element
 *
 * Parent elements: `<direction>`, `<forward>`, `<harmony>`, `<note>`
 *
 * Staff assignment is only needed for music notated on multiple staves. Staff values are numbers, with 1 referring to
 * the top-most staff in a part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff/}
 */
export class Staff implements XMLElement<'staff', StaffAttributes, StaffContents> {
  static readonly schema = {
    name: 'staff',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
    ],
  } as const;

  readonly schema = Staff.schema;

  attributes: StaffAttributes;
  contents: StaffContents;

  constructor(opts?: { attributes?: Partial<StaffAttributes>; contents?: StaffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staff.schema);
    this.contents = opts?.contents ?? operations.zero(Staff.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type BeamAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Beams that have a begin value may also have a fan attribute to indicate accelerandos and ritardandos using
   * fanned beams. The fan attribute may also be used with a continue value if the fanning direction changes on that
   * note. The value is none if not specified.
   */
  fan: 'accel' | 'none' | 'rit' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates eighth note through 1024th note beams using number values 1 thru 8 respectively. The default value
   * is 1.
   *
   * Note that this attribute does not distinguish sets of beams that overlap, as it does for <slur> and other
   * elements. Beaming groups are distinguished by being in different voices, and/or the presence or absence of
   * <grace> and <cue> elements.
   */
  number: number | null;
  /**
   * Deprecated as of Version 3.0. Formerly used for tremolos, it needs to be specified with a "yes" value for each
   * `<beam>` using it.
   */
  repeater: 'yes' | 'no' | null;
};

export type BeamContents = ['backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'];

/**
 * The `<beam>` element
 *
 * Parent element: `<note>`
 *
 * Beam values include begin, continue, end, forward hook, and backward hook. Each beam in a note is represented with a
 * separate `<beam>` element with a different number attribute, starting with the eighth note beam using a value of 1.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beam/}
 */
export class Beam implements XMLElement<'beam', BeamAttributes, BeamContents> {
  static readonly schema = {
    name: 'beam',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      fan: { type: 'optional', value: { type: 'choices', choices: ['accel', 'none', 'rit'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 8 } },
      repeater: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'beam-value',
          value: { type: 'choices', choices: ['backward hook', 'begin', 'continue', 'end', 'forward hook'] },
        },
      },
    ],
  } as const;

  readonly schema = Beam.schema;

  attributes: BeamAttributes;
  contents: BeamContents;

  constructor(opts?: { attributes?: Partial<BeamAttributes>; contents?: BeamContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Beam.schema);
    this.contents = opts?.contents ?? operations.zero(Beam.schema.contents);
  }
  /** Gets @type {BeamAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BeamAttributes['color']}. */
  setColor(color: string | null): Beam {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BeamAttributes['fan']}. */
  getFan(): 'accel' | 'none' | 'rit' | null {
    return this.attributes['fan'];
  }
  /** Sets @type {BeamAttributes['fan']}. */
  setFan(fan: 'accel' | 'none' | 'rit' | null): Beam {
    this.attributes['fan'] = fan;
    return this;
  }
  /** Gets @type {BeamAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {BeamAttributes['id']}. */
  setId(id: string | null): Beam {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {BeamAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {BeamAttributes['number']}. */
  setNumber(number: number | null): Beam {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {BeamAttributes['repeater']}. */
  getRepeater(): 'yes' | 'no' | null {
    return this.attributes['repeater'];
  }
  /** Sets @type {BeamAttributes['repeater']}. */
  setRepeater(repeater: 'yes' | 'no' | null): Beam {
    this.attributes['repeater'] = repeater;
    return this;
  }
  /** Gets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
  getBeamValue(): 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook' {
    return this.contents[0];
  }
  /** Sets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
  setBeamValue(beamValue: 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'): this {
    this.contents[0] = beamValue;
    return this;
  }
}

export type TiedAttributes = {
  /**
   * Indicates if this is the start, stop, or continuation of a tie, or if this is a tie indicating that an
   * instrument should be undamped.
   */
  type: 'start' | 'stop' | 'continue' | 'let-ring';
  /**
   * The horizontal position of an outgoing bezier point for slurs and ties with a start type, or of an incoming
   * bezier point for slurs and ties with types of stop or continue.
   */
  'bezier-x': number | null;
  /**
   * The horizontal position of an outgoing bezier point for slurs with a continue type. Not valid for other types.
   */
  'bezier-x2': number | null;
  /**
   * The vertical position of an outgoing bezier point for slurs and ties with a start type, or of an incoming
   * bezier point for slurs and ties with types of stop or continue.
   */
  'bezier-y': number | null;
  /**
   * The vertical position of an outgoing bezier point for slurs with a continue type. Not valid for other types.
   */
  'bezier-y2': number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Rarely needed to disambiguate ties, since note pitches will usually suffice. It is available for use in more
   * complex tied notation situations.
   */
  number: number | null;
  /**
   * Indicates whether slurs and ties are overhand (tips down) or underhand (tips up). This is distinct from the
   * placement attribute used by any notation type.
   */
  orientation: 'over' | 'under' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type TiedContents = [];

/**
 * The `<tied>` element
 *
 * Parent element: `<notations>`
 *
 * The `<tied>` element represents the notated tie. The `<tie>` element represents the tie sound.
 *
 * Ties that join two notes of the same pitch together should be represented with a `<tied>` element on the first note
 * with type="start" and a `<tied>` element on the second note with type="stop". This can also be done if the two notes
 * being tied are enharmonically equivalent, but have different step values. It is not recommended to use `<tied>`
 * elements to join two notes with enharmonically inequivalent pitches.
 *
 * Ties that indicate that an instrument should be undamped are specified with a single `<tied>`
 * element with type="let-ring".
 *
 * Ties that are visually attached to only one note, other than undamped ties, should be specified with two `<tied>`
 * elements on the same note, first type="start" then type="stop". This can be used to represent ties into or out of
 * repeated sections or codas.
 *
 * When multiple `<tied>` elements with the same tag are used within the same note, their order within the MusicXML
 * document should match the musical score order. For example, a note with a tie at the end of a first ending should
 * have the `<tied>` element with a type of start precede the `<tied>` element with a type of stop.
 *
 * Normal ties need only two bezier points: one associated with the start of the tie, the other with the stop. Ties
 * divided over system breaks can specify additional bezier data at `<tied>` elements with a continue type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tied/}
 */
export class Tied implements XMLElement<'tied', TiedAttributes, TiedContents> {
  static readonly schema = {
    name: 'tied',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue', 'let-ring'] } },
      'bezier-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-x2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      orientation: { type: 'optional', value: { type: 'choices', choices: ['over', 'under'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Tied.schema;

  attributes: TiedAttributes;
  contents: TiedContents;

  constructor(opts?: { attributes?: Partial<TiedAttributes>; contents?: TiedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tied.schema);
    this.contents = opts?.contents ?? operations.zero(Tied.schema.contents);
  }
  /** Gets @type {TiedAttributes['type']}. */
  getType(): 'start' | 'stop' | 'continue' | 'let-ring' {
    return this.attributes['type'];
  }
  /** Sets @type {TiedAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'continue' | 'let-ring'): Tied {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {TiedAttributes['bezier-x']}. */
  getBezierX(): number | null {
    return this.attributes['bezier-x'];
  }
  /** Sets @type {TiedAttributes['bezier-x']}. */
  setBezierX(bezierX: number | null): Tied {
    this.attributes['bezier-x'] = bezierX;
    return this;
  }
  /** Gets @type {TiedAttributes['bezier-x2']}. */
  getBezierX2(): number | null {
    return this.attributes['bezier-x2'];
  }
  /** Sets @type {TiedAttributes['bezier-x2']}. */
  setBezierX2(bezierX2: number | null): Tied {
    this.attributes['bezier-x2'] = bezierX2;
    return this;
  }
  /** Gets @type {TiedAttributes['bezier-y']}. */
  getBezierY(): number | null {
    return this.attributes['bezier-y'];
  }
  /** Sets @type {TiedAttributes['bezier-y']}. */
  setBezierY(bezierY: number | null): Tied {
    this.attributes['bezier-y'] = bezierY;
    return this;
  }
  /** Gets @type {TiedAttributes['bezier-y2']}. */
  getBezierY2(): number | null {
    return this.attributes['bezier-y2'];
  }
  /** Sets @type {TiedAttributes['bezier-y2']}. */
  setBezierY2(bezierY2: number | null): Tied {
    this.attributes['bezier-y2'] = bezierY2;
    return this;
  }
  /** Gets @type {TiedAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TiedAttributes['color']}. */
  setColor(color: string | null): Tied {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TiedAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {TiedAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Tied {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {TiedAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TiedAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Tied {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TiedAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TiedAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Tied {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TiedAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {TiedAttributes['id']}. */
  setId(id: string | null): Tied {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {TiedAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {TiedAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Tied {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {TiedAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {TiedAttributes['number']}. */
  setNumber(number: number | null): Tied {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {TiedAttributes['orientation']}. */
  getOrientation(): 'over' | 'under' | null {
    return this.attributes['orientation'];
  }
  /** Sets @type {TiedAttributes['orientation']}. */
  setOrientation(orientation: 'over' | 'under' | null): Tied {
    this.attributes['orientation'] = orientation;
    return this;
  }
  /** Gets @type {TiedAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TiedAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Tied {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TiedAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TiedAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Tied {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TiedAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TiedAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Tied {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {TiedAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {TiedAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Tied {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type SlurAttributes = {
  /**
   * Indicates if this is the start, stop, or continuation of the slur.
   */
  type: 'start' | 'stop' | 'continue';
  /**
   * The horizontal position of an outgoing bezier point for slurs and ties with a start type, or of an incoming
   * bezier point for slurs and ties with types of stop or continue.
   */
  'bezier-x': number | null;
  /**
   * The horizontal position of an outgoing bezier point for slurs with a continue type. Not valid for other types.
   */
  'bezier-x2': number | null;
  /**
   * The vertical position of an outgoing bezier point for slurs and ties with a start type, or of an incoming
   * bezier point for slurs and ties with types of stop or continue.
   */
  'bezier-y': number | null;
  /**
   * The vertical position of an outgoing bezier point for slurs with a continue type. Not valid for other types.
   */
  'bezier-y2': number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Rarely needed to disambiguate ties, since note pitches will usually suffice. It is available for use in more
   * complex tied notation situations.
   */
  number: number | null;
  /**
   * Indicates whether slurs and ties are overhand (tips down) or underhand (tips up). This is distinct from the
   * placement attribute used by any notation type.
   */
  orientation: 'over' | 'under' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type SlurContents = [];

/**
 * The `<slur>` element
 *
 * Parent element: `<notations>`
 *
 * Most slurs are represented with two `<slur>` elements: one with a start type, and one with a stop type. Slurs can add
 * more elements using a continue type. This is typically used to specify the formatting of cross-system slurs, or to
 * specify the shape of very complex slurs.
 *
 * Normal slurs and S-shaped slurs need only two bezier points: one associated with the start of the slur, the other
 * with the stop. Complex slurs and slurs divided over system breaks can specify additional bezier data at `<slur>`
 * elements with a continue type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slur/}
 */
export class Slur implements XMLElement<'slur', SlurAttributes, SlurContents> {
  static readonly schema = {
    name: 'slur',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      'bezier-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-x2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'bezier-y2': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      orientation: { type: 'optional', value: { type: 'choices', choices: ['over', 'under'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Slur.schema;

  attributes: SlurAttributes;
  contents: SlurContents;

  constructor(opts?: { attributes?: Partial<SlurAttributes>; contents?: SlurContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Slur.schema);
    this.contents = opts?.contents ?? operations.zero(Slur.schema.contents);
  }
  /** Gets @type {SlurAttributes['type']}. */
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  /** Sets @type {SlurAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'continue'): Slur {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {SlurAttributes['bezier-x']}. */
  getBezierX(): number | null {
    return this.attributes['bezier-x'];
  }
  /** Sets @type {SlurAttributes['bezier-x']}. */
  setBezierX(bezierX: number | null): Slur {
    this.attributes['bezier-x'] = bezierX;
    return this;
  }
  /** Gets @type {SlurAttributes['bezier-x2']}. */
  getBezierX2(): number | null {
    return this.attributes['bezier-x2'];
  }
  /** Sets @type {SlurAttributes['bezier-x2']}. */
  setBezierX2(bezierX2: number | null): Slur {
    this.attributes['bezier-x2'] = bezierX2;
    return this;
  }
  /** Gets @type {SlurAttributes['bezier-y']}. */
  getBezierY(): number | null {
    return this.attributes['bezier-y'];
  }
  /** Sets @type {SlurAttributes['bezier-y']}. */
  setBezierY(bezierY: number | null): Slur {
    this.attributes['bezier-y'] = bezierY;
    return this;
  }
  /** Gets @type {SlurAttributes['bezier-y2']}. */
  getBezierY2(): number | null {
    return this.attributes['bezier-y2'];
  }
  /** Sets @type {SlurAttributes['bezier-y2']}. */
  setBezierY2(bezierY2: number | null): Slur {
    this.attributes['bezier-y2'] = bezierY2;
    return this;
  }
  /** Gets @type {SlurAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SlurAttributes['color']}. */
  setColor(color: string | null): Slur {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SlurAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {SlurAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Slur {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {SlurAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SlurAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Slur {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SlurAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SlurAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Slur {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SlurAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {SlurAttributes['id']}. */
  setId(id: string | null): Slur {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {SlurAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {SlurAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Slur {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {SlurAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {SlurAttributes['number']}. */
  setNumber(number: number | null): Slur {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {SlurAttributes['orientation']}. */
  getOrientation(): 'over' | 'under' | null {
    return this.attributes['orientation'];
  }
  /** Sets @type {SlurAttributes['orientation']}. */
  setOrientation(orientation: 'over' | 'under' | null): Slur {
    this.attributes['orientation'] = orientation;
    return this;
  }
  /** Gets @type {SlurAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {SlurAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Slur {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {SlurAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SlurAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Slur {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SlurAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SlurAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Slur {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {SlurAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {SlurAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Slur {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type TupletNumberAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
};

export type TupletNumberContents = [number];

/**
 * The `<tuplet-number>` element
 *
 * Parent elements: `<tuplet-actual>`, `<tuplet-normal>`
 *
 * The `<tuplet-number>` element indicates the number of notes for this portion of the tuplet.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-number/}
 */
export class TupletNumber implements XMLElement<'tuplet-number', TupletNumberAttributes, TupletNumberContents> {
  static readonly schema = {
    name: 'tuplet-number',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = TupletNumber.schema;

  attributes: TupletNumberAttributes;
  contents: TupletNumberContents;

  constructor(opts?: { attributes?: Partial<TupletNumberAttributes>; contents?: TupletNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletNumber.schema);
    this.contents = opts?.contents ?? operations.zero(TupletNumber.schema.contents);
  }
  /** Gets @type {TupletNumberAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TupletNumberAttributes['color']}. */
  setColor(color: string | null): TupletNumber {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TupletNumberAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TupletNumberAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): TupletNumber {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TupletNumberAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TupletNumberAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TupletNumber {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TupletNumberAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TupletNumberAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TupletNumber {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TupletNumberAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TupletNumberAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TupletNumber {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type TupletTypeAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
};

export type TupletTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima',
];

/**
 * The `<tuplet-type>` element
 *
 * Parent elements: `<tuplet-actual>`, `<tuplet-normal>`
 *
 * The `<tuplet-type>` element indicates the graphical note type of the notes for this portion of the tuplet.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-type/}
 */
export class TupletType implements XMLElement<'tuplet-type', TupletTypeAttributes, TupletTypeContents> {
  static readonly schema = {
    name: 'tuplet-type',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'note-type-value',
        value: {
          type: 'choices',
          choices: [
            'whole',
            '1024th',
            '512th',
            '256th',
            '128th',
            '64th',
            '32nd',
            '16th',
            'eighth',
            'half',
            'quarter',
            'whole',
            'breve',
            'long',
            'maxima',
          ],
        },
      },
    ],
  } as const;

  readonly schema = TupletType.schema;

  attributes: TupletTypeAttributes;
  contents: TupletTypeContents;

  constructor(opts?: { attributes?: Partial<TupletTypeAttributes>; contents?: TupletTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletType.schema);
    this.contents = opts?.contents ?? operations.zero(TupletType.schema.contents);
  }
  /** Gets @type {TupletTypeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TupletTypeAttributes['color']}. */
  setColor(color: string | null): TupletType {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TupletTypeAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TupletTypeAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): TupletType {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TupletTypeAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TupletTypeAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TupletType {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TupletTypeAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TupletTypeAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TupletType {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TupletTypeAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TupletTypeAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TupletType {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): this {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type TupletDotAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
};

export type TupletDotContents = [];

/**
 * The `<tuplet-dot>` element
 *
 * Parent elements: `<tuplet-actual>`, `<tuplet-normal>`
 *
 * The `<tuplet-dot>` element is used to specify dotted tuplet types.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-dot/}
 */
export class TupletDot implements XMLElement<'tuplet-dot', TupletDotAttributes, TupletDotContents> {
  static readonly schema = {
    name: 'tuplet-dot',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [],
  } as const;

  readonly schema = TupletDot.schema;

  attributes: TupletDotAttributes;
  contents: TupletDotContents;

  constructor(opts?: { attributes?: Partial<TupletDotAttributes>; contents?: TupletDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletDot.schema);
    this.contents = opts?.contents ?? operations.zero(TupletDot.schema.contents);
  }
  /** Gets @type {TupletDotAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TupletDotAttributes['color']}. */
  setColor(color: string | null): TupletDot {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TupletDotAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TupletDotAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): TupletDot {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TupletDotAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TupletDotAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TupletDot {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TupletDotAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TupletDotAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TupletDot {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TupletDotAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TupletDotAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TupletDot {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
}

export type TupletActualAttributes = Record<string, unknown>;

export type TupletActualContents = [TupletNumber | null, TupletType | null, Array<TupletDot>];

/**
 * The `<tuplet-actual>` element
 *
 * Parent element: `<tuplet>`
 *
 * The `<tuplet-actual>` element provide optional full control over how the actual part of the `<tuplet>` is displayed,
 * including number and note type (with dots). If any of these elements are absent, their values are based on the
 * `<time-modification>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-actual/}
 */
export class TupletActual implements XMLElement<'tuplet-actual', TupletActualAttributes, TupletActualContents> {
  static readonly schema = {
    name: 'tuplet-actual',
    attributes: {},
    contents: [
      { type: 'optional', value: TupletNumber },
      { type: 'optional', value: TupletType },
      { type: 'label', label: 'tuplet-dots', value: { type: 'zeroOrMore', value: TupletDot } },
    ],
  } as const;

  readonly schema = TupletActual.schema;

  attributes: TupletActualAttributes;
  contents: TupletActualContents;

  constructor(opts?: { attributes?: Partial<TupletActualAttributes>; contents?: TupletActualContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletActual.schema);
    this.contents = opts?.contents ?? operations.zero(TupletActual.schema.contents);
  }

  /** Gets @type {TupletNumber | null}. */
  getTupletNumber(): TupletNumber | null {
    return this.contents[0];
  }
  /** Sets @type {TupletNumber | null}. */
  setTupletNumber(tupletNumber: TupletNumber | null): this {
    this.contents[0] = tupletNumber;
    return this;
  }
  /** Gets @type {TupletType | null}. */
  getTupletType(): TupletType | null {
    return this.contents[1];
  }
  /** Sets @type {TupletType | null}. */
  setTupletType(tupletType: TupletType | null): this {
    this.contents[1] = tupletType;
    return this;
  }
  /** Gets @type {Array<TupletDot>}. */
  getTupletDots(): Array<TupletDot> {
    return this.contents[2];
  }
  /** Sets @type {Array<TupletDot>}. */
  setTupletDots(tupletDots: Array<TupletDot>): this {
    this.contents[2] = tupletDots;
    return this;
  }
}

export type TupletNormalAttributes = Record<string, unknown>;

export type TupletNormalContents = [TupletNumber | null, TupletType | null, Array<TupletDot>];

/**
 * The `<tuplet-normal>` element
 *
 * Parent element: `<tuplet>`
 *
 * The `<tuplet-normal>` element provide optional full control over how the normal part of the `<tuplet>` is displayed,
 * including number and note type (with dots). If any of these elements are absent, their values are based on the
 * `<time-modification>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet-normal/}
 */
export class TupletNormal implements XMLElement<'tuplet-normal', TupletNormalAttributes, TupletNormalContents> {
  static readonly schema = {
    name: 'tuplet-normal',
    attributes: {},
    contents: [
      { type: 'optional', value: TupletNumber },
      { type: 'optional', value: TupletType },
      { type: 'label', label: 'tuplet-dots', value: { type: 'zeroOrMore', value: TupletDot } },
    ],
  } as const;

  readonly schema = TupletNormal.schema;

  attributes: TupletNormalAttributes;
  contents: TupletNormalContents;

  constructor(opts?: { attributes?: Partial<TupletNormalAttributes>; contents?: TupletNormalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TupletNormal.schema);
    this.contents = opts?.contents ?? operations.zero(TupletNormal.schema.contents);
  }

  /** Gets @type {TupletNumber | null}. */
  getTupletNumber(): TupletNumber | null {
    return this.contents[0];
  }
  /** Sets @type {TupletNumber | null}. */
  setTupletNumber(tupletNumber: TupletNumber | null): this {
    this.contents[0] = tupletNumber;
    return this;
  }
  /** Gets @type {TupletType | null}. */
  getTupletType(): TupletType | null {
    return this.contents[1];
  }
  /** Sets @type {TupletType | null}. */
  setTupletType(tupletType: TupletType | null): this {
    this.contents[1] = tupletType;
    return this;
  }
  /** Gets @type {Array<TupletDot>}. */
  getTupletDots(): Array<TupletDot> {
    return this.contents[2];
  }
  /** Sets @type {Array<TupletDot>}. */
  setTupletDots(tupletDots: Array<TupletDot>): this {
    this.contents[2] = tupletDots;
    return this;
  }
}

export type TupletAttributes = {
  /**
   * Indicates if this is the start or stop of the tuplet.
   */
  type: 'start' | 'stop' | null;
  /**
   * Indicates the presence of a bracket. If unspecified, the result is implementation-dependent.
   */
  bracket: 'yes' | 'no' | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Used to specify whether the bracket is straight or in the older curved or slurred style. It is straight if not
   * specified.
   */
  'line-shape': 'straight' | 'curved' | null;
  /**
   * Distinguishes nested tuplets.
   */
  number: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to display either the number of actual notes, the number of both actual and normal notes, or neither. It
   * is actual if not specified.
   */
  'show-number': 'none' | 'actual' | 'both' | null;
  /**
   * Used to display either the actual type, both the actual and normal types, or neither. It is none if not
   * specified.
   */
  'show-type': 'none' | 'actual' | 'both' | null;
};

export type TupletContents = [TupletActual | null, TupletNormal | null];

/**
 * The `<tuplet>` element
 *
 * Parent element: `<notations>`
 *
 * A `<tuplet>` element is present when a tuplet is to be displayed graphically, in addition to the sound data provided
 * by the `<time-modification>` elements.
 *
 * Whereas a `<time-modification>` element shows how the cumulative, sounding effect of tuplets and double-note tremolos
 * compare to the written note type, the `<tuplet>` element describes how this is displayed. The `<tuplet>` element also
 * provides more detailed representation information than the `<time-modification>` element, and is needed to represent
 * nested tuplets and other complex tuplets accurately.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuplet/}
 */
export class Tuplet implements XMLElement<'tuplet', TupletAttributes, TupletContents> {
  static readonly schema = {
    name: 'tuplet',
    attributes: {
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop'] } },
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'show-number': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
      'show-type': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
    },
    contents: [
      { type: 'optional', value: TupletActual },
      { type: 'optional', value: TupletNormal },
    ],
  } as const;

  readonly schema = Tuplet.schema;

  attributes: TupletAttributes;
  contents: TupletContents;

  constructor(opts?: { attributes?: Partial<TupletAttributes>; contents?: TupletContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tuplet.schema);
    this.contents = opts?.contents ?? operations.zero(Tuplet.schema.contents);
  }
  /** Gets @type {TupletAttributes['type']}. */
  getType(): 'start' | 'stop' | null {
    return this.attributes['type'];
  }
  /** Sets @type {TupletAttributes['type']}. */
  setType(type: 'start' | 'stop' | null): Tuplet {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {TupletAttributes['bracket']}. */
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  /** Sets @type {TupletAttributes['bracket']}. */
  setBracket(bracket: 'yes' | 'no' | null): Tuplet {
    this.attributes['bracket'] = bracket;
    return this;
  }
  /** Gets @type {TupletAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TupletAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Tuplet {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TupletAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TupletAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Tuplet {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TupletAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {TupletAttributes['id']}. */
  setId(id: string | null): Tuplet {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {TupletAttributes['line-shape']}. */
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  /** Sets @type {TupletAttributes['line-shape']}. */
  setLineShape(lineShape: 'straight' | 'curved' | null): Tuplet {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  /** Gets @type {TupletAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {TupletAttributes['number']}. */
  setNumber(number: number | null): Tuplet {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {TupletAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TupletAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Tuplet {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TupletAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TupletAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Tuplet {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TupletAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TupletAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Tuplet {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {TupletAttributes['show-number']}. */
  getShowNumber(): 'none' | 'actual' | 'both' | null {
    return this.attributes['show-number'];
  }
  /** Sets @type {TupletAttributes['show-number']}. */
  setShowNumber(showNumber: 'none' | 'actual' | 'both' | null): Tuplet {
    this.attributes['show-number'] = showNumber;
    return this;
  }
  /** Gets @type {TupletAttributes['show-type']}. */
  getShowType(): 'none' | 'actual' | 'both' | null {
    return this.attributes['show-type'];
  }
  /** Sets @type {TupletAttributes['show-type']}. */
  setShowType(showType: 'none' | 'actual' | 'both' | null): Tuplet {
    this.attributes['show-type'] = showType;
    return this;
  }
  /** Gets @type {TupletActual | null}. */
  getTupletActual(): TupletActual | null {
    return this.contents[0];
  }
  /** Sets @type {TupletActual | null}. */
  setTupletActual(tupletActual: TupletActual | null): this {
    this.contents[0] = tupletActual;
    return this;
  }
  /** Gets @type {TupletNormal | null}. */
  getTupletNormal(): TupletNormal | null {
    return this.contents[1];
  }
  /** Sets @type {TupletNormal | null}. */
  setTupletNormal(tupletNormal: TupletNormal | null): this {
    this.contents[1] = tupletNormal;
    return this;
  }
}

export type GlissandoAttributes = {
  /**
   * Indicates if this is the start or stop of the glissando.
   */
  type: 'start' | 'stop';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Distinguishes multiple glissandos when they overlap in MusicXML document order. The default value is 1.
   */
  number: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type GlissandoContents = [string];

/**
 * The `<glissando>` element
 *
 * Parent element: `<notations>`
 *
 * The `<glissando>` and `<slide>` elements both indicate rapidly moving from one pitch to the other so that individual
 * notes are not discerned. A `<glissando>` sounds the distinct notes in between the two pitches and defaults to a wavy
 * line. The optional text is printed alongside the line.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/glissando/}
 */
export class Glissando implements XMLElement<'glissando', GlissandoAttributes, GlissandoContents> {
  static readonly schema = {
    name: 'glissando',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Glissando.schema;

  attributes: GlissandoAttributes;
  contents: GlissandoContents;

  constructor(opts?: { attributes?: Partial<GlissandoAttributes>; contents?: GlissandoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Glissando.schema);
    this.contents = opts?.contents ?? operations.zero(Glissando.schema.contents);
  }
  /** Gets @type {GlissandoAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {GlissandoAttributes['type']}. */
  setType(type: 'start' | 'stop'): Glissando {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {GlissandoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {GlissandoAttributes['color']}. */
  setColor(color: string | null): Glissando {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {GlissandoAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {GlissandoAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Glissando {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {GlissandoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {GlissandoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Glissando {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {GlissandoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {GlissandoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Glissando {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {GlissandoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {GlissandoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Glissando {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {GlissandoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {GlissandoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Glissando {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {GlissandoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {GlissandoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Glissando {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {GlissandoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {GlissandoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Glissando {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {GlissandoAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {GlissandoAttributes['id']}. */
  setId(id: string | null): Glissando {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {GlissandoAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {GlissandoAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Glissando {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {GlissandoAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {GlissandoAttributes['number']}. */
  setNumber(number: number | null): Glissando {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {GlissandoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {GlissandoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Glissando {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {GlissandoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {GlissandoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Glissando {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {GlissandoAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {GlissandoAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Glissando {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type SlideAttributes = {
  /**
   * Indicates if this is the start or stop of the slide.
   */
  type: 'start' | 'stop';
  /**
   * Does the bend accelerate during playback? Default is "no".
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of discrete elements (like MIDI pitch bends) used to represent a continuous bend or slide. Default
   * is 4.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The percentage of the duration for starting a bend. Default is 25.
   */
  'first-beat': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * The percentage of the duration for ending a bend. Default is 75.
   */
  'last-beat': number | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Distinguishes multiple slides when they overlap in MusicXML document order. The default value is 1.
   */
  number: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type SlideContents = [string];

/**
 * The `<slide>` element
 *
 * Parent element: `<notations>`
 *
 * The `<glissando>` and `<slide>` elements both indicate rapidly moving from one pitch to the other so that individual
 * notes are not discerned. A `<slide>` is continuous between the two pitches and defaults to a solid line. The optional
 * text is printed alongside the line.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slide/}
 */
export class Slide implements XMLElement<'slide', SlideAttributes, SlideContents> {
  static readonly schema = {
    name: 'slide',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Slide.schema;

  attributes: SlideAttributes;
  contents: SlideContents;

  constructor(opts?: { attributes?: Partial<SlideAttributes>; contents?: SlideContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Slide.schema);
    this.contents = opts?.contents ?? operations.zero(Slide.schema.contents);
  }
  /** Gets @type {SlideAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {SlideAttributes['type']}. */
  setType(type: 'start' | 'stop'): Slide {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {SlideAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {SlideAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): Slide {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {SlideAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {SlideAttributes['beats']}. */
  setBeats(beats: number | null): Slide {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {SlideAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SlideAttributes['color']}. */
  setColor(color: string | null): Slide {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SlideAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {SlideAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Slide {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {SlideAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SlideAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Slide {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SlideAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SlideAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Slide {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SlideAttributes['first-beat']}. */
  getFirstBeat(): number | null {
    return this.attributes['first-beat'];
  }
  /** Sets @type {SlideAttributes['first-beat']}. */
  setFirstBeat(firstBeat: number | null): Slide {
    this.attributes['first-beat'] = firstBeat;
    return this;
  }
  /** Gets @type {SlideAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SlideAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Slide {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SlideAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SlideAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Slide {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SlideAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SlideAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Slide {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SlideAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SlideAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Slide {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SlideAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {SlideAttributes['id']}. */
  setId(id: string | null): Slide {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {SlideAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {SlideAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): Slide {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {SlideAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {SlideAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Slide {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {SlideAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {SlideAttributes['number']}. */
  setNumber(number: number | null): Slide {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {SlideAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SlideAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Slide {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SlideAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SlideAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Slide {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {SlideAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {SlideAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Slide {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type TrillMarkAttributes = {
  /**
   *
   */
  acccelerate: 'yes' | 'no' | null;
  /**
   *
   */
  beats: number | null;
  /**
   *
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 24 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 12 if not specified.
   */
  'second-beat': number | null;
  /**
   * The starting note for playback, relative to the current note. It is main if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type TrillMarkContents = [];

/**
 * The `<trill-mark>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<trill-mark>` element represents the trill symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/trill-mark/}
 */
export class TrillMark implements XMLElement<'trill-mark', TrillMarkAttributes, TrillMarkContents> {
  static readonly schema = {
    name: 'trill-mark',
    attributes: {
      acccelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = TrillMark.schema;

  attributes: TrillMarkAttributes;
  contents: TrillMarkContents;

  constructor(opts?: { attributes?: Partial<TrillMarkAttributes>; contents?: TrillMarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TrillMark.schema);
    this.contents = opts?.contents ?? operations.zero(TrillMark.schema.contents);
  }
  /** Gets @type {TrillMarkAttributes['acccelerate']}. */
  getAcccelerate(): 'yes' | 'no' | null {
    return this.attributes['acccelerate'];
  }
  /** Sets @type {TrillMarkAttributes['acccelerate']}. */
  setAcccelerate(acccelerate: 'yes' | 'no' | null): TrillMark {
    this.attributes['acccelerate'] = acccelerate;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {TrillMarkAttributes['beats']}. */
  setBeats(beats: number | null): TrillMark {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TrillMarkAttributes['color']}. */
  setColor(color: string | null): TrillMark {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TrillMarkAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): TrillMark {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TrillMarkAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): TrillMark {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TrillMarkAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): TrillMark {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TrillMarkAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TrillMark {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TrillMarkAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TrillMark {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TrillMarkAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TrillMark {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {TrillMarkAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): TrillMark {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TrillMarkAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): TrillMark {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TrillMarkAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): TrillMark {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TrillMarkAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): TrillMark {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {TrillMarkAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): TrillMark {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {TrillMarkAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): TrillMark {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {TrillMarkAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): TrillMark {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {TrillMarkAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {TrillMarkAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): TrillMark {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type TurnAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * If yes, then a vertical line is used to slash the turn. It is no if not specified.
   */
  slash: 'yes' | 'no' | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type TurnContents = [];

/**
 * The `<turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<turn>` element is the normal turn shape which goes up then down.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/turn/}
 */
export class Turn implements XMLElement<'turn', TurnAttributes, TurnContents> {
  static readonly schema = {
    name: 'turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Turn.schema;

  attributes: TurnAttributes;
  contents: TurnContents;

  constructor(opts?: { attributes?: Partial<TurnAttributes>; contents?: TurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Turn.schema);
    this.contents = opts?.contents ?? operations.zero(Turn.schema.contents);
  }
  /** Gets @type {TurnAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {TurnAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): Turn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {TurnAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {TurnAttributes['beats']}. */
  setBeats(beats: number | null): Turn {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {TurnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TurnAttributes['color']}. */
  setColor(color: string | null): Turn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TurnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TurnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Turn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TurnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TurnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Turn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TurnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TurnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Turn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TurnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TurnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Turn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TurnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TurnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Turn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TurnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TurnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Turn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TurnAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {TurnAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): Turn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {TurnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TurnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Turn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TurnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TurnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Turn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TurnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TurnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Turn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {TurnAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {TurnAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): Turn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {TurnAttributes['slash']}. */
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  /** Sets @type {TurnAttributes['slash']}. */
  setSlash(slash: 'yes' | 'no' | null): Turn {
    this.attributes['slash'] = slash;
    return this;
  }
  /** Gets @type {TurnAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {TurnAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Turn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {TurnAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {TurnAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Turn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {TurnAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {TurnAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Turn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type DelayedTurnAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * If yes, then a vertical line is used to slash the turn. It is no if not specified.
   */
  slash: 'yes' | 'no' | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type DelayedTurnContents = [];

/**
 * The `<delayed-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<delayed-turn>` element indicates a normal turn that is delayed until the end of the current note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/delayed-turn/}
 */
export class DelayedTurn implements XMLElement<'delayed-turn', DelayedTurnAttributes, DelayedTurnContents> {
  static readonly schema = {
    name: 'delayed-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = DelayedTurn.schema;

  attributes: DelayedTurnAttributes;
  contents: DelayedTurnContents;

  constructor(opts?: { attributes?: Partial<DelayedTurnAttributes>; contents?: DelayedTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DelayedTurn.schema);
    this.contents = opts?.contents ?? operations.zero(DelayedTurn.schema.contents);
  }
  /** Gets @type {DelayedTurnAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {DelayedTurnAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): DelayedTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {DelayedTurnAttributes['beats']}. */
  setBeats(beats: number | null): DelayedTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DelayedTurnAttributes['color']}. */
  setColor(color: string | null): DelayedTurn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DelayedTurnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DelayedTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DelayedTurnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DelayedTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DelayedTurnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DelayedTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DelayedTurnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DelayedTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DelayedTurnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DelayedTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DelayedTurnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DelayedTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {DelayedTurnAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): DelayedTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DelayedTurnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): DelayedTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DelayedTurnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DelayedTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DelayedTurnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DelayedTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {DelayedTurnAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): DelayedTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['slash']}. */
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  /** Sets @type {DelayedTurnAttributes['slash']}. */
  setSlash(slash: 'yes' | 'no' | null): DelayedTurn {
    this.attributes['slash'] = slash;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {DelayedTurnAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): DelayedTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {DelayedTurnAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): DelayedTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {DelayedTurnAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {DelayedTurnAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): DelayedTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type InvertedTurnAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * If yes, then a vertical line is used to slash the turn. It is no if not specified.
   */
  slash: 'yes' | 'no' | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type InvertedTurnContents = [];

/**
 * The `<inverted-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<inverted-turn>` element has the shape which goes down and then up.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inverted-turn/}
 */
export class InvertedTurn implements XMLElement<'inverted-turn', InvertedTurnAttributes, InvertedTurnContents> {
  static readonly schema = {
    name: 'inverted-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = InvertedTurn.schema;

  attributes: InvertedTurnAttributes;
  contents: InvertedTurnContents;

  constructor(opts?: { attributes?: Partial<InvertedTurnAttributes>; contents?: InvertedTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InvertedTurn.schema);
    this.contents = opts?.contents ?? operations.zero(InvertedTurn.schema.contents);
  }
  /** Gets @type {InvertedTurnAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {InvertedTurnAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): InvertedTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {InvertedTurnAttributes['beats']}. */
  setBeats(beats: number | null): InvertedTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {InvertedTurnAttributes['color']}. */
  setColor(color: string | null): InvertedTurn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {InvertedTurnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): InvertedTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {InvertedTurnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): InvertedTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {InvertedTurnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): InvertedTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {InvertedTurnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): InvertedTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {InvertedTurnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): InvertedTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {InvertedTurnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): InvertedTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {InvertedTurnAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): InvertedTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {InvertedTurnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): InvertedTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {InvertedTurnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): InvertedTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {InvertedTurnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): InvertedTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {InvertedTurnAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): InvertedTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['slash']}. */
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  /** Sets @type {InvertedTurnAttributes['slash']}. */
  setSlash(slash: 'yes' | 'no' | null): InvertedTurn {
    this.attributes['slash'] = slash;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {InvertedTurnAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): InvertedTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {InvertedTurnAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): InvertedTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {InvertedTurnAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {InvertedTurnAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): InvertedTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type DelayedInvertedTurnAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * If yes, then a vertical line is used to slash the turn. It is no if not specified.
   */
  slash: 'yes' | 'no' | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type DelayedInvertedTurnContents = [];

/**
 * The `<delayed-inverted-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<delayed-inverted-turn>` element indicates an inverted turn that is delayed until the end of the current note.
 * An inverted turn has the shape which goes down and then up.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/delayed-inverted-turn/}
 */
export class DelayedInvertedTurn
  implements XMLElement<'delayed-inverted-turn', DelayedInvertedTurnAttributes, DelayedInvertedTurnContents>
{
  static readonly schema = {
    name: 'delayed-inverted-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      slash: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = DelayedInvertedTurn.schema;

  attributes: DelayedInvertedTurnAttributes;
  contents: DelayedInvertedTurnContents;

  constructor(opts?: { attributes?: Partial<DelayedInvertedTurnAttributes>; contents?: DelayedInvertedTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DelayedInvertedTurn.schema);
    this.contents = opts?.contents ?? operations.zero(DelayedInvertedTurn.schema.contents);
  }
  /** Gets @type {DelayedInvertedTurnAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): DelayedInvertedTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['beats']}. */
  setBeats(beats: number | null): DelayedInvertedTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['color']}. */
  setColor(color: string | null): DelayedInvertedTurn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DelayedInvertedTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DelayedInvertedTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DelayedInvertedTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DelayedInvertedTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DelayedInvertedTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DelayedInvertedTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): DelayedInvertedTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): DelayedInvertedTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DelayedInvertedTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DelayedInvertedTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): DelayedInvertedTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['slash']}. */
  getSlash(): 'yes' | 'no' | null {
    return this.attributes['slash'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['slash']}. */
  setSlash(slash: 'yes' | 'no' | null): DelayedInvertedTurn {
    this.attributes['slash'] = slash;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): DelayedInvertedTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): DelayedInvertedTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {DelayedInvertedTurnAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {DelayedInvertedTurnAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): DelayedInvertedTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type VerticalTurnAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type VerticalTurnContents = [];

/**
 * The `<vertical-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<vertical-turn>` element has the turn symbol shape arranged vertically going from upper left to lower right.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/vertical-turn/}
 */
export class VerticalTurn implements XMLElement<'vertical-turn', VerticalTurnAttributes, VerticalTurnContents> {
  static readonly schema = {
    name: 'vertical-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = VerticalTurn.schema;

  attributes: VerticalTurnAttributes;
  contents: VerticalTurnContents;

  constructor(opts?: { attributes?: Partial<VerticalTurnAttributes>; contents?: VerticalTurnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, VerticalTurn.schema);
    this.contents = opts?.contents ?? operations.zero(VerticalTurn.schema.contents);
  }
  /** Gets @type {VerticalTurnAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {VerticalTurnAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): VerticalTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {VerticalTurnAttributes['beats']}. */
  setBeats(beats: number | null): VerticalTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {VerticalTurnAttributes['color']}. */
  setColor(color: string | null): VerticalTurn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {VerticalTurnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): VerticalTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {VerticalTurnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): VerticalTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {VerticalTurnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): VerticalTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {VerticalTurnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): VerticalTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {VerticalTurnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): VerticalTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {VerticalTurnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): VerticalTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {VerticalTurnAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): VerticalTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {VerticalTurnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): VerticalTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {VerticalTurnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): VerticalTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {VerticalTurnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): VerticalTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {VerticalTurnAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): VerticalTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {VerticalTurnAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): VerticalTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {VerticalTurnAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): VerticalTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {VerticalTurnAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {VerticalTurnAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): VerticalTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type InvertedVerticalTurnAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type InvertedVerticalTurnContents = [];

/**
 * The `<inverted-vertical-turn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<inverted-vertical-turn>` element has the turn symbol shape arranged vertically going from upper right to lower left.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inverted-vertical-turn/}
 */
export class InvertedVerticalTurn
  implements XMLElement<'inverted-vertical-turn', InvertedVerticalTurnAttributes, InvertedVerticalTurnContents>
{
  static readonly schema = {
    name: 'inverted-vertical-turn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = InvertedVerticalTurn.schema;

  attributes: InvertedVerticalTurnAttributes;
  contents: InvertedVerticalTurnContents;

  constructor(opts?: {
    attributes?: Partial<InvertedVerticalTurnAttributes>;
    contents?: InvertedVerticalTurnContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, InvertedVerticalTurn.schema);
    this.contents = opts?.contents ?? operations.zero(InvertedVerticalTurn.schema.contents);
  }
  /** Gets @type {InvertedVerticalTurnAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): InvertedVerticalTurn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['beats']}. */
  setBeats(beats: number | null): InvertedVerticalTurn {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['color']}. */
  setColor(color: string | null): InvertedVerticalTurn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): InvertedVerticalTurn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): InvertedVerticalTurn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): InvertedVerticalTurn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): InvertedVerticalTurn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): InvertedVerticalTurn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): InvertedVerticalTurn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): InvertedVerticalTurn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): InvertedVerticalTurn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): InvertedVerticalTurn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): InvertedVerticalTurn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): InvertedVerticalTurn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): InvertedVerticalTurn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): InvertedVerticalTurn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {InvertedVerticalTurnAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {InvertedVerticalTurnAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): InvertedVerticalTurn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type ShakeAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type ShakeContents = [];

/**
 * The `<shake>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<shake>` element has a similar appearance to an `<inverted-mordent>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/shake/}
 */
export class Shake implements XMLElement<'shake', ShakeAttributes, ShakeContents> {
  static readonly schema = {
    name: 'shake',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Shake.schema;

  attributes: ShakeAttributes;
  contents: ShakeContents;

  constructor(opts?: { attributes?: Partial<ShakeAttributes>; contents?: ShakeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Shake.schema);
    this.contents = opts?.contents ?? operations.zero(Shake.schema.contents);
  }
  /** Gets @type {ShakeAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {ShakeAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): Shake {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {ShakeAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {ShakeAttributes['beats']}. */
  setBeats(beats: number | null): Shake {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {ShakeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ShakeAttributes['color']}. */
  setColor(color: string | null): Shake {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ShakeAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ShakeAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Shake {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ShakeAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ShakeAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Shake {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ShakeAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {ShakeAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Shake {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {ShakeAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {ShakeAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Shake {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {ShakeAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {ShakeAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Shake {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {ShakeAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {ShakeAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Shake {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {ShakeAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {ShakeAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): Shake {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {ShakeAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {ShakeAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Shake {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {ShakeAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ShakeAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Shake {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ShakeAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ShakeAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Shake {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {ShakeAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {ShakeAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): Shake {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {ShakeAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {ShakeAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Shake {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {ShakeAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {ShakeAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Shake {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {ShakeAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {ShakeAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Shake {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type WavyLineAttributes = {
  /**
   * Indicates if this is the start, stop, or continuation of the wavy line. The value should be continue whenever
   * used within a `<barline>` element.
   */
  type: 'start' | 'stop' | 'continue';
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 4 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 75 if not specified.
   */
  'last-beat': number | null;
  /**
   * Distinguishes multiple wavy lines when they overlap in MusicXML document order.
   */
  number: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 25 if not specified.
   */
  'second-beat': number | null;
  /**
   * Specifies a particular wavy line glyph from the Standard Music Font Layout (SMuFL)
   * [Multi-segment lines](https://www.w3.org/2021/03/smufl14/tables/multi-segment-lines.html) range.
   */
  smufl: string | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type WavyLineContents = [];

/**
 * The `<wavy-line>` element
 *
 * Parent elements: `<barline>`, `<ornaments>`
 *
 * Wavy lines are one way to indicate trills and vibrato.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wavy-line/}
 */
export class WavyLine implements XMLElement<'wavy-line', WavyLineAttributes, WavyLineContents> {
  static readonly schema = {
    name: 'wavy-line',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(wiggle)|(guitar\c*VibratoStroke)/, zero: 'wiggle' },
      },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = WavyLine.schema;

  attributes: WavyLineAttributes;
  contents: WavyLineContents;

  constructor(opts?: { attributes?: Partial<WavyLineAttributes>; contents?: WavyLineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WavyLine.schema);
    this.contents = opts?.contents ?? operations.zero(WavyLine.schema.contents);
  }
  /** Gets @type {WavyLineAttributes['type']}. */
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  /** Sets @type {WavyLineAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'continue'): WavyLine {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {WavyLineAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {WavyLineAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): WavyLine {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {WavyLineAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {WavyLineAttributes['beats']}. */
  setBeats(beats: number | null): WavyLine {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {WavyLineAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {WavyLineAttributes['color']}. */
  setColor(color: string | null): WavyLine {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {WavyLineAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {WavyLineAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): WavyLine {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {WavyLineAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {WavyLineAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): WavyLine {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {WavyLineAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {WavyLineAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): WavyLine {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {WavyLineAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {WavyLineAttributes['number']}. */
  setNumber(number: number | null): WavyLine {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {WavyLineAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {WavyLineAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): WavyLine {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {WavyLineAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {WavyLineAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): WavyLine {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {WavyLineAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {WavyLineAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): WavyLine {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {WavyLineAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {WavyLineAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): WavyLine {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {WavyLineAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {WavyLineAttributes['smufl']}. */
  setSmufl(smufl: string | null): WavyLine {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {WavyLineAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {WavyLineAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): WavyLine {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {WavyLineAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {WavyLineAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): WavyLine {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {WavyLineAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {WavyLineAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): WavyLine {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type MordentAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * Used for compound ornaments, indicating how the beginning of the ornament look relative to the main part of the
   * mordent.
   */
  approach: 'above' | 'below' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 3 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Used for compound ornaments, indicating how the ending of the ornament look relative to the main part of the
   * mordent.
   */
  departure: 'above' | 'below' | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 24 if not specified.
   */
  'last-beat': number | null;
  /**
   * Specifies if the ornament is longer than usual. The value is no if not specified.
   */
  long: 'yes' | 'no' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 12 if not specified.
   */
  'second-beat': number | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type MordentContents = [];

/**
 * The `<mordent>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<mordent>` element represents the sign with the vertical line. The choice of which mordent sign is inverted
 * differs between MusicXML and the Standard Music Font Layout (SMuFL).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mordent/}
 */
export class Mordent implements XMLElement<'mordent', MordentAttributes, MordentContents> {
  static readonly schema = {
    name: 'mordent',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      approach: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      departure: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      long: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Mordent.schema;

  attributes: MordentAttributes;
  contents: MordentContents;

  constructor(opts?: { attributes?: Partial<MordentAttributes>; contents?: MordentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mordent.schema);
    this.contents = opts?.contents ?? operations.zero(Mordent.schema.contents);
  }
  /** Gets @type {MordentAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {MordentAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): Mordent {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {MordentAttributes['approach']}. */
  getApproach(): 'above' | 'below' | null {
    return this.attributes['approach'];
  }
  /** Sets @type {MordentAttributes['approach']}. */
  setApproach(approach: 'above' | 'below' | null): Mordent {
    this.attributes['approach'] = approach;
    return this;
  }
  /** Gets @type {MordentAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {MordentAttributes['beats']}. */
  setBeats(beats: number | null): Mordent {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {MordentAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {MordentAttributes['color']}. */
  setColor(color: string | null): Mordent {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {MordentAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {MordentAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Mordent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {MordentAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {MordentAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Mordent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {MordentAttributes['departure']}. */
  getDeparture(): 'above' | 'below' | null {
    return this.attributes['departure'];
  }
  /** Sets @type {MordentAttributes['departure']}. */
  setDeparture(departure: 'above' | 'below' | null): Mordent {
    this.attributes['departure'] = departure;
    return this;
  }
  /** Gets @type {MordentAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {MordentAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Mordent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {MordentAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {MordentAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Mordent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {MordentAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {MordentAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Mordent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {MordentAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {MordentAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Mordent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {MordentAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {MordentAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): Mordent {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {MordentAttributes['long']}. */
  getLong(): 'yes' | 'no' | null {
    return this.attributes['long'];
  }
  /** Sets @type {MordentAttributes['long']}. */
  setLong(long: 'yes' | 'no' | null): Mordent {
    this.attributes['long'] = long;
    return this;
  }
  /** Gets @type {MordentAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {MordentAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Mordent {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {MordentAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {MordentAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Mordent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {MordentAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {MordentAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Mordent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {MordentAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {MordentAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): Mordent {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {MordentAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {MordentAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Mordent {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {MordentAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {MordentAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Mordent {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {MordentAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {MordentAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Mordent {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type InvertedMordentAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * Used for compound ornaments, indicating how the beginning of the ornament look relative to the main part of the
   * mordent.
   */
  approach: 'above' | 'below' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 3 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Used for compound ornaments, indicating how the ending of the ornament look relative to the main part of the
   * mordent.
   */
  departure: 'above' | 'below' | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 24 if not specified.
   */
  'last-beat': number | null;
  /**
   * Specifies if the ornament is longer than usual. The value is no if not specified.
   */
  long: 'yes' | 'no' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 12 if not specified.
   */
  'second-beat': number | null;
  /**
   * The starting note for playback, relative to the current note. It is upper if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type InvertedMordentContents = [];

/**
 * The `<inverted-mordent>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<inverted-mordent>` element represents the sign without the vertical line. The choice of which mordent is
 * inverted differs between MusicXML and the Standard Music Font Layout (SMuFL).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inverted-mordent/}
 */
export class InvertedMordent
  implements XMLElement<'inverted-mordent', InvertedMordentAttributes, InvertedMordentContents>
{
  static readonly schema = {
    name: 'inverted-mordent',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      approach: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      departure: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      long: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = InvertedMordent.schema;

  attributes: InvertedMordentAttributes;
  contents: InvertedMordentContents;

  constructor(opts?: { attributes?: Partial<InvertedMordentAttributes>; contents?: InvertedMordentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InvertedMordent.schema);
    this.contents = opts?.contents ?? operations.zero(InvertedMordent.schema.contents);
  }
  /** Gets @type {InvertedMordentAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {InvertedMordentAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): InvertedMordent {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['approach']}. */
  getApproach(): 'above' | 'below' | null {
    return this.attributes['approach'];
  }
  /** Sets @type {InvertedMordentAttributes['approach']}. */
  setApproach(approach: 'above' | 'below' | null): InvertedMordent {
    this.attributes['approach'] = approach;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {InvertedMordentAttributes['beats']}. */
  setBeats(beats: number | null): InvertedMordent {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {InvertedMordentAttributes['color']}. */
  setColor(color: string | null): InvertedMordent {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {InvertedMordentAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): InvertedMordent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {InvertedMordentAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): InvertedMordent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['departure']}. */
  getDeparture(): 'above' | 'below' | null {
    return this.attributes['departure'];
  }
  /** Sets @type {InvertedMordentAttributes['departure']}. */
  setDeparture(departure: 'above' | 'below' | null): InvertedMordent {
    this.attributes['departure'] = departure;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {InvertedMordentAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): InvertedMordent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {InvertedMordentAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): InvertedMordent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {InvertedMordentAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): InvertedMordent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {InvertedMordentAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): InvertedMordent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {InvertedMordentAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): InvertedMordent {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['long']}. */
  getLong(): 'yes' | 'no' | null {
    return this.attributes['long'];
  }
  /** Sets @type {InvertedMordentAttributes['long']}. */
  setLong(long: 'yes' | 'no' | null): InvertedMordent {
    this.attributes['long'] = long;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {InvertedMordentAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): InvertedMordent {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {InvertedMordentAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): InvertedMordent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {InvertedMordentAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): InvertedMordent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {InvertedMordentAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): InvertedMordent {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {InvertedMordentAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): InvertedMordent {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {InvertedMordentAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): InvertedMordent {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {InvertedMordentAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {InvertedMordentAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): InvertedMordent {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type SchleiferAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type SchleiferContents = [];

/**
 * The `<schleifer>` element
 *
 * Parent element: `<ornaments>`
 *
 * The name for the `<schleifer>` element is based on the German ornament name, to avoid confusion with the `<slide>`
 * element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/schleifer/}
 */
export class Schleifer implements XMLElement<'schleifer', SchleiferAttributes, SchleiferContents> {
  static readonly schema = {
    name: 'schleifer',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Schleifer.schema;

  attributes: SchleiferAttributes;
  contents: SchleiferContents;

  constructor(opts?: { attributes?: Partial<SchleiferAttributes>; contents?: SchleiferContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Schleifer.schema);
    this.contents = opts?.contents ?? operations.zero(Schleifer.schema.contents);
  }
  /** Gets @type {SchleiferAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SchleiferAttributes['color']}. */
  setColor(color: string | null): Schleifer {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SchleiferAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SchleiferAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Schleifer {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SchleiferAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SchleiferAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Schleifer {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SchleiferAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SchleiferAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Schleifer {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SchleiferAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SchleiferAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Schleifer {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SchleiferAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SchleiferAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Schleifer {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SchleiferAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SchleiferAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Schleifer {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SchleiferAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {SchleiferAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Schleifer {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {SchleiferAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SchleiferAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Schleifer {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SchleiferAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SchleiferAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Schleifer {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type TremoloAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
  /**
   * Single-note tremolos use single, double-note tremolos use start or stop, and unmeasured tremolos use
   * unmeasured. The default value is single for compatibility with Version 1.1.
   */
  type: 'start' | 'stop' | 'single' | 'unmeasured' | null;
};

export type TremoloContents = [number];

/**
 * The `<tremolo>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<tremolo>` element can be used to indicate single-note, double-note, or unmeasured tremolos. The text of the
 * element indicates the number of tremolo marks and is an integer from 0 to 8. Note that the number of attached beams
 * is not included in this value, but is represented separately using the `<beam element>`. The value should be 0 for
 * unmeasured tremolos.
 *
 * When using double-note tremolos, the duration of each note in the tremolo should correspond to half of the notated
 * type value. A `<time-modification>` element should also be added with an `<actual-notes>` value of 2 and a
 * `<normal-notes>` value of 1. If used within a tuplet, this 2/1 ratio should be multiplied by the existing tuplet
 * ratio.
 *
 * The smufl attribute specifies the glyph to use from the Standard Music Font Layout (SMuFL) Tremolos range for an
 * unmeasured tremolo. It is ignored for other tremolo types. The SMuFL buzzRoll glyph is used if the attribute is
 * missing.
 *
 * Using repeater beams for indicating tremolos is deprecated as of Version 3.0.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tremolo/}
 */
export class Tremolo implements XMLElement<'tremolo', TremoloAttributes, TremoloContents> {
  static readonly schema = {
    name: 'tremolo',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'single', 'unmeasured'] } },
    },
    contents: [
      { type: 'required', value: { type: 'label', label: 'tremolo-marks', value: { type: 'int', min: 0, max: 8 } } },
    ],
  } as const;

  readonly schema = Tremolo.schema;

  attributes: TremoloAttributes;
  contents: TremoloContents;

  constructor(opts?: { attributes?: Partial<TremoloAttributes>; contents?: TremoloContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tremolo.schema);
    this.contents = opts?.contents ?? operations.zero(Tremolo.schema.contents);
  }
  /** Gets @type {TremoloAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TremoloAttributes['color']}. */
  setColor(color: string | null): Tremolo {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TremoloAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TremoloAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Tremolo {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TremoloAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TremoloAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Tremolo {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TremoloAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TremoloAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Tremolo {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TremoloAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TremoloAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Tremolo {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TremoloAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TremoloAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Tremolo {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TremoloAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TremoloAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Tremolo {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TremoloAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TremoloAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Tremolo {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TremoloAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TremoloAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Tremolo {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TremoloAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TremoloAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Tremolo {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {TremoloAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {TremoloAttributes['smufl']}. */
  setSmufl(smufl: string | null): Tremolo {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {TremoloAttributes['type']}. */
  getType(): 'start' | 'stop' | 'single' | 'unmeasured' | null {
    return this.attributes['type'];
  }
  /** Sets @type {TremoloAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'single' | 'unmeasured' | null): Tremolo {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {number}. */
  getTremoloMarks(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setTremoloMarks(tremoloMarks: number): this {
    this.contents[0] = tremoloMarks;
    return this;
  }
}

export type HaydnAttributes = {
  /**
   * If yes, the trill accelerates during playback. It is no if not specified.
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of distinct notes during playback, counting the starting note but not the two-note turn. It is 3 if
   * not specified.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the way through the duration for landing on the last beat. It is 24 if not specified.
   */
  'last-beat': number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The percentage of the way through the duration for landing on the second beat. It is 12 if not specified.
   */
  'second-beat': number | null;
  /**
   * The starting note for playback, relative to the current note. It is main if not specified.
   */
  'start-note': 'below' | 'main' | 'upper' | null;
  /**
   * The alternating note for playback, relative to the current note. It is whole if not specified.
   */
  'trill-step': 'unison' | 'half' | 'whole' | null;
  /**
   * Specifies the two-note turn included at the end of the trill, if any. It is none if not specified.
   */
  'two-note-turn': 'none' | 'whole' | 'half' | null;
};

export type HaydnContents = [];

/**
 * The `<haydn>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<haydn>` element represents the Haydn ornament. This is defined in the Standard Music Font Layout (SMuFL) as
 * ornamentHaydn.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/haydn/}
 */
export class Haydn implements XMLElement<'haydn', HaydnAttributes, HaydnContents> {
  static readonly schema = {
    name: 'haydn',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'second-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'start-note': { type: 'optional', value: { type: 'choices', choices: ['below', 'main', 'upper'] } },
      'trill-step': { type: 'optional', value: { type: 'choices', choices: ['unison', 'half', 'whole'] } },
      'two-note-turn': { type: 'optional', value: { type: 'choices', choices: ['none', 'whole', 'half'] } },
    },
    contents: [],
  } as const;

  readonly schema = Haydn.schema;

  attributes: HaydnAttributes;
  contents: HaydnContents;

  constructor(opts?: { attributes?: Partial<HaydnAttributes>; contents?: HaydnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Haydn.schema);
    this.contents = opts?.contents ?? operations.zero(Haydn.schema.contents);
  }
  /** Gets @type {HaydnAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {HaydnAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): Haydn {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {HaydnAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {HaydnAttributes['beats']}. */
  setBeats(beats: number | null): Haydn {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {HaydnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HaydnAttributes['color']}. */
  setColor(color: string | null): Haydn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HaydnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HaydnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Haydn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HaydnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HaydnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Haydn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HaydnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HaydnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Haydn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HaydnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HaydnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Haydn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HaydnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HaydnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Haydn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HaydnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HaydnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Haydn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HaydnAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {HaydnAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): Haydn {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {HaydnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HaydnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Haydn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HaydnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HaydnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Haydn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HaydnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HaydnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Haydn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {HaydnAttributes['second-beat']}. */
  getSecondBeat(): number | null {
    return this.attributes['second-beat'];
  }
  /** Sets @type {HaydnAttributes['second-beat']}. */
  setSecondBeat(secondBeat: number | null): Haydn {
    this.attributes['second-beat'] = secondBeat;
    return this;
  }
  /** Gets @type {HaydnAttributes['start-note']}. */
  getStartNote(): 'below' | 'main' | 'upper' | null {
    return this.attributes['start-note'];
  }
  /** Sets @type {HaydnAttributes['start-note']}. */
  setStartNote(startNote: 'below' | 'main' | 'upper' | null): Haydn {
    this.attributes['start-note'] = startNote;
    return this;
  }
  /** Gets @type {HaydnAttributes['trill-step']}. */
  getTrillStep(): 'unison' | 'half' | 'whole' | null {
    return this.attributes['trill-step'];
  }
  /** Sets @type {HaydnAttributes['trill-step']}. */
  setTrillStep(trillStep: 'unison' | 'half' | 'whole' | null): Haydn {
    this.attributes['trill-step'] = trillStep;
    return this;
  }
  /** Gets @type {HaydnAttributes['two-note-turn']}. */
  getTwoNoteTurn(): 'none' | 'whole' | 'half' | null {
    return this.attributes['two-note-turn'];
  }
  /** Sets @type {HaydnAttributes['two-note-turn']}. */
  setTwoNoteTurn(twoNoteTurn: 'none' | 'whole' | 'half' | null): Haydn {
    this.attributes['two-note-turn'] = twoNoteTurn;
    return this;
  }
}

export type OtherOrnamentAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type OtherOrnamentContents = [string];

/**
 * The `<other-ornament>` element
 *
 * Parent element: `<ornaments>`
 *
 * The `<other-ornament>` element is used to define any ornaments not yet in the MusicXML format. The smufl attribute
 * can be used to specify a particular ornament, allowing application interoperability without requiring every Standard
 * Music Font Layout (SMuFL) ornament to have a MusicXML element equivalent. Using the `<other-ornament>` element
 * without the smufl attribute allows for extended representation, though without application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-ornament/}
 */
export class OtherOrnament implements XMLElement<'other-ornament', OtherOrnamentAttributes, OtherOrnamentContents> {
  static readonly schema = {
    name: 'other-ornament',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherOrnament.schema;

  attributes: OtherOrnamentAttributes;
  contents: OtherOrnamentContents;

  constructor(opts?: { attributes?: Partial<OtherOrnamentAttributes>; contents?: OtherOrnamentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherOrnament.schema);
    this.contents = opts?.contents ?? operations.zero(OtherOrnament.schema.contents);
  }
  /** Gets @type {OtherOrnamentAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OtherOrnamentAttributes['color']}. */
  setColor(color: string | null): OtherOrnament {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OtherOrnamentAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): OtherOrnament {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OtherOrnamentAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): OtherOrnament {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {OtherOrnamentAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): OtherOrnament {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {OtherOrnamentAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherOrnament {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {OtherOrnamentAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherOrnament {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {OtherOrnamentAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherOrnament {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {OtherOrnamentAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): OtherOrnament {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OtherOrnamentAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): OtherOrnament {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OtherOrnamentAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): OtherOrnament {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {OtherOrnamentAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OtherOrnamentAttributes['smufl']}. */
  setSmufl(smufl: string | null): OtherOrnament {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type AccidentalMarkAttributes = {
  /**
   *
   */
  bracket: 'yes' | 'no' | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies whether or not parentheses are put around a symbol for an editorial indication. If not specified, it
   * is left to application defaults.
   */
  parentheses: 'yes' | 'no' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Specifies the symbol size to use for an editorial indication. If not specified, it is left to application
   * defaults.
   */
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
  /**
   * References a specific Standard Music Font Layout (SMuFL) accidental glyph. This is used both with the other
   * accidental value and for disambiguating cases where a single MusicXML accidental value could be represented by
   * multiple SMuFL glyphs.
   */
  smufl: string | null;
};

export type AccidentalMarkContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron',
];

/**
 * The `<accidental-mark>` element
 *
 * Parent elements: `<notations>`, `<ornaments>`
 *
 * An `<accidental-mark>` element can be used as a separate notation or as part of an ornament. When used in an
 * ornament, position and placement are relative to the ornament, not relative to the note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accidental-mark/}
 */
export class AccidentalMark implements XMLElement<'accidental-mark', AccidentalMarkAttributes, AccidentalMarkContents> {
  static readonly schema = {
    name: 'accidental-mark',
    attributes: {
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'accidental-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'sharp',
              'natural',
              'flat',
              'double-sharp',
              'sharp-sharp',
              'flat-flat',
              'natural-sharp',
              'natural-flat',
              'quarter-flat',
              'quarter-sharp',
              'three-quarters-flat',
              'three-quarters-sharp',
              'sharp-down',
              'sharp-up',
              'natural-down',
              'natural-up',
              'flat-down',
              'flat-up',
              'double-sharp-down',
              'double-sharp-up',
              'flat-flat-down',
              'flat-flat-up',
              'arrow-down',
              'arrow-up',
              'triple-sharp',
              'triple-flat',
              'slash-quarter-sharp',
              'slash-sharp',
              'slash-flat',
              'double-slash-flat',
              'sharp-1',
              'sharp-2',
              'sharp-3',
              'sharp-5',
              'flat-1',
              'flat-2',
              'flat-3',
              'flat-4',
              'sori',
              'koron',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = AccidentalMark.schema;

  attributes: AccidentalMarkAttributes;
  contents: AccidentalMarkContents;

  constructor(opts?: { attributes?: Partial<AccidentalMarkAttributes>; contents?: AccidentalMarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccidentalMark.schema);
    this.contents = opts?.contents ?? operations.zero(AccidentalMark.schema.contents);
  }
  /** Gets @type {AccidentalMarkAttributes['bracket']}. */
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  /** Sets @type {AccidentalMarkAttributes['bracket']}. */
  setBracket(bracket: 'yes' | 'no' | null): AccidentalMark {
    this.attributes['bracket'] = bracket;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {AccidentalMarkAttributes['color']}. */
  setColor(color: string | null): AccidentalMark {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {AccidentalMarkAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): AccidentalMark {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {AccidentalMarkAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): AccidentalMark {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {AccidentalMarkAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): AccidentalMark {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {AccidentalMarkAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): AccidentalMark {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {AccidentalMarkAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): AccidentalMark {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {AccidentalMarkAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): AccidentalMark {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {AccidentalMarkAttributes['id']}. */
  setId(id: string | null): AccidentalMark {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['parentheses']}. */
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  /** Sets @type {AccidentalMarkAttributes['parentheses']}. */
  setParentheses(parentheses: 'yes' | 'no' | null): AccidentalMark {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {AccidentalMarkAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): AccidentalMark {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {AccidentalMarkAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): AccidentalMark {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {AccidentalMarkAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): AccidentalMark {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['size']}. */
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  /** Sets @type {AccidentalMarkAttributes['size']}. */
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): AccidentalMark {
    this.attributes['size'] = size;
    return this;
  }
  /** Gets @type {AccidentalMarkAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {AccidentalMarkAttributes['smufl']}. */
  setSmufl(smufl: string | null): AccidentalMark {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): this {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type OrnamentsAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
};

export type OrnamentsContents = [
  Array<
    | TrillMark
    | Turn
    | DelayedTurn
    | InvertedTurn
    | DelayedInvertedTurn
    | VerticalTurn
    | InvertedVerticalTurn
    | Shake
    | WavyLine
    | Mordent
    | InvertedMordent
    | Schleifer
    | Tremolo
    | Haydn
    | OtherOrnament
  >,
  Array<AccidentalMark>,
];

/**
 * The `<ornaments>` element
 *
 * Parent element: `<notations>`
 *
 * Ornaments can be any of several types, followed optionally by accidentals. The `<accidental-mark>` element's content
 * is represented the same as an `<accidental>` element, but with a different name to reflect the different musical
 * meaning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ornaments/}
 */
export class Ornaments implements XMLElement<'ornaments', OrnamentsAttributes, OrnamentsContents> {
  static readonly schema = {
    name: 'ornaments',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              TrillMark,
              Turn,
              DelayedTurn,
              InvertedTurn,
              DelayedInvertedTurn,
              VerticalTurn,
              InvertedVerticalTurn,
              Shake,
              WavyLine,
              Mordent,
              InvertedMordent,
              Schleifer,
              Tremolo,
              Haydn,
              OtherOrnament,
            ],
          },
        },
      },
      { type: 'label', label: 'accidental-marks', value: { type: 'zeroOrMore', value: AccidentalMark } },
    ],
  } as const;

  readonly schema = Ornaments.schema;

  attributes: OrnamentsAttributes;
  contents: OrnamentsContents;

  constructor(opts?: { attributes?: Partial<OrnamentsAttributes>; contents?: OrnamentsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ornaments.schema);
    this.contents = opts?.contents ?? operations.zero(Ornaments.schema.contents);
  }
  /** Gets @type {OrnamentsAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {OrnamentsAttributes['id']}. */
  setId(id: string | null): Ornaments {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Array<TrillMark | Turn | DelayedTurn | InvertedTurn | DelayedInvertedTurn | VerticalTurn | InvertedVerticalTurn | Shake | WavyLine | Mordent | InvertedMordent | Schleifer | Tremolo | Haydn | OtherOrnament>}. */
  getValues(): Array<
    | TrillMark
    | Turn
    | DelayedTurn
    | InvertedTurn
    | DelayedInvertedTurn
    | VerticalTurn
    | InvertedVerticalTurn
    | Shake
    | WavyLine
    | Mordent
    | InvertedMordent
    | Schleifer
    | Tremolo
    | Haydn
    | OtherOrnament
  > {
    return this.contents[0];
  }
  /** Sets @type {Array<TrillMark | Turn | DelayedTurn | InvertedTurn | DelayedInvertedTurn | VerticalTurn | InvertedVerticalTurn | Shake | WavyLine | Mordent | InvertedMordent | Schleifer | Tremolo | Haydn | OtherOrnament>}. */
  setValues(
    values: Array<
      | TrillMark
      | Turn
      | DelayedTurn
      | InvertedTurn
      | DelayedInvertedTurn
      | VerticalTurn
      | InvertedVerticalTurn
      | Shake
      | WavyLine
      | Mordent
      | InvertedMordent
      | Schleifer
      | Tremolo
      | Haydn
      | OtherOrnament
    >
  ): this {
    this.contents[0] = values;
    return this;
  }
  /** Gets @type {Array<AccidentalMark>}. */
  getAccidentalMarks(): Array<AccidentalMark> {
    return this.contents[1];
  }
  /** Sets @type {Array<AccidentalMark>}. */
  setAccidentalMarks(accidentalMarks: Array<AccidentalMark>): this {
    this.contents[1] = accidentalMarks;
    return this;
  }
}

export type UpBowAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type UpBowContents = [];

/**
 * The `<up-bow>` element
 *
 * Parent element: `<technical>`
 *
 * The `<up-bow>` element represents the symbol that is used both for up-bowing on bowed instruments, and up-stroke on
 * plucked instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/up-bow/}
 */
export class UpBow implements XMLElement<'up-bow', UpBowAttributes, UpBowContents> {
  static readonly schema = {
    name: 'up-bow',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = UpBow.schema;

  attributes: UpBowAttributes;
  contents: UpBowContents;

  constructor(opts?: { attributes?: Partial<UpBowAttributes>; contents?: UpBowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, UpBow.schema);
    this.contents = opts?.contents ?? operations.zero(UpBow.schema.contents);
  }
  /** Gets @type {UpBowAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {UpBowAttributes['color']}. */
  setColor(color: string | null): UpBow {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {UpBowAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {UpBowAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): UpBow {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {UpBowAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {UpBowAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): UpBow {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {UpBowAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {UpBowAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): UpBow {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {UpBowAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {UpBowAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): UpBow {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {UpBowAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {UpBowAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): UpBow {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {UpBowAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {UpBowAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): UpBow {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {UpBowAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {UpBowAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): UpBow {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {UpBowAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {UpBowAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): UpBow {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {UpBowAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {UpBowAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): UpBow {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type DownBowAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type DownBowContents = [];

/**
 * The `<down-bow> element
 *
 * Parent element: `<technical>
 *
 * The `<down-bow> element represents the symbol that is used both for down-bowing on bowed instruments, and down-stroke
 * on plucked instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/down-bow/}
 */
export class DownBow implements XMLElement<'down-bow', DownBowAttributes, DownBowContents> {
  static readonly schema = {
    name: 'down-bow',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = DownBow.schema;

  attributes: DownBowAttributes;
  contents: DownBowContents;

  constructor(opts?: { attributes?: Partial<DownBowAttributes>; contents?: DownBowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DownBow.schema);
    this.contents = opts?.contents ?? operations.zero(DownBow.schema.contents);
  }
  /** Gets @type {DownBowAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DownBowAttributes['color']}. */
  setColor(color: string | null): DownBow {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DownBowAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DownBowAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DownBow {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DownBowAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DownBowAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DownBow {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DownBowAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DownBowAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DownBow {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DownBowAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DownBowAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DownBow {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DownBowAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DownBowAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DownBow {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DownBowAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DownBowAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DownBow {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DownBowAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DownBowAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): DownBow {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DownBowAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DownBowAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DownBow {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DownBowAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DownBowAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DownBow {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type NaturalAttributes = Record<string, unknown>;

export type NaturalContents = [];

/**
 * The `<natural>` element
 *
 * Parent element: `<harmonic>`
 *
 * The `<natural>` element indicates that this is a natural harmonic. These are usually notated at base pitch rather
 * than sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/natural/}
 */
export class Natural implements XMLElement<'natural', NaturalAttributes, NaturalContents> {
  static readonly schema = { name: 'natural', attributes: {}, contents: [] } as const;

  readonly schema = Natural.schema;

  attributes: NaturalAttributes;
  contents: NaturalContents;

  constructor(opts?: { attributes?: Partial<NaturalAttributes>; contents?: NaturalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Natural.schema);
    this.contents = opts?.contents ?? operations.zero(Natural.schema.contents);
  }
}

export type ArtificialAttributes = Record<string, unknown>;

export type ArtificialContents = [];

/**
 * The `<artificial>` element
 *
 * Parent element: `<harmonic>`
 *
 * The `<artificial>` element indicates that this is an artificial harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/artificial/}
 */
export class Artificial implements XMLElement<'artificial', ArtificialAttributes, ArtificialContents> {
  static readonly schema = { name: 'artificial', attributes: {}, contents: [] } as const;

  readonly schema = Artificial.schema;

  attributes: ArtificialAttributes;
  contents: ArtificialContents;

  constructor(opts?: { attributes?: Partial<ArtificialAttributes>; contents?: ArtificialContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Artificial.schema);
    this.contents = opts?.contents ?? operations.zero(Artificial.schema.contents);
  }
}

export type BasePitchAttributes = Record<string, unknown>;

export type BasePitchContents = [];

/**
 * The `<base-pitch>` element
 *
 * Parent element: `<harmonic>`
 *
 * The presence of the `<base-pitch>` element indicates this is the pitch at which the string is played before touching
 * to create the harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/base-pitch/}
 */
export class BasePitch implements XMLElement<'base-pitch', BasePitchAttributes, BasePitchContents> {
  static readonly schema = { name: 'base-pitch', attributes: {}, contents: [] } as const;

  readonly schema = BasePitch.schema;

  attributes: BasePitchAttributes;
  contents: BasePitchContents;

  constructor(opts?: { attributes?: Partial<BasePitchAttributes>; contents?: BasePitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BasePitch.schema);
    this.contents = opts?.contents ?? operations.zero(BasePitch.schema.contents);
  }
}

export type TouchingPitchAttributes = Record<string, unknown>;

export type TouchingPitchContents = [];

/**
 * The `<touching-pitch>` element
 *
 * Parent element: `<harmonic>`
 *
 * The presence of the `<touching-pitch>` element indicates this is the pitch at which the string is touched lightly to
 * produce the harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/touching-pitch/}
 */
export class TouchingPitch implements XMLElement<'touching-pitch', TouchingPitchAttributes, TouchingPitchContents> {
  static readonly schema = { name: 'touching-pitch', attributes: {}, contents: [] } as const;

  readonly schema = TouchingPitch.schema;

  attributes: TouchingPitchAttributes;
  contents: TouchingPitchContents;

  constructor(opts?: { attributes?: Partial<TouchingPitchAttributes>; contents?: TouchingPitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TouchingPitch.schema);
    this.contents = opts?.contents ?? operations.zero(TouchingPitch.schema.contents);
  }
}

export type SoundingPitchAttributes = Record<string, unknown>;

export type SoundingPitchContents = [];

/**
 * The `<sounding-pitch>` element
 *
 * Parent element: `<harmonic>`
 *
 * The presence of the `<sounding-pitch>` element indicates this is the pitch which is heard when playing the harmonic.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sounding-pitch/}
 */
export class SoundingPitch implements XMLElement<'sounding-pitch', SoundingPitchAttributes, SoundingPitchContents> {
  static readonly schema = { name: 'sounding-pitch', attributes: {}, contents: [] } as const;

  readonly schema = SoundingPitch.schema;

  attributes: SoundingPitchAttributes;
  contents: SoundingPitchContents;

  constructor(opts?: { attributes?: Partial<SoundingPitchAttributes>; contents?: SoundingPitchContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SoundingPitch.schema);
    this.contents = opts?.contents ?? operations.zero(SoundingPitch.schema.contents);
  }
}

export type HarmonicAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type HarmonicContents = [Array<Natural | Artificial>, Array<BasePitch | TouchingPitch | SoundingPitch>];

/**
 * The `<harmonic>` element
 *
 * Parent element: `<technical>`
 *
 * The `<harmonic>` element indicates natural and artificial harmonics. Allowing the type of pitch to be specified,
 * combined with controls for appearance/playback differences, allows both the notation and the sound to be represented.
 * Artificial harmonics can add a notated touching pitch; artificial pinch harmonics will usually not notate a touching
 * pitch. The attributes for the `<harmonic>` element refer to the use of the circular harmonic symbol, typically but
 * not always used with natural harmonics.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmonic/}
 */
export class Harmonic implements XMLElement<'harmonic', HarmonicAttributes, HarmonicContents> {
  static readonly schema = {
    name: 'harmonic',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'label',
        label: 'types',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Natural, Artificial] } },
      },
      {
        type: 'label',
        label: 'pitches',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [BasePitch, TouchingPitch, SoundingPitch] } },
      },
    ],
  } as const;

  readonly schema = Harmonic.schema;

  attributes: HarmonicAttributes;
  contents: HarmonicContents;

  constructor(opts?: { attributes?: Partial<HarmonicAttributes>; contents?: HarmonicContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Harmonic.schema);
    this.contents = opts?.contents ?? operations.zero(Harmonic.schema.contents);
  }
  /** Gets @type {HarmonicAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HarmonicAttributes['color']}. */
  setColor(color: string | null): Harmonic {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HarmonicAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HarmonicAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Harmonic {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HarmonicAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HarmonicAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Harmonic {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HarmonicAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HarmonicAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Harmonic {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HarmonicAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HarmonicAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Harmonic {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HarmonicAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HarmonicAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Harmonic {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HarmonicAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HarmonicAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Harmonic {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HarmonicAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HarmonicAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Harmonic {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HarmonicAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {HarmonicAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Harmonic {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {HarmonicAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HarmonicAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Harmonic {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HarmonicAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HarmonicAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Harmonic {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {Array<Natural | Artificial>}. */
  getTypes(): Array<Natural | Artificial> {
    return this.contents[0];
  }
  /** Sets @type {Array<Natural | Artificial>}. */
  setTypes(types: Array<Natural | Artificial>): this {
    this.contents[0] = types;
    return this;
  }
  /** Gets @type {Array<BasePitch | TouchingPitch | SoundingPitch>}. */
  getPitches(): Array<BasePitch | TouchingPitch | SoundingPitch> {
    return this.contents[1];
  }
  /** Sets @type {Array<BasePitch | TouchingPitch | SoundingPitch>}. */
  setPitches(pitches: Array<BasePitch | TouchingPitch | SoundingPitch>): this {
    this.contents[1] = pitches;
    return this;
  }
}

export type OpenStringAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type OpenStringContents = [];

/**
 * The `<open-string>`   element
 *
 * Parent element: `<technical>`
 *
 * The `<open-string>` element represents the zero-shaped open string symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/open-string/}
 */
export class OpenString implements XMLElement<'open-string', OpenStringAttributes, OpenStringContents> {
  static readonly schema = {
    name: 'open-string',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = OpenString.schema;

  attributes: OpenStringAttributes;
  contents: OpenStringContents;

  constructor(opts?: { attributes?: Partial<OpenStringAttributes>; contents?: OpenStringContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OpenString.schema);
    this.contents = opts?.contents ?? operations.zero(OpenString.schema.contents);
  }
  /** Gets @type {OpenStringAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OpenStringAttributes['color']}. */
  setColor(color: string | null): OpenString {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OpenStringAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OpenStringAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): OpenString {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OpenStringAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OpenStringAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): OpenString {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OpenStringAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {OpenStringAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): OpenString {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {OpenStringAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {OpenStringAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OpenString {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {OpenStringAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {OpenStringAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OpenString {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {OpenStringAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {OpenStringAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OpenString {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {OpenStringAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {OpenStringAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): OpenString {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {OpenStringAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OpenStringAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): OpenString {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OpenStringAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OpenStringAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): OpenString {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type ThumbPositionAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type ThumbPositionContents = [];

/**
 * The `<thumb-position>` element
 *
 * Parent element: `<technical>`
 *
 * The `<thumb-position>` element represents the thumb position symbol. This is a circle with a line, where the line
 * does not come within the circle. It is distinct from the `<snap-pizzicato>` symbol, where the line comes inside the
 * circle.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/thumb-position/}
 */
export class ThumbPosition implements XMLElement<'thumb-position', ThumbPositionAttributes, ThumbPositionContents> {
  static readonly schema = {
    name: 'thumb-position',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = ThumbPosition.schema;

  attributes: ThumbPositionAttributes;
  contents: ThumbPositionContents;

  constructor(opts?: { attributes?: Partial<ThumbPositionAttributes>; contents?: ThumbPositionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ThumbPosition.schema);
    this.contents = opts?.contents ?? operations.zero(ThumbPosition.schema.contents);
  }
  /** Gets @type {ThumbPositionAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ThumbPositionAttributes['color']}. */
  setColor(color: string | null): ThumbPosition {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ThumbPositionAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): ThumbPosition {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ThumbPositionAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): ThumbPosition {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {ThumbPositionAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): ThumbPosition {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {ThumbPositionAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): ThumbPosition {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {ThumbPositionAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): ThumbPosition {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {ThumbPositionAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): ThumbPosition {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {ThumbPositionAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): ThumbPosition {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ThumbPositionAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): ThumbPosition {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ThumbPositionAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ThumbPositionAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): ThumbPosition {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type FingeringAttributes = {
  /**
   * Indicates that this is an alternate fingering. It is no if not present.
   */
  alternate: 'yes' | 'no' | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates that this fingering is a substitution in the middle of a note. It is no if not present.
   */
  substitution: 'yes' | 'no' | null;
};

export type FingeringContents = [string];

/**
 * The `<fingering>` element
 *
 * Parent elements: `<frame-note>`, `<technical>`
 *
 * Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be given, typically to substitute fingerings in
 * the middle of a note. For guitar and other fretted instruments, the `<fingering>` element represents the fretting
 * finger; the `<pluck>` element represents the plucking finger.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fingering/}
 */
export class Fingering implements XMLElement<'fingering', FingeringAttributes, FingeringContents> {
  static readonly schema = {
    name: 'fingering',
    attributes: {
      alternate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = Fingering.schema;

  attributes: FingeringAttributes;
  contents: FingeringContents;

  constructor(opts?: { attributes?: Partial<FingeringAttributes>; contents?: FingeringContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fingering.schema);
    this.contents = opts?.contents ?? operations.zero(Fingering.schema.contents);
  }
  /** Gets @type {FingeringAttributes['alternate']}. */
  getAlternate(): 'yes' | 'no' | null {
    return this.attributes['alternate'];
  }
  /** Sets @type {FingeringAttributes['alternate']}. */
  setAlternate(alternate: 'yes' | 'no' | null): Fingering {
    this.attributes['alternate'] = alternate;
    return this;
  }
  /** Gets @type {FingeringAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FingeringAttributes['color']}. */
  setColor(color: string | null): Fingering {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FingeringAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FingeringAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Fingering {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FingeringAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FingeringAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Fingering {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FingeringAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FingeringAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Fingering {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FingeringAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FingeringAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fingering {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FingeringAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FingeringAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fingering {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FingeringAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FingeringAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fingering {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FingeringAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {FingeringAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Fingering {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {FingeringAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FingeringAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Fingering {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FingeringAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FingeringAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Fingering {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {FingeringAttributes['substitution']}. */
  getSubstitution(): 'yes' | 'no' | null {
    return this.attributes['substitution'];
  }
  /** Sets @type {FingeringAttributes['substitution']}. */
  setSubstitution(substitution: 'yes' | 'no' | null): Fingering {
    this.attributes['substitution'] = substitution;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type PluckAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type PluckContents = [string];

/**
 * The `<pluck>` element
 *
 * Parent element: `<technical>`
 *
 * The `<pluck>` element is used to specify the plucking fingering on a fretted instrument, where the fingering element
 * refers to the fretting fingering. Typical values are p, i, m, a for pulgar/thumb, indicio/index, medio/middle, and
 * anular/ring fingers.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pluck/}
 */
export class Pluck implements XMLElement<'pluck', PluckAttributes, PluckContents> {
  static readonly schema = {
    name: 'pluck',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Pluck.schema;

  attributes: PluckAttributes;
  contents: PluckContents;

  constructor(opts?: { attributes?: Partial<PluckAttributes>; contents?: PluckContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pluck.schema);
    this.contents = opts?.contents ?? operations.zero(Pluck.schema.contents);
  }
  /** Gets @type {PluckAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PluckAttributes['color']}. */
  setColor(color: string | null): Pluck {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PluckAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PluckAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Pluck {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PluckAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PluckAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Pluck {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PluckAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PluckAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Pluck {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PluckAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PluckAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Pluck {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PluckAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PluckAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Pluck {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PluckAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PluckAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Pluck {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PluckAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {PluckAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Pluck {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {PluckAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PluckAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Pluck {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PluckAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PluckAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Pluck {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type DoubleTongueAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type DoubleTongueContents = [];

/**
 * The `<double-tongue>` element
 *
 * Parent element: `<technical>`
 *
 * The `<double-tongue>` element represents the double tongue symbol (two dots arranged horizontally).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/double-tongue/}
 */
export class DoubleTongue implements XMLElement<'double-tongue', DoubleTongueAttributes, DoubleTongueContents> {
  static readonly schema = {
    name: 'double-tongue',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = DoubleTongue.schema;

  attributes: DoubleTongueAttributes;
  contents: DoubleTongueContents;

  constructor(opts?: { attributes?: Partial<DoubleTongueAttributes>; contents?: DoubleTongueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DoubleTongue.schema);
    this.contents = opts?.contents ?? operations.zero(DoubleTongue.schema.contents);
  }
  /** Gets @type {DoubleTongueAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DoubleTongueAttributes['color']}. */
  setColor(color: string | null): DoubleTongue {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DoubleTongueAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DoubleTongue {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DoubleTongueAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DoubleTongue {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DoubleTongueAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DoubleTongue {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DoubleTongueAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DoubleTongue {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DoubleTongueAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DoubleTongue {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DoubleTongueAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DoubleTongue {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DoubleTongueAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): DoubleTongue {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DoubleTongueAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DoubleTongue {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DoubleTongueAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DoubleTongueAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DoubleTongue {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type TripleTongueAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type TripleTongueContents = [];

/**
 * The `<triple-tongue>` element
 *
 * Parent element: `<technical>`
 *
 * The `<triple-tongue>` element represents the triple tongue symbol (three dots arranged horizontally).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/triple-tongue/}
 */
export class TripleTongue implements XMLElement<'triple-tongue', TripleTongueAttributes, TripleTongueContents> {
  static readonly schema = {
    name: 'triple-tongue',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = TripleTongue.schema;

  attributes: TripleTongueAttributes;
  contents: TripleTongueContents;

  constructor(opts?: { attributes?: Partial<TripleTongueAttributes>; contents?: TripleTongueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TripleTongue.schema);
    this.contents = opts?.contents ?? operations.zero(TripleTongue.schema.contents);
  }
  /** Gets @type {TripleTongueAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TripleTongueAttributes['color']}. */
  setColor(color: string | null): TripleTongue {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TripleTongueAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): TripleTongue {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TripleTongueAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): TripleTongue {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TripleTongueAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): TripleTongue {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TripleTongueAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): TripleTongue {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TripleTongueAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): TripleTongue {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TripleTongueAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): TripleTongue {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TripleTongueAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): TripleTongue {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TripleTongueAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): TripleTongue {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TripleTongueAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TripleTongueAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): TripleTongue {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type StoppedAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type StoppedContents = [];

/**
 * The `<stopped>` element
 *
 * Parent element: `<technical>`
 *
 * The `<stopped>` element represents the stopped symbol, which looks like a plus sign. The smufl attribute
 * distinguishes different Standard Music Font Layout (SMuFL) glyphs that have a similar appearance such as
 * handbellsMalletBellSuspended and guitarClosePedal. If not present, the default glyph is brassMuteClosed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stopped/}
 */
export class Stopped implements XMLElement<'stopped', StoppedAttributes, StoppedContents> {
  static readonly schema = {
    name: 'stopped',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Stopped.schema;

  attributes: StoppedAttributes;
  contents: StoppedContents;

  constructor(opts?: { attributes?: Partial<StoppedAttributes>; contents?: StoppedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stopped.schema);
    this.contents = opts?.contents ?? operations.zero(Stopped.schema.contents);
  }
  /** Gets @type {StoppedAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StoppedAttributes['color']}. */
  setColor(color: string | null): Stopped {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StoppedAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StoppedAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Stopped {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StoppedAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StoppedAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Stopped {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StoppedAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StoppedAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Stopped {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StoppedAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StoppedAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Stopped {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StoppedAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StoppedAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Stopped {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StoppedAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StoppedAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Stopped {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StoppedAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {StoppedAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Stopped {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {StoppedAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StoppedAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Stopped {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StoppedAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StoppedAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Stopped {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SnapPizzicatoAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type SnapPizzicatoContents = [];

/**
 * The `<snap-pizzicato>` element
 *
 * Parent element: `<technical>`
 *
 * The `<snap-pizzicato>` element represents the snap pizzicato symbol. This is a circle with a line, where the line
 * comes inside the circle. It is distinct from the `<thumb-position>` symbol, where the line does not come inside the
 * circle.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/snap-pizzicato/}
 */
export class SnapPizzicato implements XMLElement<'snap-pizzicato', SnapPizzicatoAttributes, SnapPizzicatoContents> {
  static readonly schema = {
    name: 'snap-pizzicato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = SnapPizzicato.schema;

  attributes: SnapPizzicatoAttributes;
  contents: SnapPizzicatoContents;

  constructor(opts?: { attributes?: Partial<SnapPizzicatoAttributes>; contents?: SnapPizzicatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SnapPizzicato.schema);
    this.contents = opts?.contents ?? operations.zero(SnapPizzicato.schema.contents);
  }
  /** Gets @type {SnapPizzicatoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SnapPizzicatoAttributes['color']}. */
  setColor(color: string | null): SnapPizzicato {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SnapPizzicatoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): SnapPizzicato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SnapPizzicatoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): SnapPizzicato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SnapPizzicatoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): SnapPizzicato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SnapPizzicatoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): SnapPizzicato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SnapPizzicatoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): SnapPizzicato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SnapPizzicatoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): SnapPizzicato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {SnapPizzicatoAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): SnapPizzicato {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SnapPizzicatoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): SnapPizzicato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SnapPizzicatoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SnapPizzicatoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): SnapPizzicato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type FretAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
};

export type FretContents = [number];

/**
 * The `<fret>` element
 *
 * Parent elements: `<frame-note>`, `<technical>`
 *
 * The `<fret>` element is used with tablature notation and chord diagrams. Fret numbers start with 0 for an open string
 * and 1 for the first fret.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fret/}
 */
export class Fret implements XMLElement<'fret', FretAttributes, FretContents> {
  static readonly schema = {
    name: 'fret',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Fret.schema;

  attributes: FretAttributes;
  contents: FretContents;

  constructor(opts?: { attributes?: Partial<FretAttributes>; contents?: FretContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fret.schema);
    this.contents = opts?.contents ?? operations.zero(Fret.schema.contents);
  }
  /** Gets @type {FretAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FretAttributes['color']}. */
  setColor(color: string | null): Fret {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FretAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FretAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Fret {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FretAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FretAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fret {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FretAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FretAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fret {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FretAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FretAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fret {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type StringAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type StringContents = [number];

/**
 * The `<string>` element
 *
 * Parent elements: `<frame-note>`, `<technical>`
 *
 * The `<string>` element is used with tablature notation, regular notation (where it is often circled), and chord
 * diagrams. String numbers start with 1 for the highest pitched full-length string.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/string/}
 */
export class String implements XMLElement<'string', StringAttributes, StringContents> {
  static readonly schema = {
    name: 'string',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'label', label: 'string-number', value: { type: 'int', min: 1, max: Infinity } }],
  } as const;

  readonly schema = String.schema;

  attributes: StringAttributes;
  contents: StringContents;

  constructor(opts?: { attributes?: Partial<StringAttributes>; contents?: StringContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, String.schema);
    this.contents = opts?.contents ?? operations.zero(String.schema.contents);
  }
  /** Gets @type {StringAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StringAttributes['color']}. */
  setColor(color: string | null): String {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StringAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StringAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): String {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StringAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StringAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): String {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StringAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StringAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): String {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StringAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StringAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): String {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StringAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StringAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): String {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StringAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StringAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): String {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StringAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {StringAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): String {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {StringAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StringAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): String {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StringAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StringAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): String {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {number}. */
  getStringNumber(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setStringNumber(stringNumber: number): this {
    this.contents[0] = stringNumber;
    return this;
  }
}

export type HammerOnAttributes = {
  /**
   * Indicates if this is the start or stop of the hammer-on.
   */
  type: 'start' | 'stop';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Distinguishes multiple hammer-ons when they overlap in MusicXML document order. The default value is 1.
   */
  number: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type HammerOnContents = [string];

/**
 * The `<hammer-on>` element
 *
 * Parent element: `<technical>`
 *
 * The `<hammer-on>` element is used in guitar and fretted instrument notation. Since a single slur can be marked over many notes, the `<hammer-on>` element is separate so the individual pair of notes can be specified. The element content can be used to specify how the `<hammer-on>` should be notated. An empty element leaves this choice up to the application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hammer-on/}
 */
export class HammerOn implements XMLElement<'hammer-on', HammerOnAttributes, HammerOnContents> {
  static readonly schema = {
    name: 'hammer-on',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = HammerOn.schema;

  attributes: HammerOnAttributes;
  contents: HammerOnContents;

  constructor(opts?: { attributes?: Partial<HammerOnAttributes>; contents?: HammerOnContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HammerOn.schema);
    this.contents = opts?.contents ?? operations.zero(HammerOn.schema.contents);
  }
  /** Gets @type {HammerOnAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {HammerOnAttributes['type']}. */
  setType(type: 'start' | 'stop'): HammerOn {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {HammerOnAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HammerOnAttributes['color']}. */
  setColor(color: string | null): HammerOn {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HammerOnAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HammerOnAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): HammerOn {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HammerOnAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HammerOnAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): HammerOn {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HammerOnAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HammerOnAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): HammerOn {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HammerOnAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HammerOnAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HammerOn {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HammerOnAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HammerOnAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HammerOn {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HammerOnAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HammerOnAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HammerOn {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HammerOnAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {HammerOnAttributes['number']}. */
  setNumber(number: number | null): HammerOn {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {HammerOnAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HammerOnAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): HammerOn {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HammerOnAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HammerOnAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): HammerOn {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HammerOnAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HammerOnAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): HammerOn {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type PullOffAttributes = {
  /**
   * Indicates if this is the start or stop of the hammer-on.
   */
  type: 'start' | 'stop';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates if this is the start or stop of the pull-off. The default value is 1.
   */
  number: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type PullOffContents = [string];

/**
 * The `<pull-off>` element
 *
 * Parent element: `<technical>`
 *
 * The `<pull-off>` element is used in guitar and fretted instrument notation. Since a single slur can be marked over
 * many notes, the `<pull-off>` element is separate so the individual pair of notes can be specified. The element
 * content can be used to specify how the `<pull-off>` should be notated. An empty element leaves this choice up to the
 * application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pull-off/}
 */
export class PullOff implements XMLElement<'pull-off', PullOffAttributes, PullOffContents> {
  static readonly schema = {
    name: 'pull-off',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = PullOff.schema;

  attributes: PullOffAttributes;
  contents: PullOffContents;

  constructor(opts?: { attributes?: Partial<PullOffAttributes>; contents?: PullOffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PullOff.schema);
    this.contents = opts?.contents ?? operations.zero(PullOff.schema.contents);
  }
  /** Gets @type {PullOffAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {PullOffAttributes['type']}. */
  setType(type: 'start' | 'stop'): PullOff {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {PullOffAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PullOffAttributes['color']}. */
  setColor(color: string | null): PullOff {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PullOffAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PullOffAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): PullOff {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PullOffAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PullOffAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): PullOff {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PullOffAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PullOffAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): PullOff {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PullOffAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PullOffAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PullOff {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PullOffAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PullOffAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PullOff {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PullOffAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PullOffAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PullOff {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PullOffAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {PullOffAttributes['number']}. */
  setNumber(number: number | null): PullOff {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {PullOffAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {PullOffAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): PullOff {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {PullOffAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PullOffAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): PullOff {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PullOffAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PullOffAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): PullOff {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type BendAlterAttributes = Record<string, unknown>;

export type BendAlterContents = [number];

/**
 * The `<bend-alter>` element
 *
 * Parent element: `<bend>`
 *
 * The `<bend-alter>` element indicates the number of semitones in the bend, similar to the `<alter>` element. As with
 * the `<alter>` element, numbers like 0.5 can be used to indicate microtones. Negative values indicate pre-bends or
 * releases. The `<pre-bend>` and `<release>` elements are used to distinguish what is intended. Because the
 * `<bend-alter>` element represents the number of steps in the bend, a release after a bend has a negative
 * `<bend-alter>` value, not a zero value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bend-alter/}
 */
export class BendAlter implements XMLElement<'bend-alter', BendAlterAttributes, BendAlterContents> {
  static readonly schema = {
    name: 'bend-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = BendAlter.schema;

  attributes: BendAlterAttributes;
  contents: BendAlterContents;

  constructor(opts?: { attributes?: Partial<BendAlterAttributes>; contents?: BendAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BendAlter.schema);
    this.contents = opts?.contents ?? operations.zero(BendAlter.schema.contents);
  }

  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type PreBendAttributes = Record<string, unknown>;

export type PreBendContents = [];

/**
 * The `<pre-bend> element
 *
 * Parent element: `<bend>
 *
 * The `<pre-bend> element indicates that a bend is a pre-bend rather than a normal bend or a release.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pre-bend/}
 */
export class PreBend implements XMLElement<'pre-bend', PreBendAttributes, PreBendContents> {
  static readonly schema = { name: 'pre-bend', attributes: {}, contents: [] } as const;

  readonly schema = PreBend.schema;

  attributes: PreBendAttributes;
  contents: PreBendContents;

  constructor(opts?: { attributes?: Partial<PreBendAttributes>; contents?: PreBendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PreBend.schema);
    this.contents = opts?.contents ?? operations.zero(PreBend.schema.contents);
  }
}

export type ReleaseAttributes = {
  /**
   * Specifies where the release starts in terms of divisions relative to the current note.
   */
  offset: number | null;
};

export type ReleaseContents = [];

/**
 * The `<release>` element
 *
 * Parent element: `<bend>`
 *
 * The `<release>` element indicates that a bend is a release rather than a normal bend or pre-bend. The first-beat and
 * last-beat attributes of the parent `<bend>` element are relative to the original note position, not this offset
 * value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/release/}
 */
export class Release implements XMLElement<'release', ReleaseAttributes, ReleaseContents> {
  static readonly schema = {
    name: 'release',
    attributes: { offset: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } } },
    contents: [],
  } as const;

  readonly schema = Release.schema;

  attributes: ReleaseAttributes;
  contents: ReleaseContents;

  constructor(opts?: { attributes?: Partial<ReleaseAttributes>; contents?: ReleaseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Release.schema);
    this.contents = opts?.contents ?? operations.zero(Release.schema.contents);
  }
  /** Gets @type {ReleaseAttributes['offset']}. */
  getOffset(): number | null {
    return this.attributes['offset'];
  }
  /** Sets @type {ReleaseAttributes['offset']}. */
  setOffset(offset: number | null): Release {
    this.attributes['offset'] = offset;
    return this;
  }
}

export type WithBarAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The percentage of the duration for starting a bend. Default is 25.
   */
  'first-beat': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type WithBarContents = [string];

/**
 * The `<with-bar>` element
 *
 * Parent element: `<bend>`
 *
 * The `<with-bar>` element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The
 * content of the element indicates how this should be notated. Content values of "scoop" and "dip" refer to the
 * Standard Music Font Layout (SMuFL) guitarVibratoBarScoop and guitarVibratoBarDip glyphs.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/with-bar/}
 */
export class WithBar implements XMLElement<'with-bar', WithBarAttributes, WithBarContents> {
  static readonly schema = {
    name: 'with-bar',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = WithBar.schema;

  attributes: WithBarAttributes;
  contents: WithBarContents;

  constructor(opts?: { attributes?: Partial<WithBarAttributes>; contents?: WithBarContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, WithBar.schema);
    this.contents = opts?.contents ?? operations.zero(WithBar.schema.contents);
  }
  /** Gets @type {WithBarAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {WithBarAttributes['color']}. */
  setColor(color: string | null): WithBar {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {WithBarAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {WithBarAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): WithBar {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {WithBarAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {WithBarAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): WithBar {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {WithBarAttributes['first-beat']}. */
  getFirstBeat(): number | null {
    return this.attributes['first-beat'];
  }
  /** Sets @type {WithBarAttributes['first-beat']}. */
  setFirstBeat(firstBeat: number | null): WithBar {
    this.attributes['first-beat'] = firstBeat;
    return this;
  }
  /** Gets @type {WithBarAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {WithBarAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): WithBar {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {WithBarAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {WithBarAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): WithBar {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {WithBarAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {WithBarAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): WithBar {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {WithBarAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {WithBarAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): WithBar {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {WithBarAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {WithBarAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): WithBar {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {WithBarAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {WithBarAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): WithBar {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {WithBarAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {WithBarAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): WithBar {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type BendAttributes = {
  /**
   * Does the bend accelerate during playback? Default is "no".
   */
  accelerate: 'yes' | 'no' | null;
  /**
   * The number of discrete elements (like MIDI pitch bends) used to represent a continuous bend or slide. Default
   * is 4.
   */
  beats: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The percentage of the duration for starting a bend. Default is 25.
   */
  'first-beat': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The percentage of the duration for ending a bend. Default is 75.
   */
  'last-beat': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Distinguishes between the angled bend symbols commonly used in standard notation and the curved bend symbols
   * commonly used in both tablature and standard notation.
   */
  shape: 'angled' | 'curved' | null;
};

export type BendContents = [BendAlter, Array<PreBend | Release>, WithBar | null];

/**
 * The `<bend>` element
 *
 * Parent element: `<technical>`
 *
 * The `<bend>` element is used in guitar notation and tablature. A single note with a bend and release will contain two
 * `<bend>` elements: the first to represent the bend and the second to represent the release.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bend/}
 */
export class Bend implements XMLElement<'bend', BendAttributes, BendContents> {
  static readonly schema = {
    name: 'bend',
    attributes: {
      accelerate: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      beats: { type: 'optional', value: { type: 'float', min: 2, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'first-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'last-beat': { type: 'optional', value: { type: 'float', min: 0, max: 100 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      shape: { type: 'optional', value: { type: 'choices', choices: ['angled', 'curved'] } },
    },
    contents: [
      { type: 'required', value: BendAlter },
      {
        type: 'label',
        label: 'bends',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [PreBend, Release] } },
      },
      { type: 'optional', value: WithBar },
    ],
  } as const;

  readonly schema = Bend.schema;

  attributes: BendAttributes;
  contents: BendContents;

  constructor(opts?: { attributes?: Partial<BendAttributes>; contents?: BendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bend.schema);
    this.contents = opts?.contents ?? operations.zero(Bend.schema.contents);
  }
  /** Gets @type {BendAttributes['accelerate']}. */
  getAccelerate(): 'yes' | 'no' | null {
    return this.attributes['accelerate'];
  }
  /** Sets @type {BendAttributes['accelerate']}. */
  setAccelerate(accelerate: 'yes' | 'no' | null): Bend {
    this.attributes['accelerate'] = accelerate;
    return this;
  }
  /** Gets @type {BendAttributes['beats']}. */
  getBeats(): number | null {
    return this.attributes['beats'];
  }
  /** Sets @type {BendAttributes['beats']}. */
  setBeats(beats: number | null): Bend {
    this.attributes['beats'] = beats;
    return this;
  }
  /** Gets @type {BendAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BendAttributes['color']}. */
  setColor(color: string | null): Bend {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BendAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {BendAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Bend {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {BendAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {BendAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Bend {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {BendAttributes['first-beat']}. */
  getFirstBeat(): number | null {
    return this.attributes['first-beat'];
  }
  /** Sets @type {BendAttributes['first-beat']}. */
  setFirstBeat(firstBeat: number | null): Bend {
    this.attributes['first-beat'] = firstBeat;
    return this;
  }
  /** Gets @type {BendAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {BendAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Bend {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {BendAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {BendAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Bend {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {BendAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {BendAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Bend {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {BendAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {BendAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Bend {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {BendAttributes['last-beat']}. */
  getLastBeat(): number | null {
    return this.attributes['last-beat'];
  }
  /** Sets @type {BendAttributes['last-beat']}. */
  setLastBeat(lastBeat: number | null): Bend {
    this.attributes['last-beat'] = lastBeat;
    return this;
  }
  /** Gets @type {BendAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {BendAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Bend {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {BendAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {BendAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Bend {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {BendAttributes['shape']}. */
  getShape(): 'angled' | 'curved' | null {
    return this.attributes['shape'];
  }
  /** Sets @type {BendAttributes['shape']}. */
  setShape(shape: 'angled' | 'curved' | null): Bend {
    this.attributes['shape'] = shape;
    return this;
  }
  /** Gets @type {BendAlter}. */
  getBendAlter(): BendAlter {
    return this.contents[0];
  }
  /** Sets @type {BendAlter}. */
  setBendAlter(bendAlter: BendAlter): this {
    this.contents[0] = bendAlter;
    return this;
  }
  /** Gets @type {Array<PreBend | Release>}. */
  getBends(): Array<PreBend | Release> {
    return this.contents[1];
  }
  /** Sets @type {Array<PreBend | Release>}. */
  setBends(bends: Array<PreBend | Release>): this {
    this.contents[1] = bends;
    return this;
  }
  /** Gets @type {WithBar | null}. */
  getWithBar(): WithBar | null {
    return this.contents[2];
  }
  /** Sets @type {WithBar | null}. */
  setWithBar(withBar: WithBar | null): this {
    this.contents[2] = withBar;
    return this;
  }
}

export type TapAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies the symbol to use If the element is empty. It is ignored if the tap glyph is already specified by the
   * element content. If neither element content nor the hand attribute are present, the display is
   * application-specific.
   */
  hand: 'left' | 'right' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type TapContents = [string | null];

/**
 * The `<tap>` element
 *
 * Parent element: `<technical>`
 *
 * The `<tap>` element indicates a tap on the fretboard. The element content allows specification of the notation; + and
 * T are common choices.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tap/}
 */
export class Tap implements XMLElement<'tap', TapAttributes, TapContents> {
  static readonly schema = {
    name: 'tap',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      hand: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = Tap.schema;

  attributes: TapAttributes;
  contents: TapContents;

  constructor(opts?: { attributes?: Partial<TapAttributes>; contents?: TapContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tap.schema);
    this.contents = opts?.contents ?? operations.zero(Tap.schema.contents);
  }
  /** Gets @type {TapAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TapAttributes['color']}. */
  setColor(color: string | null): Tap {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TapAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TapAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Tap {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TapAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TapAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Tap {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TapAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TapAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Tap {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TapAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TapAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Tap {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TapAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TapAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Tap {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TapAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TapAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Tap {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TapAttributes['hand']}. */
  getHand(): 'left' | 'right' | null {
    return this.attributes['hand'];
  }
  /** Sets @type {TapAttributes['hand']}. */
  setHand(hand: 'left' | 'right' | null): Tap {
    this.attributes['hand'] = hand;
    return this;
  }
  /** Gets @type {TapAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TapAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Tap {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TapAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TapAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Tap {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TapAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TapAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Tap {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string | null}. */
  getText(): string | null {
    return this.contents[0];
  }
  /** Sets @type {string | null}. */
  setText(text: string | null): this {
    this.contents[0] = text;
    return this;
  }
}

export type HeelAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates that this is a substitution in the middle of a note. It is no if not present.
   */
  substitution: 'yes' | 'no' | null;
};

export type HeelContents = [];

/**
 * The `<heel>` element
 *
 * Parent element: `<technical>`
 *
 * The `<heel>` element is used with organ pedals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/heel/}
 */
export class Heel implements XMLElement<'heel', HeelAttributes, HeelContents> {
  static readonly schema = {
    name: 'heel',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Heel.schema;

  attributes: HeelAttributes;
  contents: HeelContents;

  constructor(opts?: { attributes?: Partial<HeelAttributes>; contents?: HeelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Heel.schema);
    this.contents = opts?.contents ?? operations.zero(Heel.schema.contents);
  }
  /** Gets @type {HeelAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HeelAttributes['color']}. */
  setColor(color: string | null): Heel {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HeelAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HeelAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Heel {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HeelAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HeelAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Heel {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HeelAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HeelAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Heel {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HeelAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HeelAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Heel {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HeelAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HeelAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Heel {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HeelAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HeelAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Heel {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HeelAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HeelAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Heel {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HeelAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HeelAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Heel {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HeelAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HeelAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Heel {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {HeelAttributes['substitution']}. */
  getSubstitution(): 'yes' | 'no' | null {
    return this.attributes['substitution'];
  }
  /** Sets @type {HeelAttributes['substitution']}. */
  setSubstitution(substitution: 'yes' | 'no' | null): Heel {
    this.attributes['substitution'] = substitution;
    return this;
  }
}

export type ToeAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates that this is a substitution in the middle of a note. It is no if not present.
   */
  substitution: 'yes' | 'no' | null;
};

export type ToeContents = [];

/**
 * The `<toe>` element
 *
 * Parent element: `<technical>`
 *
 * The `<toe>` element is used with organ pedals.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/toe/}
 */
export class Toe implements XMLElement<'toe', ToeAttributes, ToeContents> {
  static readonly schema = {
    name: 'toe',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      substitution: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Toe.schema;

  attributes: ToeAttributes;
  contents: ToeContents;

  constructor(opts?: { attributes?: Partial<ToeAttributes>; contents?: ToeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Toe.schema);
    this.contents = opts?.contents ?? operations.zero(Toe.schema.contents);
  }
  /** Gets @type {ToeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ToeAttributes['color']}. */
  setColor(color: string | null): Toe {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ToeAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ToeAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Toe {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ToeAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ToeAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Toe {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ToeAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {ToeAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Toe {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {ToeAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {ToeAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Toe {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {ToeAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {ToeAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Toe {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {ToeAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {ToeAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Toe {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {ToeAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {ToeAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Toe {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {ToeAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ToeAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Toe {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ToeAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ToeAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Toe {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {ToeAttributes['substitution']}. */
  getSubstitution(): 'yes' | 'no' | null {
    return this.attributes['substitution'];
  }
  /** Sets @type {ToeAttributes['substitution']}. */
  setSubstitution(substitution: 'yes' | 'no' | null): Toe {
    this.attributes['substitution'] = substitution;
    return this;
  }
}

export type FingernailsAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type FingernailsContents = [];

/**
 * The `<fingernails>` element
 *
 * Parent element: `<technical>`
 *
 * The `<fingernails>` element is used in notation for harp and other plucked string instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fingernails/}
 */
export class Fingernails implements XMLElement<'fingernails', FingernailsAttributes, FingernailsContents> {
  static readonly schema = {
    name: 'fingernails',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Fingernails.schema;

  attributes: FingernailsAttributes;
  contents: FingernailsContents;

  constructor(opts?: { attributes?: Partial<FingernailsAttributes>; contents?: FingernailsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fingernails.schema);
    this.contents = opts?.contents ?? operations.zero(Fingernails.schema.contents);
  }
  /** Gets @type {FingernailsAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FingernailsAttributes['color']}. */
  setColor(color: string | null): Fingernails {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FingernailsAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FingernailsAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Fingernails {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FingernailsAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FingernailsAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Fingernails {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FingernailsAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FingernailsAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Fingernails {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FingernailsAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FingernailsAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fingernails {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FingernailsAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FingernailsAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fingernails {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FingernailsAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FingernailsAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fingernails {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FingernailsAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {FingernailsAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Fingernails {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {FingernailsAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FingernailsAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Fingernails {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FingernailsAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FingernailsAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Fingernails {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type HoleTypeAttributes = Record<string, unknown>;

export type HoleTypeContents = [string];

/**
 * The `<hole-type>` element
 *
 * Parent element: `<hole>`
 *
 * The content of the `<hole-type>` element indicates what the hole symbol represents in terms of instrument fingering
 * or other techniques.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole-type/}
 */
export class HoleType implements XMLElement<'hole-type', HoleTypeAttributes, HoleTypeContents> {
  static readonly schema = {
    name: 'hole-type',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = HoleType.schema;

  attributes: HoleTypeAttributes;
  contents: HoleTypeContents;

  constructor(opts?: { attributes?: Partial<HoleTypeAttributes>; contents?: HoleTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HoleType.schema);
    this.contents = opts?.contents ?? operations.zero(HoleType.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type HoleClosedAttributes = {
  /**
   * Indicates which portion of the hole is filled in when the element value is half.
   */
  location: 'bottom' | 'left' | 'right' | 'top' | null;
};

export type HoleClosedContents = ['yes' | 'no' | 'half'];

/**
 * The `<hole-closed>` element
 *
 * Parent element: `<hole>`
 *
 * The `<hole-closed>` element represents whether the hole is closed, open, or half-open.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole-closed/}
 */
export class HoleClosed implements XMLElement<'hole-closed', HoleClosedAttributes, HoleClosedContents> {
  static readonly schema = {
    name: 'hole-closed',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['bottom', 'left', 'right', 'top'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'hole-closed-value',
          value: { type: 'choices', choices: ['yes', 'no', 'half'] },
        },
      },
    ],
  } as const;

  readonly schema = HoleClosed.schema;

  attributes: HoleClosedAttributes;
  contents: HoleClosedContents;

  constructor(opts?: { attributes?: Partial<HoleClosedAttributes>; contents?: HoleClosedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HoleClosed.schema);
    this.contents = opts?.contents ?? operations.zero(HoleClosed.schema.contents);
  }
  /** Gets @type {HoleClosedAttributes['location']}. */
  getLocation(): 'bottom' | 'left' | 'right' | 'top' | null {
    return this.attributes['location'];
  }
  /** Sets @type {HoleClosedAttributes['location']}. */
  setLocation(location: 'bottom' | 'left' | 'right' | 'top' | null): HoleClosed {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {'yes' | 'no' | 'half'}. */
  getHoleClosedValue(): 'yes' | 'no' | 'half' {
    return this.contents[0];
  }
  /** Sets @type {'yes' | 'no' | 'half'}. */
  setHoleClosedValue(holeClosedValue: 'yes' | 'no' | 'half'): this {
    this.contents[0] = holeClosedValue;
    return this;
  }
}

export type HoleShapeAttributes = Record<string, unknown>;

export type HoleShapeContents = [string];

/**
 * The `<hole-shape>` element
 *
 * Parent element: `<hole>`
 *
 * The `<hole-shape>` element indicates the shape of the hole symbol. It is a circle if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole-shape/}
 */
export class HoleShape implements XMLElement<'hole-shape', HoleShapeAttributes, HoleShapeContents> {
  static readonly schema = {
    name: 'hole-shape',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = HoleShape.schema;

  attributes: HoleShapeAttributes;
  contents: HoleShapeContents;

  constructor(opts?: { attributes?: Partial<HoleShapeAttributes>; contents?: HoleShapeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HoleShape.schema);
    this.contents = opts?.contents ?? operations.zero(HoleShape.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type HoleAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type HoleContents = [HoleType | null, HoleClosed, HoleShape | null];

/**
 * The `<hole>` element
 *
 * Parent element: `<technical>`
 *
 * The `<hole>` element represents the symbols used for woodwind and brass fingerings as well as other notations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/hole/}
 */
export class Hole implements XMLElement<'hole', HoleAttributes, HoleContents> {
  static readonly schema = {
    name: 'hole',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      { type: 'optional', value: HoleType },
      { type: 'required', value: HoleClosed },
      { type: 'optional', value: HoleShape },
    ],
  } as const;

  readonly schema = Hole.schema;

  attributes: HoleAttributes;
  contents: HoleContents;

  constructor(opts?: { attributes?: Partial<HoleAttributes>; contents?: HoleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Hole.schema);
    this.contents = opts?.contents ?? operations.zero(Hole.schema.contents);
  }
  /** Gets @type {HoleAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HoleAttributes['color']}. */
  setColor(color: string | null): Hole {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HoleAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HoleAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Hole {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HoleAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HoleAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Hole {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HoleAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HoleAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Hole {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HoleAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HoleAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Hole {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HoleAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HoleAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Hole {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HoleAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HoleAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Hole {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HoleAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HoleAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Hole {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HoleAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HoleAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Hole {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HoleAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HoleAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Hole {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {HoleType | null}. */
  getHoleType(): HoleType | null {
    return this.contents[0];
  }
  /** Sets @type {HoleType | null}. */
  setHoleType(holeType: HoleType | null): this {
    this.contents[0] = holeType;
    return this;
  }
  /** Gets @type {HoleClosed}. */
  getHoleClosed(): HoleClosed {
    return this.contents[1];
  }
  /** Sets @type {HoleClosed}. */
  setHoleClosed(holeClosed: HoleClosed): this {
    this.contents[1] = holeClosed;
    return this;
  }
  /** Gets @type {HoleShape | null}. */
  getHoleShape(): HoleShape | null {
    return this.contents[2];
  }
  /** Sets @type {HoleShape | null}. */
  setHoleShape(holeShape: HoleShape | null): this {
    this.contents[2] = holeShape;
    return this;
  }
}

export type ArrowDirectionAttributes = Record<string, unknown>;

export type ArrowDirectionContents = [
  | 'down'
  | 'left'
  | 'left right'
  | 'northeast'
  | 'northeast southwest'
  | 'northwest'
  | 'northwest southeast'
  | 'other'
  | 'right'
  | 'southeast'
  | 'southwest'
  | 'up'
  | 'up down',
];

/**
 * The `<arrow-direction>` element
 *
 * Parent element: `<arrow>`
 *
 * The `<arrow-direction>` element represents the direction in which an arrow points, using Unicode arrow terminology.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrow-direction/}
 */
export class ArrowDirection implements XMLElement<'arrow-direction', ArrowDirectionAttributes, ArrowDirectionContents> {
  static readonly schema = {
    name: 'arrow-direction',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'arrow-direction',
          value: {
            type: 'choices',
            choices: [
              'down',
              'left',
              'left right',
              'northeast',
              'northeast southwest',
              'northwest',
              'northwest southeast',
              'other',
              'right',
              'southeast',
              'southwest',
              'up',
              'up down',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = ArrowDirection.schema;

  attributes: ArrowDirectionAttributes;
  contents: ArrowDirectionContents;

  constructor(opts?: { attributes?: Partial<ArrowDirectionAttributes>; contents?: ArrowDirectionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ArrowDirection.schema);
    this.contents = opts?.contents ?? operations.zero(ArrowDirection.schema.contents);
  }

  /** Gets @type {'down' | 'left' | 'left right' | 'northeast' | 'northeast southwest' | 'northwest' | 'northwest southeast' | 'other' | 'right' | 'southeast' | 'southwest' | 'up' | 'up down'}. */
  getArrowDirection():
    | 'down'
    | 'left'
    | 'left right'
    | 'northeast'
    | 'northeast southwest'
    | 'northwest'
    | 'northwest southeast'
    | 'other'
    | 'right'
    | 'southeast'
    | 'southwest'
    | 'up'
    | 'up down' {
    return this.contents[0];
  }
  /** Sets @type {'down' | 'left' | 'left right' | 'northeast' | 'northeast southwest' | 'northwest' | 'northwest southeast' | 'other' | 'right' | 'southeast' | 'southwest' | 'up' | 'up down'}. */
  setArrowDirection(
    arrowDirection:
      | 'down'
      | 'left'
      | 'left right'
      | 'northeast'
      | 'northeast southwest'
      | 'northwest'
      | 'northwest southeast'
      | 'other'
      | 'right'
      | 'southeast'
      | 'southwest'
      | 'up'
      | 'up down'
  ): this {
    this.contents[0] = arrowDirection;
    return this;
  }
}

export type ArrowStyleAttributes = Record<string, unknown>;

export type ArrowStyleContents = ['combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'];

/**
 * The `<arrow-style>` element
 *
 * Parent element: `<arrow>`
 *
 * The `<arrow-style>` element represents the style of an arrow, using Unicode arrow terminology.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrow-style/}
 */
export class ArrowStyle implements XMLElement<'arrow-style', ArrowStyleAttributes, ArrowStyleContents> {
  static readonly schema = {
    name: 'arrow-style',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'arrow-style',
          value: { type: 'choices', choices: ['combined', 'double', 'filled', 'hollow', 'other', 'paired', 'single'] },
        },
      },
    ],
  } as const;

  readonly schema = ArrowStyle.schema;

  attributes: ArrowStyleAttributes;
  contents: ArrowStyleContents;

  constructor(opts?: { attributes?: Partial<ArrowStyleAttributes>; contents?: ArrowStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ArrowStyle.schema);
    this.contents = opts?.contents ?? operations.zero(ArrowStyle.schema.contents);
  }

  /** Gets @type {'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'}. */
  getArrowStyle(): 'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single' {
    return this.contents[0];
  }
  /** Sets @type {'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'}. */
  setArrowStyle(arrowStyle: 'combined' | 'double' | 'filled' | 'hollow' | 'other' | 'paired' | 'single'): this {
    this.contents[0] = arrowStyle;
    return this;
  }
}

export type ArrowheadAttributes = Record<string, unknown>;

export type ArrowheadContents = [];

/**
 * The `<arrowhead>` element
 *
 * Parent element: `<arrow>`
 *
 * The presence of an `<arrowhead>` element indicates that only the arrowhead is displayed within the `<arrow>`, not the
 * arrow stem.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrowhead/}
 */
export class Arrowhead implements XMLElement<'arrowhead', ArrowheadAttributes, ArrowheadContents> {
  static readonly schema = { name: 'arrowhead', attributes: {}, contents: [] } as const;

  readonly schema = Arrowhead.schema;

  attributes: ArrowheadAttributes;
  contents: ArrowheadContents;

  constructor(opts?: { attributes?: Partial<ArrowheadAttributes>; contents?: ArrowheadContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Arrowhead.schema);
    this.contents = opts?.contents ?? operations.zero(Arrowhead.schema.contents);
  }
}

export type CircularArrowAttributes = Record<string, unknown>;

export type CircularArrowContents = ['anticlockwise' | 'clockwise'];

/**
 * The `<circular-arrow>` element
 *
 * Parent element: `<arrow>`
 *
 * The `<circular-arrow>` element represents a circular arrow, using Unicode arrow terminology to specify the arrow
 * direction.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/circular-arrow/}
 */
export class CircularArrow implements XMLElement<'circular-arrow', CircularArrowAttributes, CircularArrowContents> {
  static readonly schema = {
    name: 'circular-arrow',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'circular-arrow',
          value: { type: 'choices', choices: ['anticlockwise', 'clockwise'] },
        },
      },
    ],
  } as const;

  readonly schema = CircularArrow.schema;

  attributes: CircularArrowAttributes;
  contents: CircularArrowContents;

  constructor(opts?: { attributes?: Partial<CircularArrowAttributes>; contents?: CircularArrowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, CircularArrow.schema);
    this.contents = opts?.contents ?? operations.zero(CircularArrow.schema.contents);
  }

  /** Gets @type {'anticlockwise' | 'clockwise'}. */
  getCircularArrow(): 'anticlockwise' | 'clockwise' {
    return this.contents[0];
  }
  /** Sets @type {'anticlockwise' | 'clockwise'}. */
  setCircularArrow(circularArrow: 'anticlockwise' | 'clockwise'): this {
    this.contents[0] = circularArrow;
    return this;
  }
}

export type ArrowAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type ArrowContents = [ArrowDirection, ArrowStyle | null, Arrowhead | null, CircularArrow | null];

/**
 * The `<arrow>` element
 *
 * Parent element: `<technical>`
 *
 * The `<arrow>` element represents an arrow used for a musical technical indication. It can represent both Unicode and
 * Standard Music Font Layout (SMuFL) arrows. The smufl attribute distinguishes different SMuFL glyphs that have an
 * arrow appearance such as arrowBlackUp, guitarStrumUp, or handbellsSwingUp. The specified glyph should match the
 * descriptive representation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arrow/}
 */
export class Arrow implements XMLElement<'arrow', ArrowAttributes, ArrowContents> {
  static readonly schema = {
    name: 'arrow',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'required', value: ArrowDirection },
      { type: 'optional', value: ArrowStyle },
      { type: 'optional', value: Arrowhead },
      { type: 'optional', value: CircularArrow },
    ],
  } as const;

  readonly schema = Arrow.schema;

  attributes: ArrowAttributes;
  contents: ArrowContents;

  constructor(opts?: { attributes?: Partial<ArrowAttributes>; contents?: ArrowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Arrow.schema);
    this.contents = opts?.contents ?? operations.zero(Arrow.schema.contents);
  }
  /** Gets @type {ArrowAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ArrowAttributes['color']}. */
  setColor(color: string | null): Arrow {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ArrowAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ArrowAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Arrow {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ArrowAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ArrowAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Arrow {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ArrowAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {ArrowAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Arrow {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {ArrowAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {ArrowAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Arrow {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {ArrowAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {ArrowAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Arrow {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {ArrowAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {ArrowAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Arrow {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {ArrowAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {ArrowAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Arrow {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {ArrowAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ArrowAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Arrow {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ArrowAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ArrowAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Arrow {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {ArrowAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {ArrowAttributes['smufl']}. */
  setSmufl(smufl: string | null): Arrow {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {ArrowDirection}. */
  getArrowDirection(): ArrowDirection {
    return this.contents[0];
  }
  /** Sets @type {ArrowDirection}. */
  setArrowDirection(arrowDirection: ArrowDirection): this {
    this.contents[0] = arrowDirection;
    return this;
  }
  /** Gets @type {ArrowStyle | null}. */
  getArrowStyle(): ArrowStyle | null {
    return this.contents[1];
  }
  /** Sets @type {ArrowStyle | null}. */
  setArrowStyle(arrowStyle: ArrowStyle | null): this {
    this.contents[1] = arrowStyle;
    return this;
  }
  /** Gets @type {Arrowhead | null}. */
  getArrowhead(): Arrowhead | null {
    return this.contents[2];
  }
  /** Sets @type {Arrowhead | null}. */
  setArrowhead(arrowhead: Arrowhead | null): this {
    this.contents[2] = arrowhead;
    return this;
  }
  /** Gets @type {CircularArrow | null}. */
  getCircularArrow(): CircularArrow | null {
    return this.contents[3];
  }
  /** Sets @type {CircularArrow | null}. */
  setCircularArrow(circularArrow: CircularArrow | null): this {
    this.contents[3] = circularArrow;
    return this;
  }
}

export type HandbellAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type HandbellContents = [
  | 'belltree'
  | 'damp'
  | 'echo'
  | 'gyro'
  | 'hand martellato'
  | 'mallet lift'
  | 'mallet table'
  | 'martellato'
  | 'martellato lift'
  | 'muted martellato'
  | 'pluck lift'
  | 'swing',
];

/**
 * The `<handbell>` element
 *
 * Parent element: `<technical>`
 *
 * The `<handbell>` element represents notation for various techniques used in handbell and handchime music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/handbell/}
 */
export class Handbell implements XMLElement<'handbell', HandbellAttributes, HandbellContents> {
  static readonly schema = {
    name: 'handbell',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'handbell-value',
          value: {
            type: 'choices',
            choices: [
              'belltree',
              'damp',
              'echo',
              'gyro',
              'hand martellato',
              'mallet lift',
              'mallet table',
              'martellato',
              'martellato lift',
              'muted martellato',
              'pluck lift',
              'swing',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Handbell.schema;

  attributes: HandbellAttributes;
  contents: HandbellContents;

  constructor(opts?: { attributes?: Partial<HandbellAttributes>; contents?: HandbellContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Handbell.schema);
    this.contents = opts?.contents ?? operations.zero(Handbell.schema.contents);
  }
  /** Gets @type {HandbellAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HandbellAttributes['color']}. */
  setColor(color: string | null): Handbell {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HandbellAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HandbellAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Handbell {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HandbellAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HandbellAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Handbell {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HandbellAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HandbellAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Handbell {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HandbellAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HandbellAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Handbell {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HandbellAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HandbellAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Handbell {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HandbellAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HandbellAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Handbell {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HandbellAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HandbellAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Handbell {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HandbellAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HandbellAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Handbell {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HandbellAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HandbellAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Handbell {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {'belltree' | 'damp' | 'echo' | 'gyro' | 'hand martellato' | 'mallet lift' | 'mallet table' | 'martellato' | 'martellato lift' | 'muted martellato' | 'pluck lift' | 'swing'}. */
  getHandbellValue():
    | 'belltree'
    | 'damp'
    | 'echo'
    | 'gyro'
    | 'hand martellato'
    | 'mallet lift'
    | 'mallet table'
    | 'martellato'
    | 'martellato lift'
    | 'muted martellato'
    | 'pluck lift'
    | 'swing' {
    return this.contents[0];
  }
  /** Sets @type {'belltree' | 'damp' | 'echo' | 'gyro' | 'hand martellato' | 'mallet lift' | 'mallet table' | 'martellato' | 'martellato lift' | 'muted martellato' | 'pluck lift' | 'swing'}. */
  setHandbellValue(
    handbellValue:
      | 'belltree'
      | 'damp'
      | 'echo'
      | 'gyro'
      | 'hand martellato'
      | 'mallet lift'
      | 'mallet table'
      | 'martellato'
      | 'martellato lift'
      | 'muted martellato'
      | 'pluck lift'
      | 'swing'
  ): this {
    this.contents[0] = handbellValue;
    return this;
  }
}

export type BrassBendAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type BrassBendContents = [];

/**
 * The `<brass-bend>` element
 *
 * Parent element: `<technical>`
 *
 * The `<brass-bend>` element represents the u-shaped bend symbol used in brass notation, distinct from the `<bend>`
 * element used in guitar music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/brass-bend/}
 */
export class BrassBend implements XMLElement<'brass-bend', BrassBendAttributes, BrassBendContents> {
  static readonly schema = {
    name: 'brass-bend',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = BrassBend.schema;

  attributes: BrassBendAttributes;
  contents: BrassBendContents;

  constructor(opts?: { attributes?: Partial<BrassBendAttributes>; contents?: BrassBendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BrassBend.schema);
    this.contents = opts?.contents ?? operations.zero(BrassBend.schema.contents);
  }
  /** Gets @type {BrassBendAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BrassBendAttributes['color']}. */
  setColor(color: string | null): BrassBend {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BrassBendAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {BrassBendAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): BrassBend {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {BrassBendAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {BrassBendAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): BrassBend {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {BrassBendAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {BrassBendAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): BrassBend {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {BrassBendAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {BrassBendAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BrassBend {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {BrassBendAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {BrassBendAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BrassBend {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {BrassBendAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {BrassBendAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BrassBend {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {BrassBendAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {BrassBendAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): BrassBend {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {BrassBendAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {BrassBendAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): BrassBend {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {BrassBendAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {BrassBendAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): BrassBend {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type FlipAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type FlipContents = [];

/**
 * The `<flip>` element
 *
 * Parent element: `<technical>`
 *
 * The `<flip>` element represents the flip symbol used in brass notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/flip/}
 */
export class Flip implements XMLElement<'flip', FlipAttributes, FlipContents> {
  static readonly schema = {
    name: 'flip',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Flip.schema;

  attributes: FlipAttributes;
  contents: FlipContents;

  constructor(opts?: { attributes?: Partial<FlipAttributes>; contents?: FlipContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Flip.schema);
    this.contents = opts?.contents ?? operations.zero(Flip.schema.contents);
  }
  /** Gets @type {FlipAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FlipAttributes['color']}. */
  setColor(color: string | null): Flip {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FlipAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FlipAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Flip {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FlipAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FlipAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Flip {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FlipAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FlipAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Flip {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FlipAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FlipAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Flip {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FlipAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FlipAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Flip {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FlipAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FlipAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Flip {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FlipAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {FlipAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Flip {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {FlipAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FlipAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Flip {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FlipAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FlipAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Flip {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SmearAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type SmearContents = [];

/**
 * The `<smear>` element
 *
 * Parent element: `<technical>`
 *
 * The `<smear>` element represents the tilde-shaped smear symbol used in brass notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/smear/}
 */
export class Smear implements XMLElement<'smear', SmearAttributes, SmearContents> {
  static readonly schema = {
    name: 'smear',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Smear.schema;

  attributes: SmearAttributes;
  contents: SmearContents;

  constructor(opts?: { attributes?: Partial<SmearAttributes>; contents?: SmearContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Smear.schema);
    this.contents = opts?.contents ?? operations.zero(Smear.schema.contents);
  }
  /** Gets @type {SmearAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SmearAttributes['color']}. */
  setColor(color: string | null): Smear {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SmearAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SmearAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Smear {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SmearAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SmearAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Smear {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SmearAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SmearAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Smear {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SmearAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SmearAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Smear {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SmearAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SmearAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Smear {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SmearAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SmearAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Smear {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SmearAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {SmearAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Smear {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {SmearAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SmearAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Smear {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SmearAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SmearAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Smear {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OpenAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type OpenContents = [];

/**
 * The `<open>` element
 *
 * Parent element: `<technical>`
 *
 * The `<open>` element represents the open symbol, which looks like a circle. The smufl attribute can be used to
 * distinguish different Standard Music Font Layout (SMuFL) glyphs that have a similar appearance such as brassMuteOpen
 * and guitarOpenPedal. If not present, the default glyph is brassMuteOpen.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/open/}
 */
export class Open implements XMLElement<'open', OpenAttributes, OpenContents> {
  static readonly schema = {
    name: 'open',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = Open.schema;

  attributes: OpenAttributes;
  contents: OpenContents;

  constructor(opts?: { attributes?: Partial<OpenAttributes>; contents?: OpenContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Open.schema);
    this.contents = opts?.contents ?? operations.zero(Open.schema.contents);
  }
  /** Gets @type {OpenAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OpenAttributes['color']}. */
  setColor(color: string | null): Open {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OpenAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OpenAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Open {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OpenAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OpenAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Open {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OpenAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {OpenAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Open {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {OpenAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {OpenAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Open {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {OpenAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {OpenAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Open {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {OpenAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {OpenAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Open {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {OpenAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {OpenAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Open {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {OpenAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OpenAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Open {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OpenAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OpenAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Open {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {OpenAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OpenAttributes['smufl']}. */
  setSmufl(smufl: string | null): Open {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type HalfMutedAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type HalfMutedContents = [];

/**
 * The `<half-muted>` element
 *
 * Parent element: `<technical>`
 *
 * The `<half-muted>` element represents the half-muted symbol, which looks like a circle with a plus sign inside. The
 * smufl attribute can be used to distinguish different SMuFL glyphs that have a similar appearance such as
 * brassMuteHalfClosed and guitarHalfOpenPedal. If not present, the default glyph is brassMuteHalfClosed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/half-muted/}
 */
export class HalfMuted implements XMLElement<'half-muted', HalfMutedAttributes, HalfMutedContents> {
  static readonly schema = {
    name: 'half-muted',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = HalfMuted.schema;

  attributes: HalfMutedAttributes;
  contents: HalfMutedContents;

  constructor(opts?: { attributes?: Partial<HalfMutedAttributes>; contents?: HalfMutedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HalfMuted.schema);
    this.contents = opts?.contents ?? operations.zero(HalfMuted.schema.contents);
  }
  /** Gets @type {HalfMutedAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HalfMutedAttributes['color']}. */
  setColor(color: string | null): HalfMuted {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HalfMutedAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): HalfMuted {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HalfMutedAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): HalfMuted {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HalfMutedAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): HalfMuted {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HalfMutedAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HalfMuted {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HalfMutedAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HalfMuted {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HalfMutedAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HalfMuted {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HalfMutedAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): HalfMuted {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HalfMutedAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): HalfMuted {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HalfMutedAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): HalfMuted {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {HalfMutedAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {HalfMutedAttributes['smufl']}. */
  setSmufl(smufl: string | null): HalfMuted {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type HarmonClosedAttributes = {
  /**
   * Indicates which portion of the symbol is filled in when the element value is half.
   */
  location: 'bottom' | 'left' | 'right' | 'top' | null;
};

export type HarmonClosedContents = ['yes' | 'no' | 'half'];

/**
 * The `<harmon-closed>` element
 *
 * Parent element: `<harmon-mute>`
 *
 * The `<harmon-closed>` element represents whether the harmon mute is closed, open, or half-open.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmon-closed/}
 */
export class HarmonClosed implements XMLElement<'harmon-closed', HarmonClosedAttributes, HarmonClosedContents> {
  static readonly schema = {
    name: 'harmon-closed',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['bottom', 'left', 'right', 'top'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'harmon-closed-value',
          value: { type: 'choices', choices: ['yes', 'no', 'half'] },
        },
      },
    ],
  } as const;

  readonly schema = HarmonClosed.schema;

  attributes: HarmonClosedAttributes;
  contents: HarmonClosedContents;

  constructor(opts?: { attributes?: Partial<HarmonClosedAttributes>; contents?: HarmonClosedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HarmonClosed.schema);
    this.contents = opts?.contents ?? operations.zero(HarmonClosed.schema.contents);
  }
  /** Gets @type {HarmonClosedAttributes['location']}. */
  getLocation(): 'bottom' | 'left' | 'right' | 'top' | null {
    return this.attributes['location'];
  }
  /** Sets @type {HarmonClosedAttributes['location']}. */
  setLocation(location: 'bottom' | 'left' | 'right' | 'top' | null): HarmonClosed {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {'yes' | 'no' | 'half'}. */
  getHarmonClosedValue(): 'yes' | 'no' | 'half' {
    return this.contents[0];
  }
  /** Sets @type {'yes' | 'no' | 'half'}. */
  setHarmonClosedValue(harmonClosedValue: 'yes' | 'no' | 'half'): this {
    this.contents[0] = harmonClosedValue;
    return this;
  }
}

export type HarmonMuteAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type HarmonMuteContents = [HarmonClosed];

/**
 * The `<harmon-mute>` element
 *
 * Parent element: `<technical>`
 *
 * The `<harmon-mute>` element represents the symbols used for harmon mutes in brass notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmon-mute/}
 */
export class HarmonMute implements XMLElement<'harmon-mute', HarmonMuteAttributes, HarmonMuteContents> {
  static readonly schema = {
    name: 'harmon-mute',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: HarmonClosed }],
  } as const;

  readonly schema = HarmonMute.schema;

  attributes: HarmonMuteAttributes;
  contents: HarmonMuteContents;

  constructor(opts?: { attributes?: Partial<HarmonMuteAttributes>; contents?: HarmonMuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HarmonMute.schema);
    this.contents = opts?.contents ?? operations.zero(HarmonMute.schema.contents);
  }
  /** Gets @type {HarmonMuteAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HarmonMuteAttributes['color']}. */
  setColor(color: string | null): HarmonMute {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HarmonMuteAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): HarmonMute {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HarmonMuteAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): HarmonMute {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HarmonMuteAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): HarmonMute {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HarmonMuteAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HarmonMute {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HarmonMuteAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HarmonMute {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HarmonMuteAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HarmonMute {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HarmonMuteAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): HarmonMute {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HarmonMuteAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): HarmonMute {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HarmonMuteAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): HarmonMute {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {HarmonMuteAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {HarmonMuteAttributes['smufl']}. */
  setSmufl(smufl: string | null): HarmonMute {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {HarmonClosed}. */
  getHarmonClosed(): HarmonClosed {
    return this.contents[0];
  }
  /** Sets @type {HarmonClosed}. */
  setHarmonClosed(harmonClosed: HarmonClosed): this {
    this.contents[0] = harmonClosed;
    return this;
  }
}

export type GolpeAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type GolpeContents = [];

/**
 * The `<golpe>` element
 *
 * Parent element: `<technical>`
 *
 * The `<golpe>` element represents the golpe symbol that is used for tapping the pick guard in guitar music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/golpe/}
 */
export class Golpe implements XMLElement<'golpe', GolpeAttributes, GolpeContents> {
  static readonly schema = {
    name: 'golpe',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Golpe.schema;

  attributes: GolpeAttributes;
  contents: GolpeContents;

  constructor(opts?: { attributes?: Partial<GolpeAttributes>; contents?: GolpeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Golpe.schema);
    this.contents = opts?.contents ?? operations.zero(Golpe.schema.contents);
  }
  /** Gets @type {GolpeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {GolpeAttributes['color']}. */
  setColor(color: string | null): Golpe {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {GolpeAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {GolpeAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Golpe {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {GolpeAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {GolpeAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Golpe {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {GolpeAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {GolpeAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Golpe {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {GolpeAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {GolpeAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Golpe {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {GolpeAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {GolpeAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Golpe {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {GolpeAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {GolpeAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Golpe {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {GolpeAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {GolpeAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Golpe {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {GolpeAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {GolpeAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Golpe {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {GolpeAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {GolpeAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Golpe {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OtherTechnicalAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type OtherTechnicalContents = [string | null];

/**
 * The `<other-technical>` element
 *
 * Parent element: `<technical>`
 *
 * The `<other-technical>` element is used to define any technical indications not yet in the MusicXML format. The smufl
 * attribute can be used to specify a particular glyph, allowing application interoperability without requiring every
 * Standard Music Font Layout (SMuFL) technical indication to have a MusicXML element equivalent. Using the
 * `<other-technical>` element without the smufl attribute allows for extended representation, though without
 * application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-technical/}
 */
export class OtherTechnical implements XMLElement<'other-technical', OtherTechnicalAttributes, OtherTechnicalContents> {
  static readonly schema = {
    name: 'other-technical',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherTechnical.schema;

  attributes: OtherTechnicalAttributes;
  contents: OtherTechnicalContents;

  constructor(opts?: { attributes?: Partial<OtherTechnicalAttributes>; contents?: OtherTechnicalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherTechnical.schema);
    this.contents = opts?.contents ?? operations.zero(OtherTechnical.schema.contents);
  }
  /** Gets @type {OtherTechnicalAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OtherTechnicalAttributes['color']}. */
  setColor(color: string | null): OtherTechnical {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OtherTechnicalAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): OtherTechnical {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OtherTechnicalAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): OtherTechnical {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {OtherTechnicalAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): OtherTechnical {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {OtherTechnicalAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherTechnical {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {OtherTechnicalAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherTechnical {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {OtherTechnicalAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherTechnical {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {OtherTechnicalAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): OtherTechnical {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OtherTechnicalAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): OtherTechnical {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OtherTechnicalAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): OtherTechnical {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {OtherTechnicalAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OtherTechnicalAttributes['smufl']}. */
  setSmufl(smufl: string | null): OtherTechnical {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {string | null}. */
  getText(): string | null {
    return this.contents[0];
  }
  /** Sets @type {string | null}. */
  setText(text: string | null): this {
    this.contents[0] = text;
    return this;
  }
}

export type TechnicalAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
};

export type TechnicalContents = [
  Array<
    | UpBow
    | DownBow
    | Harmonic
    | OpenString
    | ThumbPosition
    | Fingering
    | Pluck
    | DoubleTongue
    | TripleTongue
    | Stopped
    | SnapPizzicato
    | Fret
    | String
    | HammerOn
    | PullOff
    | Bend
    | Tap
    | Heel
    | Toe
    | Fingernails
    | Hole
    | Arrow
    | Handbell
    | BrassBend
    | Flip
    | Smear
    | Open
    | HalfMuted
    | HarmonMute
    | Golpe
    | OtherTechnical
  >,
];

/**
 * The `<technical>` element
 *
 * Parent element: `<notations>`
 *
 * The `<technical>` element groups together technical indications that give performance information for specific
 * instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/technical/}
 */
export class Technical implements XMLElement<'technical', TechnicalAttributes, TechnicalContents> {
  static readonly schema = {
    name: 'technical',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              UpBow,
              DownBow,
              Harmonic,
              OpenString,
              ThumbPosition,
              Fingering,
              Pluck,
              DoubleTongue,
              TripleTongue,
              Stopped,
              SnapPizzicato,
              Fret,
              String,
              HammerOn,
              PullOff,
              Bend,
              Tap,
              Heel,
              Toe,
              Fingernails,
              Hole,
              Arrow,
              Handbell,
              BrassBend,
              Flip,
              Smear,
              Open,
              HalfMuted,
              HarmonMute,
              Golpe,
              OtherTechnical,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Technical.schema;

  attributes: TechnicalAttributes;
  contents: TechnicalContents;

  constructor(opts?: { attributes?: Partial<TechnicalAttributes>; contents?: TechnicalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Technical.schema);
    this.contents = opts?.contents ?? operations.zero(Technical.schema.contents);
  }
  /** Gets @type {TechnicalAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {TechnicalAttributes['id']}. */
  setId(id: string | null): Technical {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Array<UpBow | DownBow | Harmonic | OpenString | ThumbPosition | Fingering | Pluck | DoubleTongue | TripleTongue | Stopped | SnapPizzicato | Fret | String | HammerOn | PullOff | Bend | Tap | Heel | Toe | Fingernails | Hole | Arrow | Handbell | BrassBend | Flip | Smear | Open | HalfMuted | HarmonMute | Golpe | OtherTechnical>}. */
  getValues(): Array<
    | UpBow
    | DownBow
    | Harmonic
    | OpenString
    | ThumbPosition
    | Fingering
    | Pluck
    | DoubleTongue
    | TripleTongue
    | Stopped
    | SnapPizzicato
    | Fret
    | String
    | HammerOn
    | PullOff
    | Bend
    | Tap
    | Heel
    | Toe
    | Fingernails
    | Hole
    | Arrow
    | Handbell
    | BrassBend
    | Flip
    | Smear
    | Open
    | HalfMuted
    | HarmonMute
    | Golpe
    | OtherTechnical
  > {
    return this.contents[0];
  }
  /** Sets @type {Array<UpBow | DownBow | Harmonic | OpenString | ThumbPosition | Fingering | Pluck | DoubleTongue | TripleTongue | Stopped | SnapPizzicato | Fret | String | HammerOn | PullOff | Bend | Tap | Heel | Toe | Fingernails | Hole | Arrow | Handbell | BrassBend | Flip | Smear | Open | HalfMuted | HarmonMute | Golpe | OtherTechnical>}. */
  setValues(
    values: Array<
      | UpBow
      | DownBow
      | Harmonic
      | OpenString
      | ThumbPosition
      | Fingering
      | Pluck
      | DoubleTongue
      | TripleTongue
      | Stopped
      | SnapPizzicato
      | Fret
      | String
      | HammerOn
      | PullOff
      | Bend
      | Tap
      | Heel
      | Toe
      | Fingernails
      | Hole
      | Arrow
      | Handbell
      | BrassBend
      | Flip
      | Smear
      | Open
      | HalfMuted
      | HarmonMute
      | Golpe
      | OtherTechnical
    >
  ): this {
    this.contents[0] = values;
    return this;
  }
}

export type AccentAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type AccentContents = [];

/**
 * The `<accent>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<accent>` element indicates a regular horizontal accent mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accent/}
 */
export class Accent implements XMLElement<'accent', AccentAttributes, AccentContents> {
  static readonly schema = {
    name: 'accent',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Accent.schema;

  attributes: AccentAttributes;
  contents: AccentContents;

  constructor(opts?: { attributes?: Partial<AccentAttributes>; contents?: AccentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Accent.schema);
    this.contents = opts?.contents ?? operations.zero(Accent.schema.contents);
  }
  /** Gets @type {AccentAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {AccentAttributes['color']}. */
  setColor(color: string | null): Accent {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {AccentAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {AccentAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Accent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {AccentAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {AccentAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Accent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {AccentAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {AccentAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Accent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {AccentAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {AccentAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Accent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {AccentAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {AccentAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Accent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {AccentAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {AccentAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Accent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {AccentAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {AccentAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Accent {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {AccentAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {AccentAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Accent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {AccentAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {AccentAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Accent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type StrongAccentAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates if the point of the accent is down or up. The default value is up.
   */
  type: 'up' | 'down' | null;
};

export type StrongAccentContents = [];

/**
 * The `<strong-accent>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<strong-accent>` element indicates a vertical accent mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/strong-accent/}
 */
export class StrongAccent implements XMLElement<'strong-accent', StrongAccentAttributes, StrongAccentContents> {
  static readonly schema = {
    name: 'strong-accent',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      type: { type: 'optional', value: { type: 'choices', choices: ['up', 'down'] } },
    },
    contents: [],
  } as const;

  readonly schema = StrongAccent.schema;

  attributes: StrongAccentAttributes;
  contents: StrongAccentContents;

  constructor(opts?: { attributes?: Partial<StrongAccentAttributes>; contents?: StrongAccentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StrongAccent.schema);
    this.contents = opts?.contents ?? operations.zero(StrongAccent.schema.contents);
  }
  /** Gets @type {StrongAccentAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StrongAccentAttributes['color']}. */
  setColor(color: string | null): StrongAccent {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StrongAccentAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): StrongAccent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StrongAccentAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): StrongAccent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StrongAccentAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): StrongAccent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StrongAccentAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): StrongAccent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StrongAccentAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): StrongAccent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StrongAccentAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): StrongAccent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {StrongAccentAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): StrongAccent {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StrongAccentAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): StrongAccent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StrongAccentAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): StrongAccent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {StrongAccentAttributes['type']}. */
  getType(): 'up' | 'down' | null {
    return this.attributes['type'];
  }
  /** Sets @type {StrongAccentAttributes['type']}. */
  setType(type: 'up' | 'down' | null): StrongAccent {
    this.attributes['type'] = type;
    return this;
  }
}

export type StaccatoAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type StaccatoContents = [];

/**
 * The `<staccato>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<staccato>` element is used for a dot articulation, as opposed to a stroke or a wedge.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staccato/}
 */
export class Staccato implements XMLElement<'staccato', StaccatoAttributes, StaccatoContents> {
  static readonly schema = {
    name: 'staccato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Staccato.schema;

  attributes: StaccatoAttributes;
  contents: StaccatoContents;

  constructor(opts?: { attributes?: Partial<StaccatoAttributes>; contents?: StaccatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staccato.schema);
    this.contents = opts?.contents ?? operations.zero(Staccato.schema.contents);
  }
  /** Gets @type {StaccatoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StaccatoAttributes['color']}. */
  setColor(color: string | null): Staccato {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StaccatoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StaccatoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Staccato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StaccatoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StaccatoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Staccato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StaccatoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StaccatoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Staccato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StaccatoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StaccatoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Staccato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StaccatoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StaccatoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Staccato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StaccatoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StaccatoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Staccato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StaccatoAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {StaccatoAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Staccato {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {StaccatoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StaccatoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Staccato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StaccatoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StaccatoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Staccato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type TenutoAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type TenutoContents = [];

/**
 * The `<tenuto>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<tenuto>` element indicates a tenuto line symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tenuto/}
 */
export class Tenuto implements XMLElement<'tenuto', TenutoAttributes, TenutoContents> {
  static readonly schema = {
    name: 'tenuto',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Tenuto.schema;

  attributes: TenutoAttributes;
  contents: TenutoContents;

  constructor(opts?: { attributes?: Partial<TenutoAttributes>; contents?: TenutoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Tenuto.schema);
    this.contents = opts?.contents ?? operations.zero(Tenuto.schema.contents);
  }
  /** Gets @type {TenutoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TenutoAttributes['color']}. */
  setColor(color: string | null): Tenuto {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TenutoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TenutoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Tenuto {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TenutoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TenutoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Tenuto {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TenutoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TenutoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Tenuto {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TenutoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TenutoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Tenuto {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TenutoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TenutoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Tenuto {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TenutoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TenutoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Tenuto {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TenutoAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {TenutoAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Tenuto {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {TenutoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TenutoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Tenuto {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TenutoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TenutoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Tenuto {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type DetachedLegatoAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type DetachedLegatoContents = [];

/**
 * The `<detached-legato>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<detached-legato>` element indicates the combination of a tenuto line and staccato dot symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/detached-legato/}
 */
export class DetachedLegato implements XMLElement<'detached-legato', DetachedLegatoAttributes, DetachedLegatoContents> {
  static readonly schema = {
    name: 'detached-legato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = DetachedLegato.schema;

  attributes: DetachedLegatoAttributes;
  contents: DetachedLegatoContents;

  constructor(opts?: { attributes?: Partial<DetachedLegatoAttributes>; contents?: DetachedLegatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DetachedLegato.schema);
    this.contents = opts?.contents ?? operations.zero(DetachedLegato.schema.contents);
  }
  /** Gets @type {DetachedLegatoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DetachedLegatoAttributes['color']}. */
  setColor(color: string | null): DetachedLegato {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DetachedLegatoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DetachedLegato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DetachedLegatoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DetachedLegato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DetachedLegatoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DetachedLegato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DetachedLegatoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DetachedLegato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DetachedLegatoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DetachedLegato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DetachedLegatoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DetachedLegato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DetachedLegatoAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): DetachedLegato {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DetachedLegatoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DetachedLegato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DetachedLegatoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DetachedLegatoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DetachedLegato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type StaccatissimoAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type StaccatissimoContents = [];

/**
 * The `<staccatissimo>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<staccatissimo>` element is used for a wedge articulation, as opposed to a dot or a stroke.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staccatissimo/}
 */
export class Staccatissimo implements XMLElement<'staccatissimo', StaccatissimoAttributes, StaccatissimoContents> {
  static readonly schema = {
    name: 'staccatissimo',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Staccatissimo.schema;

  attributes: StaccatissimoAttributes;
  contents: StaccatissimoContents;

  constructor(opts?: { attributes?: Partial<StaccatissimoAttributes>; contents?: StaccatissimoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staccatissimo.schema);
    this.contents = opts?.contents ?? operations.zero(Staccatissimo.schema.contents);
  }
  /** Gets @type {StaccatissimoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StaccatissimoAttributes['color']}. */
  setColor(color: string | null): Staccatissimo {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StaccatissimoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Staccatissimo {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StaccatissimoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Staccatissimo {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StaccatissimoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Staccatissimo {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StaccatissimoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Staccatissimo {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StaccatissimoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Staccatissimo {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StaccatissimoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Staccatissimo {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {StaccatissimoAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Staccatissimo {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StaccatissimoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Staccatissimo {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StaccatissimoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StaccatissimoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Staccatissimo {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SpiccatoAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type SpiccatoContents = [];

/**
 * The `<spiccato>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<spiccato>` element is used for a stroke articulation, as opposed to a dot or a wedge.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/spiccato/}
 */
export class Spiccato implements XMLElement<'spiccato', SpiccatoAttributes, SpiccatoContents> {
  static readonly schema = {
    name: 'spiccato',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Spiccato.schema;

  attributes: SpiccatoAttributes;
  contents: SpiccatoContents;

  constructor(opts?: { attributes?: Partial<SpiccatoAttributes>; contents?: SpiccatoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Spiccato.schema);
    this.contents = opts?.contents ?? operations.zero(Spiccato.schema.contents);
  }
  /** Gets @type {SpiccatoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SpiccatoAttributes['color']}. */
  setColor(color: string | null): Spiccato {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SpiccatoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Spiccato {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SpiccatoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Spiccato {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SpiccatoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Spiccato {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SpiccatoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Spiccato {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SpiccatoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Spiccato {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SpiccatoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Spiccato {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {SpiccatoAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Spiccato {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SpiccatoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Spiccato {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SpiccatoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SpiccatoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Spiccato {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type ScoopAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type ScoopContents = [];

/**
 * The `<scoop>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<scoop>` element is an indeterminate slide attached to a single note. The scoop appears before the main note and
 * comes from below the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/scoop/}
 */
export class Scoop implements XMLElement<'scoop', ScoopAttributes, ScoopContents> {
  static readonly schema = {
    name: 'scoop',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Scoop.schema;

  attributes: ScoopAttributes;
  contents: ScoopContents;

  constructor(opts?: { attributes?: Partial<ScoopAttributes>; contents?: ScoopContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Scoop.schema);
    this.contents = opts?.contents ?? operations.zero(Scoop.schema.contents);
  }
  /** Gets @type {ScoopAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ScoopAttributes['color']}. */
  setColor(color: string | null): Scoop {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ScoopAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ScoopAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Scoop {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ScoopAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ScoopAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Scoop {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ScoopAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {ScoopAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Scoop {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {ScoopAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {ScoopAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Scoop {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {ScoopAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {ScoopAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Scoop {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {ScoopAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {ScoopAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Scoop {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {ScoopAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {ScoopAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Scoop {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {ScoopAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ScoopAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Scoop {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ScoopAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ScoopAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Scoop {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type PlopAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Distinguishes between different line lengths for doit, falloff, plop, and scoop articulations.
   */
  'line-length': 'short' | 'medium' | 'long' | null;
  /**
   * Is the line straight or curved?
   */
  'line-shape': 'straight' | 'curved' | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type PlopContents = [];

/**
 * The `<plop>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<plop>` element is an indeterminate slide attached to a single note. The plop appears before the main note and
 * comes from above the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/plop/}
 */
export class Plop implements XMLElement<'plop', PlopAttributes, PlopContents> {
  static readonly schema = {
    name: 'plop',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Plop.schema;

  attributes: PlopAttributes;
  contents: PlopContents;

  constructor(opts?: { attributes?: Partial<PlopAttributes>; contents?: PlopContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Plop.schema);
    this.contents = opts?.contents ?? operations.zero(Plop.schema.contents);
  }
  /** Gets @type {PlopAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PlopAttributes['color']}. */
  setColor(color: string | null): Plop {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PlopAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {PlopAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Plop {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {PlopAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PlopAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Plop {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PlopAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PlopAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Plop {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PlopAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PlopAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Plop {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PlopAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PlopAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Plop {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PlopAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PlopAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Plop {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PlopAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PlopAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Plop {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PlopAttributes['line-length']}. */
  getLineLength(): 'short' | 'medium' | 'long' | null {
    return this.attributes['line-length'];
  }
  /** Sets @type {PlopAttributes['line-length']}. */
  setLineLength(lineLength: 'short' | 'medium' | 'long' | null): Plop {
    this.attributes['line-length'] = lineLength;
    return this;
  }
  /** Gets @type {PlopAttributes['line-shape']}. */
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  /** Sets @type {PlopAttributes['line-shape']}. */
  setLineShape(lineShape: 'straight' | 'curved' | null): Plop {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  /** Gets @type {PlopAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {PlopAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Plop {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {PlopAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {PlopAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Plop {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {PlopAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PlopAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Plop {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PlopAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PlopAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Plop {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {PlopAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {PlopAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Plop {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type DoitAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Distinguishes between different line lengths for doit, falloff, plop, and scoop articulations.
   */
  'line-length': 'short' | 'medium' | 'long' | null;
  /**
   * Is the line straight or curved?
   */
  'line-shape': 'straight' | 'curved' | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type DoitContents = [];

/**
 * The `<doit>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<doit>` element is an indeterminate slide attached to a single note. The doit appears after the main note and
 * goes above the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/doit/}
 */
export class Doit implements XMLElement<'doit', DoitAttributes, DoitContents> {
  static readonly schema = {
    name: 'doit',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Doit.schema;

  attributes: DoitAttributes;
  contents: DoitContents;

  constructor(opts?: { attributes?: Partial<DoitAttributes>; contents?: DoitContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Doit.schema);
    this.contents = opts?.contents ?? operations.zero(Doit.schema.contents);
  }
  /** Gets @type {DoitAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DoitAttributes['color']}. */
  setColor(color: string | null): Doit {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DoitAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {DoitAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Doit {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {DoitAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DoitAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Doit {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DoitAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DoitAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Doit {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DoitAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DoitAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Doit {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DoitAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DoitAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Doit {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DoitAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DoitAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Doit {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DoitAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DoitAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Doit {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DoitAttributes['line-length']}. */
  getLineLength(): 'short' | 'medium' | 'long' | null {
    return this.attributes['line-length'];
  }
  /** Sets @type {DoitAttributes['line-length']}. */
  setLineLength(lineLength: 'short' | 'medium' | 'long' | null): Doit {
    this.attributes['line-length'] = lineLength;
    return this;
  }
  /** Gets @type {DoitAttributes['line-shape']}. */
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  /** Sets @type {DoitAttributes['line-shape']}. */
  setLineShape(lineShape: 'straight' | 'curved' | null): Doit {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  /** Gets @type {DoitAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {DoitAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Doit {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {DoitAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DoitAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Doit {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DoitAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DoitAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Doit {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DoitAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DoitAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Doit {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DoitAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {DoitAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Doit {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type FalloffAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Distinguishes between different line lengths for doit, falloff, plop, and scoop articulations.
   */
  'line-length': 'short' | 'medium' | 'long' | null;
  /**
   * Is the line straight or curved?
   */
  'line-shape': 'straight' | 'curved' | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type FalloffContents = [];

/**
 * The `<falloff>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<falloff>` element is an indeterminate slide attached to a single note. The falloff appears after the main note
 * and goes below the main pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/falloff/}
 */
export class Falloff implements XMLElement<'falloff', FalloffAttributes, FalloffContents> {
  static readonly schema = {
    name: 'falloff',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'line-length': { type: 'optional', value: { type: 'choices', choices: ['short', 'medium', 'long'] } },
      'line-shape': { type: 'optional', value: { type: 'choices', choices: ['straight', 'curved'] } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Falloff.schema;

  attributes: FalloffAttributes;
  contents: FalloffContents;

  constructor(opts?: { attributes?: Partial<FalloffAttributes>; contents?: FalloffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Falloff.schema);
    this.contents = opts?.contents ?? operations.zero(Falloff.schema.contents);
  }
  /** Gets @type {FalloffAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FalloffAttributes['color']}. */
  setColor(color: string | null): Falloff {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FalloffAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {FalloffAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Falloff {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {FalloffAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FalloffAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Falloff {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FalloffAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FalloffAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Falloff {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FalloffAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FalloffAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Falloff {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FalloffAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FalloffAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Falloff {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FalloffAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FalloffAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Falloff {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FalloffAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FalloffAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Falloff {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FalloffAttributes['line-length']}. */
  getLineLength(): 'short' | 'medium' | 'long' | null {
    return this.attributes['line-length'];
  }
  /** Sets @type {FalloffAttributes['line-length']}. */
  setLineLength(lineLength: 'short' | 'medium' | 'long' | null): Falloff {
    this.attributes['line-length'] = lineLength;
    return this;
  }
  /** Gets @type {FalloffAttributes['line-shape']}. */
  getLineShape(): 'straight' | 'curved' | null {
    return this.attributes['line-shape'];
  }
  /** Sets @type {FalloffAttributes['line-shape']}. */
  setLineShape(lineShape: 'straight' | 'curved' | null): Falloff {
    this.attributes['line-shape'] = lineShape;
    return this;
  }
  /** Gets @type {FalloffAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {FalloffAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Falloff {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {FalloffAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {FalloffAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Falloff {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {FalloffAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FalloffAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Falloff {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FalloffAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FalloffAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Falloff {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {FalloffAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {FalloffAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Falloff {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type BreathMarkAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type BreathMarkContents = ['comma' | 'tick' | 'upbow' | 'salzedo' | '' | null];

/**
 * The `<breath-mark>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<breath-mark>` element indicates a place to take a breath.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/breath-mark/}
 */
export class BreathMark implements XMLElement<'breath-mark', BreathMarkAttributes, BreathMarkContents> {
  static readonly schema = {
    name: 'breath-mark',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'optional',
        value: {
          type: 'label',
          label: 'breath-mark-value',
          value: { type: 'choices', choices: ['comma', 'tick', 'upbow', 'salzedo', ''] },
        },
      },
    ],
  } as const;

  readonly schema = BreathMark.schema;

  attributes: BreathMarkAttributes;
  contents: BreathMarkContents;

  constructor(opts?: { attributes?: Partial<BreathMarkAttributes>; contents?: BreathMarkContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BreathMark.schema);
    this.contents = opts?.contents ?? operations.zero(BreathMark.schema.contents);
  }
  /** Gets @type {BreathMarkAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BreathMarkAttributes['color']}. */
  setColor(color: string | null): BreathMark {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {BreathMarkAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): BreathMark {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {BreathMarkAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): BreathMark {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {BreathMarkAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): BreathMark {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {BreathMarkAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BreathMark {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {BreathMarkAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BreathMark {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {BreathMarkAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BreathMark {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {BreathMarkAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): BreathMark {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {BreathMarkAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): BreathMark {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {BreathMarkAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {BreathMarkAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): BreathMark {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null}. */
  getBreathMarkValue(): 'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null {
    return this.contents[0];
  }
  /** Sets @type {'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null}. */
  setBreathMarkValue(breathMarkValue: 'comma' | 'tick' | 'upbow' | 'salzedo' | '' | null): this {
    this.contents[0] = breathMarkValue;
    return this;
  }
}

export type CaesuraAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type CaesuraContents = ['normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null];

/**
 * The `<caesura>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<caesura>` element indicates a slight pause. It is notated using a "railroad tracks" symbol or other variations
 * specified in the element content.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/caesura/}
 */
export class Caesura implements XMLElement<'caesura', CaesuraAttributes, CaesuraContents> {
  static readonly schema = {
    name: 'caesura',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'optional',
        value: {
          type: 'label',
          label: 'caesura-value',
          value: { type: 'choices', choices: ['normal', 'thick', 'short', 'curved', 'single', ''] },
        },
      },
    ],
  } as const;

  readonly schema = Caesura.schema;

  attributes: CaesuraAttributes;
  contents: CaesuraContents;

  constructor(opts?: { attributes?: Partial<CaesuraAttributes>; contents?: CaesuraContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Caesura.schema);
    this.contents = opts?.contents ?? operations.zero(Caesura.schema.contents);
  }
  /** Gets @type {CaesuraAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {CaesuraAttributes['color']}. */
  setColor(color: string | null): Caesura {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {CaesuraAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {CaesuraAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Caesura {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {CaesuraAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {CaesuraAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Caesura {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {CaesuraAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {CaesuraAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Caesura {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {CaesuraAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {CaesuraAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Caesura {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {CaesuraAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {CaesuraAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Caesura {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {CaesuraAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {CaesuraAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Caesura {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {CaesuraAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {CaesuraAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Caesura {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {CaesuraAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {CaesuraAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Caesura {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {CaesuraAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {CaesuraAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Caesura {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null}. */
  getCaesuraValue(): 'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null {
    return this.contents[0];
  }
  /** Sets @type {'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null}. */
  setCaesuraValue(caesuraValue: 'normal' | 'thick' | 'short' | 'curved' | 'single' | '' | null): this {
    this.contents[0] = caesuraValue;
    return this;
  }
}

export type StressAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type StressContents = [];

/**
 * The `<stress>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<stress>` element indicates a stressed note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stress/}
 */
export class Stress implements XMLElement<'stress', StressAttributes, StressContents> {
  static readonly schema = {
    name: 'stress',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Stress.schema;

  attributes: StressAttributes;
  contents: StressContents;

  constructor(opts?: { attributes?: Partial<StressAttributes>; contents?: StressContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stress.schema);
    this.contents = opts?.contents ?? operations.zero(Stress.schema.contents);
  }
  /** Gets @type {StressAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StressAttributes['color']}. */
  setColor(color: string | null): Stress {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StressAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StressAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Stress {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StressAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StressAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Stress {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StressAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StressAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Stress {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StressAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StressAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Stress {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StressAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StressAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Stress {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StressAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StressAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Stress {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StressAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {StressAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Stress {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {StressAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StressAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Stress {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StressAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StressAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Stress {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type UnstressAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type UnstressContents = [];

/**
 * The `<unstress>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<unstress>` element indicates an unstressed note. It is often notated using a u-shaped symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/unstress/}
 */
export class Unstress implements XMLElement<'unstress', UnstressAttributes, UnstressContents> {
  static readonly schema = {
    name: 'unstress',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = Unstress.schema;

  attributes: UnstressAttributes;
  contents: UnstressContents;

  constructor(opts?: { attributes?: Partial<UnstressAttributes>; contents?: UnstressContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Unstress.schema);
    this.contents = opts?.contents ?? operations.zero(Unstress.schema.contents);
  }
  /** Gets @type {UnstressAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {UnstressAttributes['color']}. */
  setColor(color: string | null): Unstress {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {UnstressAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {UnstressAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Unstress {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {UnstressAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {UnstressAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Unstress {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {UnstressAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {UnstressAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Unstress {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {UnstressAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {UnstressAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Unstress {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {UnstressAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {UnstressAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Unstress {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {UnstressAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {UnstressAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Unstress {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {UnstressAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {UnstressAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Unstress {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {UnstressAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {UnstressAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Unstress {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {UnstressAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {UnstressAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Unstress {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type SoftAccentAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type SoftAccentContents = [];

/**
 * The `<soft-accent>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<soft-accent>` element indicates a soft accent that is not as heavy as a normal accent. It is often notated as
 * <>. It can be combined with other articulations to implement the first eight symbols in the Standard Music Font
 * Layout (SMuFL) [Articulation supplement](https://www.w3.org/2021/03/smufl14/tables/articulation-supplement.html)
 * range.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/soft-accent/}
 */
export class SoftAccent implements XMLElement<'soft-accent', SoftAccentAttributes, SoftAccentContents> {
  static readonly schema = {
    name: 'soft-accent',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = SoftAccent.schema;

  attributes: SoftAccentAttributes;
  contents: SoftAccentContents;

  constructor(opts?: { attributes?: Partial<SoftAccentAttributes>; contents?: SoftAccentContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SoftAccent.schema);
    this.contents = opts?.contents ?? operations.zero(SoftAccent.schema.contents);
  }
  /** Gets @type {SoftAccentAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SoftAccentAttributes['color']}. */
  setColor(color: string | null): SoftAccent {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SoftAccentAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): SoftAccent {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SoftAccentAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): SoftAccent {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SoftAccentAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): SoftAccent {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SoftAccentAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): SoftAccent {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SoftAccentAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): SoftAccent {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SoftAccentAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): SoftAccent {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {SoftAccentAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): SoftAccent {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SoftAccentAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): SoftAccent {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SoftAccentAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SoftAccentAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): SoftAccent {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OtherArticulationAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type OtherArticulationContents = [];

/**
 * The `<other-articulation>` element
 *
 * Parent element: `<articulations>`
 *
 * The `<other-articulation>` element is used to define any articulations not yet in the MusicXML format. The smufl
 * attribute can be used to specify a particular articulation, allowing application interoperability without requiring
 * every Standard Music Font Layout (SMuFL) articulation to have a MusicXML element equivalent. Using the
 * `<other-articulation>` element without the smufl attribute allows for extended representation, though without
 * application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-articulation/}
 */
export class OtherArticulation
  implements XMLElement<'other-articulation', OtherArticulationAttributes, OtherArticulationContents>
{
  static readonly schema = {
    name: 'other-articulation',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [],
  } as const;

  readonly schema = OtherArticulation.schema;

  attributes: OtherArticulationAttributes;
  contents: OtherArticulationContents;

  constructor(opts?: { attributes?: Partial<OtherArticulationAttributes>; contents?: OtherArticulationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherArticulation.schema);
    this.contents = opts?.contents ?? operations.zero(OtherArticulation.schema.contents);
  }
  /** Gets @type {OtherArticulationAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OtherArticulationAttributes['color']}. */
  setColor(color: string | null): OtherArticulation {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OtherArticulationAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): OtherArticulation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OtherArticulationAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): OtherArticulation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {OtherArticulationAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): OtherArticulation {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {OtherArticulationAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherArticulation {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {OtherArticulationAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherArticulation {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {OtherArticulationAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherArticulation {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {OtherArticulationAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): OtherArticulation {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OtherArticulationAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): OtherArticulation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OtherArticulationAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): OtherArticulation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {OtherArticulationAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OtherArticulationAttributes['smufl']}. */
  setSmufl(smufl: string | null): OtherArticulation {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type ArticulationsAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
};

export type ArticulationsContents = [
  Array<
    | Accent
    | StrongAccent
    | Staccato
    | Tenuto
    | DetachedLegato
    | Staccatissimo
    | Spiccato
    | Scoop
    | Plop
    | Doit
    | Falloff
    | BreathMark
    | Caesura
    | Stress
    | Unstress
    | SoftAccent
    | OtherArticulation
  >,
];

/**
 * The `<articulations>` element
 *
 * Parent element: `<notations>`
 *
 * The `<articulations>` element groups together articulations and accents.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/articulations/}
 */
export class Articulations implements XMLElement<'articulations', ArticulationsAttributes, ArticulationsContents> {
  static readonly schema = {
    name: 'articulations',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'articulations',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Accent,
              StrongAccent,
              Staccato,
              Tenuto,
              DetachedLegato,
              Staccatissimo,
              Spiccato,
              Scoop,
              Plop,
              Doit,
              Falloff,
              BreathMark,
              Caesura,
              Stress,
              Unstress,
              SoftAccent,
              OtherArticulation,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Articulations.schema;

  attributes: ArticulationsAttributes;
  contents: ArticulationsContents;

  constructor(opts?: { attributes?: Partial<ArticulationsAttributes>; contents?: ArticulationsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Articulations.schema);
    this.contents = opts?.contents ?? operations.zero(Articulations.schema.contents);
  }
  /** Gets @type {ArticulationsAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {ArticulationsAttributes['id']}. */
  setId(id: string | null): Articulations {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Array<Accent | StrongAccent | Staccato | Tenuto | DetachedLegato | Staccatissimo | Spiccato | Scoop | Plop | Doit | Falloff | BreathMark | Caesura | Stress | Unstress | SoftAccent | OtherArticulation>}. */
  getArticulations(): Array<
    | Accent
    | StrongAccent
    | Staccato
    | Tenuto
    | DetachedLegato
    | Staccatissimo
    | Spiccato
    | Scoop
    | Plop
    | Doit
    | Falloff
    | BreathMark
    | Caesura
    | Stress
    | Unstress
    | SoftAccent
    | OtherArticulation
  > {
    return this.contents[0];
  }
  /** Sets @type {Array<Accent | StrongAccent | Staccato | Tenuto | DetachedLegato | Staccatissimo | Spiccato | Scoop | Plop | Doit | Falloff | BreathMark | Caesura | Stress | Unstress | SoftAccent | OtherArticulation>}. */
  setArticulations(
    articulations: Array<
      | Accent
      | StrongAccent
      | Staccato
      | Tenuto
      | DetachedLegato
      | Staccatissimo
      | Spiccato
      | Scoop
      | Plop
      | Doit
      | Falloff
      | BreathMark
      | Caesura
      | Stress
      | Unstress
      | SoftAccent
      | OtherArticulation
    >
  ): this {
    this.contents[0] = articulations;
    return this;
  }
}

export type PAttributes = Record<string, unknown>;

export type PContents = [];

/**
 * The `<p>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<p>` element represents a piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/p/}
 */
export class P implements XMLElement<'p', PAttributes, PContents> {
  static readonly schema = { name: 'p', attributes: {}, contents: [] } as const;

  readonly schema = P.schema;

  attributes: PAttributes;
  contents: PContents;

  constructor(opts?: { attributes?: Partial<PAttributes>; contents?: PContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, P.schema);
    this.contents = opts?.contents ?? operations.zero(P.schema.contents);
  }
}

export type PpAttributes = Record<string, unknown>;

export type PpContents = [];

/**
 * The `<pp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pp>` element represents a pianissimo dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pp/}
 */
export class Pp implements XMLElement<'pp', PpAttributes, PpContents> {
  static readonly schema = { name: 'pp', attributes: {}, contents: [] } as const;

  readonly schema = Pp.schema;

  attributes: PpAttributes;
  contents: PpContents;

  constructor(opts?: { attributes?: Partial<PpAttributes>; contents?: PpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pp.schema);
    this.contents = opts?.contents ?? operations.zero(Pp.schema.contents);
  }
}

export type PppAttributes = Record<string, unknown>;

export type PppContents = [];

/**
 * The `<ppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ppp>` element represents a triple piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ppp/}
 */
export class Ppp implements XMLElement<'ppp', PppAttributes, PppContents> {
  static readonly schema = { name: 'ppp', attributes: {}, contents: [] } as const;

  readonly schema = Ppp.schema;

  attributes: PppAttributes;
  contents: PppContents;

  constructor(opts?: { attributes?: Partial<PppAttributes>; contents?: PppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ppp.schema);
    this.contents = opts?.contents ?? operations.zero(Ppp.schema.contents);
  }
}

export type PpppAttributes = Record<string, unknown>;

export type PpppContents = [];

/**
 * The `<pppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pppp>` element represents a pppp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pppp/}
 */
export class Pppp implements XMLElement<'pppp', PpppAttributes, PpppContents> {
  static readonly schema = { name: 'pppp', attributes: {}, contents: [] } as const;

  readonly schema = Pppp.schema;

  attributes: PpppAttributes;
  contents: PpppContents;

  constructor(opts?: { attributes?: Partial<PpppAttributes>; contents?: PpppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pppp.schema);
    this.contents = opts?.contents ?? operations.zero(Pppp.schema.contents);
  }
}

export type PppppAttributes = Record<string, unknown>;

export type PppppContents = [];

/**
 * The `<ppppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ppppp>` element represents a ppppp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ppppp/}
 */
export class Ppppp implements XMLElement<'ppppp', PppppAttributes, PppppContents> {
  static readonly schema = { name: 'ppppp', attributes: {}, contents: [] } as const;

  readonly schema = Ppppp.schema;

  attributes: PppppAttributes;
  contents: PppppContents;

  constructor(opts?: { attributes?: Partial<PppppAttributes>; contents?: PppppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ppppp.schema);
    this.contents = opts?.contents ?? operations.zero(Ppppp.schema.contents);
  }
}

export type PpppppAttributes = Record<string, unknown>;

export type PpppppContents = [];

/**
 * The `<pppppp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pppppp>` element represents a pppppp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pppppp/}
 */
export class Pppppp implements XMLElement<'pppppp', PpppppAttributes, PpppppContents> {
  static readonly schema = { name: 'pppppp', attributes: {}, contents: [] } as const;

  readonly schema = Pppppp.schema;

  attributes: PpppppAttributes;
  contents: PpppppContents;

  constructor(opts?: { attributes?: Partial<PpppppAttributes>; contents?: PpppppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pppppp.schema);
    this.contents = opts?.contents ?? operations.zero(Pppppp.schema.contents);
  }
}

export type FAttributes = Record<string, unknown>;

export type FContents = [];

/**
 * The `<f>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<f>` element represents a forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/f/}
 */
export class F implements XMLElement<'f', FAttributes, FContents> {
  static readonly schema = { name: 'f', attributes: {}, contents: [] } as const;

  readonly schema = F.schema;

  attributes: FAttributes;
  contents: FContents;

  constructor(opts?: { attributes?: Partial<FAttributes>; contents?: FContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, F.schema);
    this.contents = opts?.contents ?? operations.zero(F.schema.contents);
  }
}

export type FfAttributes = Record<string, unknown>;

export type FfContents = [];

/**
 * The `<ff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ff>` element represents a fortissimo dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ff/}
 */
export class Ff implements XMLElement<'ff', FfAttributes, FfContents> {
  static readonly schema = { name: 'ff', attributes: {}, contents: [] } as const;

  readonly schema = Ff.schema;

  attributes: FfAttributes;
  contents: FfContents;

  constructor(opts?: { attributes?: Partial<FfAttributes>; contents?: FfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ff.schema);
    this.contents = opts?.contents ?? operations.zero(Ff.schema.contents);
  }
}

export type FffAttributes = Record<string, unknown>;

export type FffContents = [];

/**
 * The `<fff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fff>` element represents a triple forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fff/}
 */
export class Fff implements XMLElement<'fff', FffAttributes, FffContents> {
  static readonly schema = { name: 'fff', attributes: {}, contents: [] } as const;

  readonly schema = Fff.schema;

  attributes: FffAttributes;
  contents: FffContents;

  constructor(opts?: { attributes?: Partial<FffAttributes>; contents?: FffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fff.schema);
    this.contents = opts?.contents ?? operations.zero(Fff.schema.contents);
  }
}

export type FfffAttributes = Record<string, unknown>;

export type FfffContents = [];

/**
 * The `<ffff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ffff>` element represents an ffff dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ffff/}
 */
export class Ffff implements XMLElement<'ffff', FfffAttributes, FfffContents> {
  static readonly schema = { name: 'ffff', attributes: {}, contents: [] } as const;

  readonly schema = Ffff.schema;

  attributes: FfffAttributes;
  contents: FfffContents;

  constructor(opts?: { attributes?: Partial<FfffAttributes>; contents?: FfffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ffff.schema);
    this.contents = opts?.contents ?? operations.zero(Ffff.schema.contents);
  }
}

export type FffffAttributes = Record<string, unknown>;

export type FffffContents = [];

/**
 * The `<fffff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fffff>` element represents an fffff dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fffff/}
 */
export class Fffff implements XMLElement<'fffff', FffffAttributes, FffffContents> {
  static readonly schema = { name: 'fffff', attributes: {}, contents: [] } as const;

  readonly schema = Fffff.schema;

  attributes: FffffAttributes;
  contents: FffffContents;

  constructor(opts?: { attributes?: Partial<FffffAttributes>; contents?: FffffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fffff.schema);
    this.contents = opts?.contents ?? operations.zero(Fffff.schema.contents);
  }
}

export type FfffffAttributes = Record<string, unknown>;

export type FfffffContents = [];

/**
 * The `<ffffff>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<ffffff>` element represents an ffffff dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ffffff/}
 */
export class Ffffff implements XMLElement<'ffffff', FfffffAttributes, FfffffContents> {
  static readonly schema = { name: 'ffffff', attributes: {}, contents: [] } as const;

  readonly schema = Ffffff.schema;

  attributes: FfffffAttributes;
  contents: FfffffContents;

  constructor(opts?: { attributes?: Partial<FfffffAttributes>; contents?: FfffffContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ffffff.schema);
    this.contents = opts?.contents ?? operations.zero(Ffffff.schema.contents);
  }
}

export type MpAttributes = Record<string, unknown>;

export type MpContents = [];

/**
 * The `<mp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<mp>` element represents a mezzo piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mp/}
 */
export class Mp implements XMLElement<'mp', MpAttributes, MpContents> {
  static readonly schema = { name: 'mp', attributes: {}, contents: [] } as const;

  readonly schema = Mp.schema;

  attributes: MpAttributes;
  contents: MpContents;

  constructor(opts?: { attributes?: Partial<MpAttributes>; contents?: MpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mp.schema);
    this.contents = opts?.contents ?? operations.zero(Mp.schema.contents);
  }
}

export type MfAttributes = Record<string, unknown>;

export type MfContents = [];

/**
 * The `<mf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<mf>` element represents a mezzo forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mf/}
 */
export class Mf implements XMLElement<'mf', MfAttributes, MfContents> {
  static readonly schema = { name: 'mf', attributes: {}, contents: [] } as const;

  readonly schema = Mf.schema;

  attributes: MfAttributes;
  contents: MfContents;

  constructor(opts?: { attributes?: Partial<MfAttributes>; contents?: MfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mf.schema);
    this.contents = opts?.contents ?? operations.zero(Mf.schema.contents);
  }
}

export type SfAttributes = Record<string, unknown>;

export type SfContents = [];

/**
 * The `<sf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sf>` element represents a sforzando sf dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sf/}
 */
export class Sf implements XMLElement<'sf', SfAttributes, SfContents> {
  static readonly schema = { name: 'sf', attributes: {}, contents: [] } as const;

  readonly schema = Sf.schema;

  attributes: SfAttributes;
  contents: SfContents;

  constructor(opts?: { attributes?: Partial<SfAttributes>; contents?: SfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sf.schema);
    this.contents = opts?.contents ?? operations.zero(Sf.schema.contents);
  }
}

export type SfpAttributes = Record<string, unknown>;

export type SfpContents = [];

/**
 * The `<sfp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfp>` element represents a sforzando piano sfp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfp/}
 */
export class Sfp implements XMLElement<'sfp', SfpAttributes, SfpContents> {
  static readonly schema = { name: 'sfp', attributes: {}, contents: [] } as const;

  readonly schema = Sfp.schema;

  attributes: SfpAttributes;
  contents: SfpContents;

  constructor(opts?: { attributes?: Partial<SfpAttributes>; contents?: SfpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfp.schema);
    this.contents = opts?.contents ?? operations.zero(Sfp.schema.contents);
  }
}

export type SfppAttributes = Record<string, unknown>;

export type SfppContents = [];

/**
 * The `<sfpp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfpp>` element represents a sforzando pianissimo sfpp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfpp/}
 */
export class Sfpp implements XMLElement<'sfpp', SfppAttributes, SfppContents> {
  static readonly schema = { name: 'sfpp', attributes: {}, contents: [] } as const;

  readonly schema = Sfpp.schema;

  attributes: SfppAttributes;
  contents: SfppContents;

  constructor(opts?: { attributes?: Partial<SfppAttributes>; contents?: SfppContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfpp.schema);
    this.contents = opts?.contents ?? operations.zero(Sfpp.schema.contents);
  }
}

export type FpAttributes = Record<string, unknown>;

export type FpContents = [];

/**
 * The `<fp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fp>` element represents a forte piano dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fp/}
 */
export class Fp implements XMLElement<'fp', FpAttributes, FpContents> {
  static readonly schema = { name: 'fp', attributes: {}, contents: [] } as const;

  readonly schema = Fp.schema;

  attributes: FpAttributes;
  contents: FpContents;

  constructor(opts?: { attributes?: Partial<FpAttributes>; contents?: FpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fp.schema);
    this.contents = opts?.contents ?? operations.zero(Fp.schema.contents);
  }
}

export type RfAttributes = Record<string, unknown>;

export type RfContents = [];

/**
 * The `<rf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<rf>` element represents a rinforzando rf dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rf/}
 */
export class Rf implements XMLElement<'rf', RfAttributes, RfContents> {
  static readonly schema = { name: 'rf', attributes: {}, contents: [] } as const;

  readonly schema = Rf.schema;

  attributes: RfAttributes;
  contents: RfContents;

  constructor(opts?: { attributes?: Partial<RfAttributes>; contents?: RfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rf.schema);
    this.contents = opts?.contents ?? operations.zero(Rf.schema.contents);
  }
}

export type RfzAttributes = Record<string, unknown>;

export type RfzContents = [];

/**
 * The `<rfz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<rfz>` element represents a rinforzando rfz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rfz/}
 */
export class Rfz implements XMLElement<'rfz', RfzAttributes, RfzContents> {
  static readonly schema = { name: 'rfz', attributes: {}, contents: [] } as const;

  readonly schema = Rfz.schema;

  attributes: RfzAttributes;
  contents: RfzContents;

  constructor(opts?: { attributes?: Partial<RfzAttributes>; contents?: RfzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rfz.schema);
    this.contents = opts?.contents ?? operations.zero(Rfz.schema.contents);
  }
}

export type SfzAttributes = Record<string, unknown>;

export type SfzContents = [];

/**
 * The `<sfz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfz>` element represents a sforzando sfz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfz/}
 */
export class Sfz implements XMLElement<'sfz', SfzAttributes, SfzContents> {
  static readonly schema = { name: 'sfz', attributes: {}, contents: [] } as const;

  readonly schema = Sfz.schema;

  attributes: SfzAttributes;
  contents: SfzContents;

  constructor(opts?: { attributes?: Partial<SfzAttributes>; contents?: SfzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfz.schema);
    this.contents = opts?.contents ?? operations.zero(Sfz.schema.contents);
  }
}

export type SffzAttributes = Record<string, unknown>;

export type SffzContents = [];

/**
 * The `<sffz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sffz>` element represents a sforzando sffz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sffz/}
 */
export class Sffz implements XMLElement<'sffz', SffzAttributes, SffzContents> {
  static readonly schema = { name: 'sffz', attributes: {}, contents: [] } as const;

  readonly schema = Sffz.schema;

  attributes: SffzAttributes;
  contents: SffzContents;

  constructor(opts?: { attributes?: Partial<SffzAttributes>; contents?: SffzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sffz.schema);
    this.contents = opts?.contents ?? operations.zero(Sffz.schema.contents);
  }
}

export type FzAttributes = Record<string, unknown>;

export type FzContents = [];

/**
 * The `<fz>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<fz>` element represents a forzando fz dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fz/}
 */
export class Fz implements XMLElement<'fz', FzAttributes, FzContents> {
  static readonly schema = { name: 'fz', attributes: {}, contents: [] } as const;

  readonly schema = Fz.schema;

  attributes: FzAttributes;
  contents: FzContents;

  constructor(opts?: { attributes?: Partial<FzAttributes>; contents?: FzContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fz.schema);
    this.contents = opts?.contents ?? operations.zero(Fz.schema.contents);
  }
}

export type NAttributes = Record<string, unknown>;

export type NContents = [];

/**
 * The `<n>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<n>` element represents a niente dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/n/}
 */
export class N implements XMLElement<'n', NAttributes, NContents> {
  static readonly schema = { name: 'n', attributes: {}, contents: [] } as const;

  readonly schema = N.schema;

  attributes: NAttributes;
  contents: NContents;

  constructor(opts?: { attributes?: Partial<NAttributes>; contents?: NContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, N.schema);
    this.contents = opts?.contents ?? operations.zero(N.schema.contents);
  }
}

export type PfAttributes = Record<string, unknown>;

export type PfContents = [];

/**
 * The `<pf>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<pf>` element represents a piano forte dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pf/}
 */
export class Pf implements XMLElement<'pf', PfAttributes, PfContents> {
  static readonly schema = { name: 'pf', attributes: {}, contents: [] } as const;

  readonly schema = Pf.schema;

  attributes: PfAttributes;
  contents: PfContents;

  constructor(opts?: { attributes?: Partial<PfAttributes>; contents?: PfContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pf.schema);
    this.contents = opts?.contents ?? operations.zero(Pf.schema.contents);
  }
}

export type SfzpAttributes = Record<string, unknown>;

export type SfzpContents = [];

/**
 * The `<sfzp>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<sfzp>` element represents a sforzando piano sfzp dynamic marking.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sfzp/}
 */
export class Sfzp implements XMLElement<'sfzp', SfzpAttributes, SfzpContents> {
  static readonly schema = { name: 'sfzp', attributes: {}, contents: [] } as const;

  readonly schema = Sfzp.schema;

  attributes: SfzpAttributes;
  contents: SfzpContents;

  constructor(opts?: { attributes?: Partial<SfzpAttributes>; contents?: SfzpContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sfzp.schema);
    this.contents = opts?.contents ?? operations.zero(Sfzp.schema.contents);
  }
}

export type OtherDynamicsAttributes = {
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type OtherDynamicsContents = [string];

/**
 * The `<other-dynamics>` element
 *
 * Parent element: `<dynamics>`
 *
 * The `<other-dynamics>` element allows other dynamic marks that are not covered by combinations of the individual
 * `<dynamics>` child elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-dynamics/}
 */
export class OtherDynamics implements XMLElement<'other-dynamics', OtherDynamicsAttributes, OtherDynamicsContents> {
  static readonly schema = {
    name: 'other-dynamics',
    attributes: { smufl: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherDynamics.schema;

  attributes: OtherDynamicsAttributes;
  contents: OtherDynamicsContents;

  constructor(opts?: { attributes?: Partial<OtherDynamicsAttributes>; contents?: OtherDynamicsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherDynamics.schema);
    this.contents = opts?.contents ?? operations.zero(OtherDynamics.schema.contents);
  }
  /** Gets @type {OtherDynamicsAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OtherDynamicsAttributes['smufl']}. */
  setSmufl(smufl: string | null): OtherDynamics {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type DynamicsAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   *
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type DynamicsContents = [
  Array<
    | P
    | Pp
    | Ppp
    | Pppp
    | Ppppp
    | Pppppp
    | F
    | Ff
    | Fff
    | Ffff
    | Fffff
    | Fffff
    | Ffffff
    | Mp
    | Mf
    | Sf
    | Sfp
    | Sfpp
    | Fp
    | Rf
    | Rfz
    | Sfz
    | Sffz
    | Fz
    | N
    | Pf
    | Sfzp
    | OtherDynamics
  >,
];

/**
 * The `<dynamics>` element
 *
 * Parent elements: `<direction-type>`, `<notations>`
 *
 * Dynamics can be associated either with a note or a general musical direction. To avoid inconsistencies between and
 * amongst the letter abbreviations for dynamics (what is sf vs. sfz, standing alone or with a trailing dynamic that is
 * not always piano), we use the actual letters as the names of these dynamic elements. The `<other-dynamics>` element
 * allows other dynamic marks that are not covered here. Dynamics elements may also be combined to create marks not
 * covered by a single element, such as `<sf/>``<mp/>`.
 *
 * These letter dynamic symbols are separated from crescendo, decrescendo, and wedge indications. Dynamic representation
 * is inconsistent in scores. Many things are assumed by the composer and left out, such as returns to original
 * dynamics. The MusicXML format captures what is in the score, but does not try to be optimal for analysis or synthesis
 * of dynamics.
 *
 * The placement attribute is used when the dynamics are associated with a `<note>`. It is ignored when the dynamics are
 * associated with a `<direction>`. In that case the `<direction>` element's placement attribute is used instead.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/dynamics/}
 */
export class Dynamics implements XMLElement<'dynamics', DynamicsAttributes, DynamicsContents> {
  static readonly schema = {
    name: 'dynamics',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              P,
              Pp,
              Ppp,
              Pppp,
              Ppppp,
              Pppppp,
              F,
              Ff,
              Fff,
              Ffff,
              Fffff,
              Fffff,
              Ffffff,
              Mp,
              Mf,
              Sf,
              Sfp,
              Sfpp,
              Fp,
              Rf,
              Rfz,
              Sfz,
              Sffz,
              Fz,
              N,
              Pf,
              Sfzp,
              OtherDynamics,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Dynamics.schema;

  attributes: DynamicsAttributes;
  contents: DynamicsContents;

  constructor(opts?: { attributes?: Partial<DynamicsAttributes>; contents?: DynamicsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Dynamics.schema);
    this.contents = opts?.contents ?? operations.zero(Dynamics.schema.contents);
  }
  /** Gets @type {DynamicsAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DynamicsAttributes['color']}. */
  setColor(color: string | null): Dynamics {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DynamicsAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DynamicsAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Dynamics {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DynamicsAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DynamicsAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Dynamics {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DynamicsAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {DynamicsAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Dynamics {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {DynamicsAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DynamicsAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Dynamics {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DynamicsAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DynamicsAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Dynamics {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DynamicsAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DynamicsAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Dynamics {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DynamicsAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DynamicsAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Dynamics {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DynamicsAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {DynamicsAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Dynamics {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {DynamicsAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {DynamicsAttributes['id']}. */
  setId(id: string | null): Dynamics {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {DynamicsAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {DynamicsAttributes['overline']}. */
  setOverline(overline: number | null): Dynamics {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {DynamicsAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DynamicsAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Dynamics {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DynamicsAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {DynamicsAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): Dynamics {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {DynamicsAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DynamicsAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Dynamics {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DynamicsAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DynamicsAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Dynamics {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DynamicsAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {DynamicsAttributes['underline']}. */
  setUnderline(underline: number | null): Dynamics {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {DynamicsAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {DynamicsAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Dynamics {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {Array<P | Pp | Ppp | Pppp | Ppppp | Pppppp | F | Ff | Fff | Ffff | Fffff | Fffff | Ffffff | Mp | Mf | Sf | Sfp | Sfpp | Fp | Rf | Rfz | Sfz | Sffz | Fz | N | Pf | Sfzp | OtherDynamics>}. */
  getValue(): Array<
    | P
    | Pp
    | Ppp
    | Pppp
    | Ppppp
    | Pppppp
    | F
    | Ff
    | Fff
    | Ffff
    | Fffff
    | Fffff
    | Ffffff
    | Mp
    | Mf
    | Sf
    | Sfp
    | Sfpp
    | Fp
    | Rf
    | Rfz
    | Sfz
    | Sffz
    | Fz
    | N
    | Pf
    | Sfzp
    | OtherDynamics
  > {
    return this.contents[0];
  }
  /** Sets @type {Array<P | Pp | Ppp | Pppp | Ppppp | Pppppp | F | Ff | Fff | Ffff | Fffff | Fffff | Ffffff | Mp | Mf | Sf | Sfp | Sfpp | Fp | Rf | Rfz | Sfz | Sffz | Fz | N | Pf | Sfzp | OtherDynamics>}. */
  setValue(
    value: Array<
      | P
      | Pp
      | Ppp
      | Pppp
      | Ppppp
      | Pppppp
      | F
      | Ff
      | Fff
      | Ffff
      | Fffff
      | Fffff
      | Ffffff
      | Mp
      | Mf
      | Sf
      | Sfp
      | Sfpp
      | Fp
      | Rf
      | Rfz
      | Sfz
      | Sffz
      | Fz
      | N
      | Pf
      | Sfzp
      | OtherDynamics
    >
  ): this {
    this.contents[0] = value;
    return this;
  }
}

export type FermataAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The type describes whether a fermata is upright or inverted. It is upright if not specified.
   */
  type: 'upright' | 'inverted' | null;
};

export type FermataContents = [
  '' | 'normal' | 'angled' | 'square' | 'double-angled' | 'double-square' | 'double-dot' | 'half-curve' | 'curlew',
];

/**
 * The `<fermata>` element
 *
 * Parent elements: `<barline>`, `<notations>`
 *
 * The `<fermata>` element content represents the shape of the fermata sign. An empty `<fermata>` element represents a
 * normal fermata.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fermata/}
 */
export class Fermata implements XMLElement<'fermata', FermataAttributes, FermataContents> {
  static readonly schema = {
    name: 'fermata',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      type: { type: 'optional', value: { type: 'choices', choices: ['upright', 'inverted'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'fermata-shape',
          value: {
            type: 'choices',
            choices: [
              '',
              'normal',
              'angled',
              'square',
              'double-angled',
              'double-square',
              'double-dot',
              'half-curve',
              'curlew',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Fermata.schema;

  attributes: FermataAttributes;
  contents: FermataContents;

  constructor(opts?: { attributes?: Partial<FermataAttributes>; contents?: FermataContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fermata.schema);
    this.contents = opts?.contents ?? operations.zero(Fermata.schema.contents);
  }
  /** Gets @type {FermataAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FermataAttributes['color']}. */
  setColor(color: string | null): Fermata {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FermataAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FermataAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Fermata {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FermataAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FermataAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Fermata {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FermataAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FermataAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Fermata {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FermataAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FermataAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Fermata {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FermataAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FermataAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Fermata {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FermataAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FermataAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Fermata {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FermataAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {FermataAttributes['id']}. */
  setId(id: string | null): Fermata {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {FermataAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FermataAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Fermata {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FermataAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FermataAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Fermata {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {FermataAttributes['type']}. */
  getType(): 'upright' | 'inverted' | null {
    return this.attributes['type'];
  }
  /** Sets @type {FermataAttributes['type']}. */
  setType(type: 'upright' | 'inverted' | null): Fermata {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {'' | 'normal' | 'angled' | 'square' | 'double-angled' | 'double-square' | 'double-dot' | 'half-curve' | 'curlew'}. */
  getFermataShape():
    | ''
    | 'normal'
    | 'angled'
    | 'square'
    | 'double-angled'
    | 'double-square'
    | 'double-dot'
    | 'half-curve'
    | 'curlew' {
    return this.contents[0];
  }
  /** Sets @type {'' | 'normal' | 'angled' | 'square' | 'double-angled' | 'double-square' | 'double-dot' | 'half-curve' | 'curlew'}. */
  setFermataShape(
    fermataShape:
      | ''
      | 'normal'
      | 'angled'
      | 'square'
      | 'double-angled'
      | 'double-square'
      | 'double-dot'
      | 'half-curve'
      | 'curlew'
  ): this {
    this.contents[0] = fermataShape;
    return this;
  }
}

export type ArpeggiateAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Used if there is an arrow on the arpeggio sign. By default, arpeggios go from the lowest to highest note.
   */
  direction: 'up' | 'down' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Used to distinguish between two simultaneous chords arpeggiated separately (different numbers) or together
   * (same number).
   */
  number: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * If yes, indicates that the arpeggio continues onto another staff within the part. This serves as a hint to
   * applications and is not required for cross-staff arpeggios.
   */
  unbroken: 'yes' | 'no' | null;
};

export type ArpeggiateContents = [];

/**
 * The `<arpeggiate>` element
 *
 * Parent element: `<notations>`
 *
 * The `<arpeggiate>` element indicates that this note is part of an arpeggiated chord. The length of the sign can be
 * determined from the position attributes for the `<arpeggiate>` elements used with the top and bottom notes of the
 * arpeggiated chord.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/arpeggiate/}
 */
export class Arpeggiate implements XMLElement<'arpeggiate', ArpeggiateAttributes, ArpeggiateContents> {
  static readonly schema = {
    name: 'arpeggiate',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      direction: { type: 'optional', value: { type: 'choices', choices: ['up', 'down'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      unbroken: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Arpeggiate.schema;

  attributes: ArpeggiateAttributes;
  contents: ArpeggiateContents;

  constructor(opts?: { attributes?: Partial<ArpeggiateAttributes>; contents?: ArpeggiateContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Arpeggiate.schema);
    this.contents = opts?.contents ?? operations.zero(Arpeggiate.schema.contents);
  }
  /** Gets @type {ArpeggiateAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ArpeggiateAttributes['color']}. */
  setColor(color: string | null): Arpeggiate {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ArpeggiateAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Arpeggiate {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ArpeggiateAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Arpeggiate {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['direction']}. */
  getDirection(): 'up' | 'down' | null {
    return this.attributes['direction'];
  }
  /** Sets @type {ArpeggiateAttributes['direction']}. */
  setDirection(direction: 'up' | 'down' | null): Arpeggiate {
    this.attributes['direction'] = direction;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {ArpeggiateAttributes['id']}. */
  setId(id: string | null): Arpeggiate {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {ArpeggiateAttributes['number']}. */
  setNumber(number: number | null): Arpeggiate {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {ArpeggiateAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Arpeggiate {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ArpeggiateAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Arpeggiate {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ArpeggiateAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Arpeggiate {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {ArpeggiateAttributes['unbroken']}. */
  getUnbroken(): 'yes' | 'no' | null {
    return this.attributes['unbroken'];
  }
  /** Sets @type {ArpeggiateAttributes['unbroken']}. */
  setUnbroken(unbroken: 'yes' | 'no' | null): Arpeggiate {
    this.attributes['unbroken'] = unbroken;
    return this;
  }
}

export type NonArpeggiateAttributes = {
  /**
   * Indicates whether this is the top or bottom of the symbol.
   */
  type: 'top' | 'bottom';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Used to distinguish between two simultaneous chords arpeggiated separately (different numbers) or together
   * (same number).
   */
  number: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
};

export type NonArpeggiateContents = [];

/**
 * The `<non-arpeggiate>` element
 *
 * Parent element: `<notations>`
 *
 * The `<non-arpeggiate>` element indicates that this `<note>` is at the top or bottom of a bracket indicating to not
 * arpeggiate these notes. Since this does not involve playback, it is only used on the top or bottom notes, not on each
 * `<note>` as for the `<arpeggiate>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/non-arpeggiate/}
 */
export class NonArpeggiate implements XMLElement<'non-arpeggiate', NonArpeggiateAttributes, NonArpeggiateContents> {
  static readonly schema = {
    name: 'non-arpeggiate',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['top', 'bottom'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [],
  } as const;

  readonly schema = NonArpeggiate.schema;

  attributes: NonArpeggiateAttributes;
  contents: NonArpeggiateContents;

  constructor(opts?: { attributes?: Partial<NonArpeggiateAttributes>; contents?: NonArpeggiateContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NonArpeggiate.schema);
    this.contents = opts?.contents ?? operations.zero(NonArpeggiate.schema.contents);
  }
  /** Gets @type {NonArpeggiateAttributes['type']}. */
  getType(): 'top' | 'bottom' {
    return this.attributes['type'];
  }
  /** Sets @type {NonArpeggiateAttributes['type']}. */
  setType(type: 'top' | 'bottom'): NonArpeggiate {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {NonArpeggiateAttributes['color']}. */
  setColor(color: string | null): NonArpeggiate {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {NonArpeggiateAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): NonArpeggiate {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {NonArpeggiateAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): NonArpeggiate {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {NonArpeggiateAttributes['id']}. */
  setId(id: string | null): NonArpeggiate {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {NonArpeggiateAttributes['number']}. */
  setNumber(number: number | null): NonArpeggiate {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {NonArpeggiateAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): NonArpeggiate {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {NonArpeggiateAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): NonArpeggiate {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {NonArpeggiateAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {NonArpeggiateAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): NonArpeggiate {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
}

export type OtherNotationAttributes = {
  /**
   * Indicates if this is a single-note notation, or the start or stop of a multi-note notation.
   */
  type: 'start' | 'stop' | 'single';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Used to distinguish between two simultaneous chords arpeggiated separately (different numbers) or together
   * (same number).
   */
  number: number | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type OtherNotationContents = [string];

/**
 * The `<other-notation>` element
 *
 * Parent element: `<notations>`
 *
 * The `<other-notation>` element is used to define any notations not yet in the MusicXML format. It handles notations
 * where more specific extension elements such as `<other-dynamics>` and `<other-technical>` are not appropriate.
 *
 * The smufl attribute can be used to specify a particular notation, allowing application interoperability without
 * requiring every Standard Music Font Layout (SMuFL) glyph to have a MusicXML element equivalent. Using the
 * `<other-notation>` element without the smufl attribute allows for extended representation, though without application
 * interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-notation/}
 */
export class OtherNotation implements XMLElement<'other-notation', OtherNotationAttributes, OtherNotationContents> {
  static readonly schema = {
    name: 'other-notation',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherNotation.schema;

  attributes: OtherNotationAttributes;
  contents: OtherNotationContents;

  constructor(opts?: { attributes?: Partial<OtherNotationAttributes>; contents?: OtherNotationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherNotation.schema);
    this.contents = opts?.contents ?? operations.zero(OtherNotation.schema.contents);
  }
  /** Gets @type {OtherNotationAttributes['type']}. */
  getType(): 'start' | 'stop' | 'single' {
    return this.attributes['type'];
  }
  /** Sets @type {OtherNotationAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'single'): OtherNotation {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OtherNotationAttributes['color']}. */
  setColor(color: string | null): OtherNotation {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OtherNotationAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): OtherNotation {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OtherNotationAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): OtherNotation {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {OtherNotationAttributes['id']}. */
  setId(id: string | null): OtherNotation {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {OtherNotationAttributes['number']}. */
  setNumber(number: number | null): OtherNotation {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {OtherNotationAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): OtherNotation {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OtherNotationAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): OtherNotation {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OtherNotationAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): OtherNotation {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {OtherNotationAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OtherNotationAttributes['smufl']}. */
  setSmufl(smufl: string | null): OtherNotation {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type NotationsAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
};

export type NotationsContents = [
  Footnote | null,
  Level | null,
  Array<
    | Tied
    | Slur
    | Tuplet
    | Glissando
    | Slide
    | Ornaments
    | Technical
    | Articulations
    | Dynamics
    | Fermata
    | Arpeggiate
    | NonArpeggiate
    | AccidentalMark
    | OtherNotation
  >,
];

/**
 * The `<notations>` element
 *
 * Parent element: `<note>`
 *
 * The `<notations>` element collects musical notations that apply to a specific note or chord. Multiple `<notations>`
 * elements are allowed in order to represent multiple editorial levels. The print-object attribute allows `<notations>`
 * to represent details of performance technique, such as fingerings, without having them appear in the score. This
 * element is not related to the concept of XML notations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/notations/}
 */
export class Notations implements XMLElement<'notations', NotationsAttributes, NotationsContents> {
  static readonly schema = {
    name: 'notations',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      {
        type: 'label',
        label: 'values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Tied,
              Slur,
              Tuplet,
              Glissando,
              Slide,
              Ornaments,
              Technical,
              Articulations,
              Dynamics,
              Fermata,
              Arpeggiate,
              NonArpeggiate,
              AccidentalMark,
              OtherNotation,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Notations.schema;

  attributes: NotationsAttributes;
  contents: NotationsContents;

  constructor(opts?: { attributes?: Partial<NotationsAttributes>; contents?: NotationsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Notations.schema);
    this.contents = opts?.contents ?? operations.zero(Notations.schema.contents);
  }
  /** Gets @type {NotationsAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {NotationsAttributes['id']}. */
  setId(id: string | null): Notations {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {NotationsAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {NotationsAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Notations {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[0];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[0] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[1];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[1] = level;
    return this;
  }
  /** Gets @type {Array<Tied | Slur | Tuplet | Glissando | Slide | Ornaments | Technical | Articulations | Dynamics | Fermata | Arpeggiate | NonArpeggiate | AccidentalMark | OtherNotation>}. */
  getValues(): Array<
    | Tied
    | Slur
    | Tuplet
    | Glissando
    | Slide
    | Ornaments
    | Technical
    | Articulations
    | Dynamics
    | Fermata
    | Arpeggiate
    | NonArpeggiate
    | AccidentalMark
    | OtherNotation
  > {
    return this.contents[2];
  }
  /** Sets @type {Array<Tied | Slur | Tuplet | Glissando | Slide | Ornaments | Technical | Articulations | Dynamics | Fermata | Arpeggiate | NonArpeggiate | AccidentalMark | OtherNotation>}. */
  setValues(
    values: Array<
      | Tied
      | Slur
      | Tuplet
      | Glissando
      | Slide
      | Ornaments
      | Technical
      | Articulations
      | Dynamics
      | Fermata
      | Arpeggiate
      | NonArpeggiate
      | AccidentalMark
      | OtherNotation
    >
  ): this {
    this.contents[2] = values;
    return this;
  }
}

export type SyllabicAttributes = Record<string, unknown>;

export type SyllabicContents = ['begin' | 'end' | 'middle' | 'single'];

/**
 * The `<syllabic>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<syllabic>` element indicates lyric hyphenation. The single, begin, end, and middle values represent
 * single-syllable words, word-beginning syllables, word-ending syllables, and mid-word syllables, respectively.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/syllabic/}
 */
export class Syllabic implements XMLElement<'syllabic', SyllabicAttributes, SyllabicContents> {
  static readonly schema = {
    name: 'syllabic',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'syllabic',
          value: { type: 'choices', choices: ['begin', 'end', 'middle', 'single'] },
        },
      },
    ],
  } as const;

  readonly schema = Syllabic.schema;

  attributes: SyllabicAttributes;
  contents: SyllabicContents;

  constructor(opts?: { attributes?: Partial<SyllabicAttributes>; contents?: SyllabicContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Syllabic.schema);
    this.contents = opts?.contents ?? operations.zero(Syllabic.schema.contents);
  }

  /** Gets @type {'begin' | 'end' | 'middle' | 'single'}. */
  getSyllabic(): 'begin' | 'end' | 'middle' | 'single' {
    return this.contents[0];
  }
  /** Sets @type {'begin' | 'end' | 'middle' | 'single'}. */
  setSyllabic(syllabic: 'begin' | 'end' | 'middle' | 'single'): this {
    this.contents[0] = syllabic;
    return this;
  }
}

export type TextAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in
   * [the W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Specifies the language used in the element content.
   */
  'xml:lang': string | null;
};

export type TextContents = [string];

/**
 * The `<text>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<text>` element represents a syllable or portion of a syllable for lyric text underlay. A hyphen in the element
 * content should only be used for an actual hyphenated word.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/text/}
 */
export class Text implements XMLElement<'text', TextAttributes, TextContents> {
  static readonly schema = {
    name: 'text',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = Text.schema;

  attributes: TextAttributes;
  contents: TextContents;

  constructor(opts?: { attributes?: Partial<TextAttributes>; contents?: TextContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Text.schema);
    this.contents = opts?.contents ?? operations.zero(Text.schema.contents);
  }
  /** Gets @type {TextAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TextAttributes['color']}. */
  setColor(color: string | null): Text {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TextAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {TextAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Text {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {TextAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TextAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Text {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TextAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TextAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Text {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TextAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TextAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Text {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TextAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TextAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Text {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TextAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TextAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Text {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TextAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TextAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Text {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TextAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {TextAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): Text {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {TextAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {TextAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): Text {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {TextAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {TextAttributes['overline']}. */
  setOverline(overline: number | null): Text {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {TextAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {TextAttributes['rotation']}. */
  setRotation(rotation: number | null): Text {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {TextAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {TextAttributes['underline']}. */
  setUnderline(underline: number | null): Text {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {TextAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {TextAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): Text {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type ElisionAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Used to specify the elision symbol to use if the element text content is empty. It is ignored otherwise.
   */
  smufl: string | null;
};

export type ElisionContents = [];

/**
 * The `<elision>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<elision>` element represents an elision between lyric syllables. The text content specifies the symbol used to
 * display the elision. Common values are a no-break space (Unicode 00A0), an underscore (Unicode 005F), or an undertie
 * (Unicode 203F). If the text content is empty, the smufl attribute is used to specify the symbol to use. If neither
 * text content nor a smufl attribute are present, the elision glyph is application-specific.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/elision/}
 */
export class Elision implements XMLElement<'elision', ElisionAttributes, ElisionContents> {
  static readonly schema = {
    name: 'elision',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      smufl: { type: 'optional', value: { type: 'regex', pattern: /lyrics/, zero: 'lyrics' } },
    },
    contents: [],
  } as const;

  readonly schema = Elision.schema;

  attributes: ElisionAttributes;
  contents: ElisionContents;

  constructor(opts?: { attributes?: Partial<ElisionAttributes>; contents?: ElisionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Elision.schema);
    this.contents = opts?.contents ?? operations.zero(Elision.schema.contents);
  }
  /** Gets @type {ElisionAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ElisionAttributes['color']}. */
  setColor(color: string | null): Elision {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ElisionAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {ElisionAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Elision {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {ElisionAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {ElisionAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Elision {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {ElisionAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {ElisionAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Elision {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {ElisionAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {ElisionAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Elision {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {ElisionAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {ElisionAttributes['smufl']}. */
  setSmufl(smufl: string | null): Elision {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type ExtendAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the `<offset>` element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down. It should be interpreted
   * in the context of the placement attribute if that is present.
   */
  'relative-y': number | null;
  /**
   * Indicates if this is the start, stop, or continuation of the extension. Before Version 3.0 this attribute was
   * not available, and an `<extend>` element was always treated as the start of the extension.
   */
  type: 'start' | 'stop' | 'continue' | null;
};

export type ExtendContents = [];

/**
 * The `<extend>` element
 *
 * Parent elements: `<figure>`, `<lyric>`
 *
 * The `<extend>` element represents lyric word extension / melisma lines as well as figured bass extensions.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/extend/}
 */
export class Extend implements XMLElement<'extend', ExtendAttributes, ExtendContents> {
  static readonly schema = {
    name: 'extend',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      type: { type: 'optional', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
    },
    contents: [],
  } as const;

  readonly schema = Extend.schema;

  attributes: ExtendAttributes;
  contents: ExtendContents;

  constructor(opts?: { attributes?: Partial<ExtendAttributes>; contents?: ExtendContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Extend.schema);
    this.contents = opts?.contents ?? operations.zero(Extend.schema.contents);
  }
  /** Gets @type {ExtendAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ExtendAttributes['color']}. */
  setColor(color: string | null): Extend {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ExtendAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ExtendAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Extend {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ExtendAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ExtendAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Extend {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ExtendAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ExtendAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Extend {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ExtendAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ExtendAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Extend {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {ExtendAttributes['type']}. */
  getType(): 'start' | 'stop' | 'continue' | null {
    return this.attributes['type'];
  }
  /** Sets @type {ExtendAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'continue' | null): Extend {
    this.attributes['type'] = type;
    return this;
  }
}

export type LaughingAttributes = Record<string, unknown>;

export type LaughingContents = [];

/**
 * The `<laughing>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<laughing>` element represents a laughing voice.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/laughing/}
 */
export class Laughing implements XMLElement<'laughing', LaughingAttributes, LaughingContents> {
  static readonly schema = { name: 'laughing', attributes: {}, contents: [] } as const;

  readonly schema = Laughing.schema;

  attributes: LaughingAttributes;
  contents: LaughingContents;

  constructor(opts?: { attributes?: Partial<LaughingAttributes>; contents?: LaughingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Laughing.schema);
    this.contents = opts?.contents ?? operations.zero(Laughing.schema.contents);
  }
}

export type HummingAttributes = Record<string, unknown>;

export type HummingContents = [];

/**
 * The `<humming>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<humming>` element represents a humming voice.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/humming/}
 */
export class Humming implements XMLElement<'humming', HummingAttributes, HummingContents> {
  static readonly schema = { name: 'humming', attributes: {}, contents: [] } as const;

  readonly schema = Humming.schema;

  attributes: HummingAttributes;
  contents: HummingContents;

  constructor(opts?: { attributes?: Partial<HummingAttributes>; contents?: HummingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Humming.schema);
    this.contents = opts?.contents ?? operations.zero(Humming.schema.contents);
  }
}

export type EndLineAttributes = Record<string, unknown>;

export type EndLineContents = [];

/**
 * The `<end-line>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<end-line>` element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for
 * Karaoke and similar applications.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/end-line/}
 */
export class EndLine implements XMLElement<'end-line', EndLineAttributes, EndLineContents> {
  static readonly schema = { name: 'end-line', attributes: {}, contents: [] } as const;

  readonly schema = EndLine.schema;

  attributes: EndLineAttributes;
  contents: EndLineContents;

  constructor(opts?: { attributes?: Partial<EndLineAttributes>; contents?: EndLineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EndLine.schema);
    this.contents = opts?.contents ?? operations.zero(EndLine.schema.contents);
  }
}

export type EndParagraphAttributes = Record<string, unknown>;

export type EndParagraphContents = [];

/**
 * The `<end-paragraph>` element
 *
 * Parent element: `<lyric>`
 *
 * The `<end-paragraph>` element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric
 * display for Karaoke and similar applications.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/end-paragraph/}
 */
export class EndParagraph implements XMLElement<'end-paragraph', EndParagraphAttributes, EndParagraphContents> {
  static readonly schema = { name: 'end-paragraph', attributes: {}, contents: [] } as const;

  readonly schema = EndParagraph.schema;

  attributes: EndParagraphAttributes;
  contents: EndParagraphContents;

  constructor(opts?: { attributes?: Partial<EndParagraphAttributes>; contents?: EndParagraphContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, EndParagraph.schema);
    this.contents = opts?.contents ?? operations.zero(EndParagraph.schema.contents);
  }
}

export type Intelligible = [Syllabic | null, Text, Array<[[Elision, Syllabic | null] | null, Text]>, Extend | null];

export type LyricAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Indicates the name of the lyric type. Common examples are verse and chorus.
   */
  name: string | null;
  /**
   * Specifies the lyric line when multiple lines are present.
   */
  number: string | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Specifies which lyrics are to be sung which times through a repeated section.
   */
  'time-only': string | null;
};

export type LyricContents = [
  Intelligible | Extend | Laughing | Humming,
  EndLine | null,
  EndParagraph | null,
  Footnote | null,
  Level | null,
];

/**
 * The `<lyric>` element
 *
 * Parent element: `<note>`
 *
 * The `<lyric>` element represents text underlays for lyrics. Two `<text>` elements that are not separated by an
 * `<elision>` element are part of the same syllable, but may have different text formatting. A second `<syllabic>`
 * element is not allowed unless preceded by an `<elision>` element.
 *
 * If not otherwise specified:
 *
 * - The justify value is center.
 * - The placement value is below.
 * - The valign value is baseline.
 * - The halign value matches the justify value.
 *
 * The print-object attribute can override a `<note>`'s print-lyric attribute in cases where only some lyrics on a note
 * are printed, as when lyrics for later verses are printed in a block of text rather than with each note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/lyric/}
 */
export class Lyric implements XMLElement<'lyric', LyricAttributes, LyricContents> {
  static readonly schema = {
    name: 'lyric',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      name: { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'intelligible',
              value: [
                { type: 'optional', value: Syllabic },
                { type: 'required', value: Text },
                {
                  type: 'zeroOrMore',
                  value: [
                    {
                      type: 'optional',
                      value: [
                        { type: 'required', value: Elision },
                        { type: 'optional', value: Syllabic },
                      ],
                    },
                    { type: 'required', value: Text },
                  ],
                },
                { type: 'optional', value: Extend },
              ],
            },
            Extend,
            Laughing,
            Humming,
          ],
        },
      },
      { type: 'optional', value: EndLine },
      { type: 'optional', value: EndParagraph },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = Lyric.schema;

  attributes: LyricAttributes;
  contents: LyricContents;

  constructor(opts?: { attributes?: Partial<LyricAttributes>; contents?: LyricContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Lyric.schema);
    this.contents = opts?.contents ?? operations.zero(Lyric.schema.contents);
  }
  /** Gets @type {LyricAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {LyricAttributes['color']}. */
  setColor(color: string | null): Lyric {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {LyricAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {LyricAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Lyric {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {LyricAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {LyricAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Lyric {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {LyricAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {LyricAttributes['id']}. */
  setId(id: string | null): Lyric {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {LyricAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {LyricAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): Lyric {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {LyricAttributes['name']}. */
  getName(): string | null {
    return this.attributes['name'];
  }
  /** Sets @type {LyricAttributes['name']}. */
  setName(name: string | null): Lyric {
    this.attributes['name'] = name;
    return this;
  }
  /** Gets @type {LyricAttributes['number']}. */
  getNumber(): string | null {
    return this.attributes['number'];
  }
  /** Sets @type {LyricAttributes['number']}. */
  setNumber(number: string | null): Lyric {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {LyricAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {LyricAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Lyric {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {LyricAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {LyricAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Lyric {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {LyricAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {LyricAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Lyric {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {LyricAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {LyricAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Lyric {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {LyricAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {LyricAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): Lyric {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  /** Gets @type {Intelligible | Extend | Laughing | Humming}. */
  getValue(): Intelligible | Extend | Laughing | Humming {
    return this.contents[0];
  }
  /** Sets @type {Intelligible | Extend | Laughing | Humming}. */
  setValue(value: Intelligible | Extend | Laughing | Humming): this {
    this.contents[0] = value;
    return this;
  }
  /** Gets @type {EndLine | null}. */
  getEndLine(): EndLine | null {
    return this.contents[1];
  }
  /** Sets @type {EndLine | null}. */
  setEndLine(endLine: EndLine | null): this {
    this.contents[1] = endLine;
    return this;
  }
  /** Gets @type {EndParagraph | null}. */
  getEndParagraph(): EndParagraph | null {
    return this.contents[2];
  }
  /** Sets @type {EndParagraph | null}. */
  setEndParagraph(endParagraph: EndParagraph | null): this {
    this.contents[2] = endParagraph;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[3];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[3] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[4];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[4] = level;
    return this;
  }
}

export type IpaAttributes = Record<string, unknown>;

export type IpaContents = [string];

/**
 * The `<ipa>` element
 *
 * Parent element: `<play>`
 *
 * The `<ipa>` element represents International Phonetic Alphabet (IPA) sounds for vocal music. String content is
 * limited to IPA 2015 symbols represented in Unicode 13.0.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ipa/}
 */
export class Ipa implements XMLElement<'ipa', IpaAttributes, IpaContents> {
  static readonly schema = {
    name: 'ipa',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Ipa.schema;

  attributes: IpaAttributes;
  contents: IpaContents;

  constructor(opts?: { attributes?: Partial<IpaAttributes>; contents?: IpaContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ipa.schema);
    this.contents = opts?.contents ?? operations.zero(Ipa.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MuteAttributes = Record<string, unknown>;

export type MuteContents = [
  | 'on'
  | 'off'
  | 'bucket'
  | 'cup'
  | 'echo'
  | 'harmon-no-stem'
  | 'harmon-stem'
  | 'hat'
  | 'palm'
  | 'plunger'
  | 'practice'
  | 'solotone'
  | 'stop-hand'
  | 'stop-mute'
  | 'straight',
];

/**
 * The `<mute>` element
 *
 * Parent element: `<play>`
 *
 * The `<mute>` element represents muting playback for different instruments, including brass, winds, and strings.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mute/}
 */
export class Mute implements XMLElement<'mute', MuteAttributes, MuteContents> {
  static readonly schema = {
    name: 'mute',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'mute',
          value: {
            type: 'choices',
            choices: [
              'on',
              'off',
              'bucket',
              'cup',
              'echo',
              'harmon-no-stem',
              'harmon-stem',
              'hat',
              'palm',
              'plunger',
              'practice',
              'solotone',
              'stop-hand',
              'stop-mute',
              'straight',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Mute.schema;

  attributes: MuteAttributes;
  contents: MuteContents;

  constructor(opts?: { attributes?: Partial<MuteAttributes>; contents?: MuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mute.schema);
    this.contents = opts?.contents ?? operations.zero(Mute.schema.contents);
  }

  /** Gets @type {'on' | 'off' | 'bucket' | 'cup' | 'echo' | 'harmon-no-stem' | 'harmon-stem' | 'hat' | 'palm' | 'plunger' | 'practice' | 'solotone' | 'stop-hand' | 'stop-mute' | 'straight'}. */
  getMute():
    | 'on'
    | 'off'
    | 'bucket'
    | 'cup'
    | 'echo'
    | 'harmon-no-stem'
    | 'harmon-stem'
    | 'hat'
    | 'palm'
    | 'plunger'
    | 'practice'
    | 'solotone'
    | 'stop-hand'
    | 'stop-mute'
    | 'straight' {
    return this.contents[0];
  }
  /** Sets @type {'on' | 'off' | 'bucket' | 'cup' | 'echo' | 'harmon-no-stem' | 'harmon-stem' | 'hat' | 'palm' | 'plunger' | 'practice' | 'solotone' | 'stop-hand' | 'stop-mute' | 'straight'}. */
  setMute(
    mute:
      | 'on'
      | 'off'
      | 'bucket'
      | 'cup'
      | 'echo'
      | 'harmon-no-stem'
      | 'harmon-stem'
      | 'hat'
      | 'palm'
      | 'plunger'
      | 'practice'
      | 'solotone'
      | 'stop-hand'
      | 'stop-mute'
      | 'straight'
  ): this {
    this.contents[0] = mute;
    return this;
  }
}

export type SemiPitchedAttributes = Record<string, unknown>;

export type SemiPitchedContents = ['high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'];

/**
 * The `<semi-pitched>` element
 *
 * Parent element: `<play>`
 *
 * The `<semi-pitched>` element represents categories of indefinite pitch for percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/semi-pitched/}
 */
export class SemiPitched implements XMLElement<'semi-pitched', SemiPitchedAttributes, SemiPitchedContents> {
  static readonly schema = {
    name: 'semi-pitched',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'semi-pitched',
          value: { type: 'choices', choices: ['high', 'low', 'medium', 'medium-high', 'medium-low', 'very-low'] },
        },
      },
    ],
  } as const;

  readonly schema = SemiPitched.schema;

  attributes: SemiPitchedAttributes;
  contents: SemiPitchedContents;

  constructor(opts?: { attributes?: Partial<SemiPitchedAttributes>; contents?: SemiPitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SemiPitched.schema);
    this.contents = opts?.contents ?? operations.zero(SemiPitched.schema.contents);
  }

  /** Gets @type {'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'}. */
  getSemiPitched(): 'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low' {
    return this.contents[0];
  }
  /** Sets @type {'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'}. */
  setSemiPitched(semiPitched: 'high' | 'low' | 'medium' | 'medium-high' | 'medium-low' | 'very-low'): this {
    this.contents[0] = semiPitched;
    return this;
  }
}

export type OtherPlayAttributes = {
  /**
   * Indicates the type of playback to which the element content applies.
   */
  type: string;
};

export type OtherPlayContents = [];

/**
 * The `<other-play>` element
 *
 * Parent element: `<play>`
 *
 * The `<other-play>` element represents other types of playback not otherwise specified within the `<play>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-play/}
 */
export class OtherPlay implements XMLElement<'other-play', OtherPlayAttributes, OtherPlayContents> {
  static readonly schema = {
    name: 'other-play',
    attributes: { type: { type: 'required', value: { type: 'string' } } },
    contents: [],
  } as const;

  readonly schema = OtherPlay.schema;

  attributes: OtherPlayAttributes;
  contents: OtherPlayContents;

  constructor(opts?: { attributes?: Partial<OtherPlayAttributes>; contents?: OtherPlayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherPlay.schema);
    this.contents = opts?.contents ?? operations.zero(OtherPlay.schema.contents);
  }
  /** Gets @type {OtherPlayAttributes['type']}. */
  getType(): string {
    return this.attributes['type'];
  }
  /** Sets @type {OtherPlayAttributes['type']}. */
  setType(type: string): OtherPlay {
    this.attributes['type'] = type;
    return this;
  }
}

export type PlayAttributes = {
  /**
   * Refers to a specific `<score-instrument>` to which this playback applies.
   */
  id: string | null;
};

export type PlayContents = [Array<Ipa | Mute | SemiPitched | OtherPlay>];

/**
 * The `<play>` element
 *
 * Parent elements: `<note>`, `<sound>`
 *
 * The `<play>` element specifies playback techniques to be used in conjunction with the `<instrument-sound>` element.
 * When used as part of a `<sound>` element, it applies to all notes going forward in score order. In multi-instrument
 * parts, the affected instrument should be specified using the id attribute. When used as part of a `<note>` element,
 * it applies to the current note only.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/play/}
 */
export class Play implements XMLElement<'play', PlayAttributes, PlayContents> {
  static readonly schema = {
    name: 'play',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Ipa, Mute, SemiPitched, OtherPlay] } },
      },
    ],
  } as const;

  readonly schema = Play.schema;

  attributes: PlayAttributes;
  contents: PlayContents;

  constructor(opts?: { attributes?: Partial<PlayAttributes>; contents?: PlayContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Play.schema);
    this.contents = opts?.contents ?? operations.zero(Play.schema.contents);
  }
  /** Gets @type {PlayAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {PlayAttributes['id']}. */
  setId(id: string | null): Play {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Array<Ipa | Mute | SemiPitched | OtherPlay>}. */
  getValue(): Array<Ipa | Mute | SemiPitched | OtherPlay> {
    return this.contents[0];
  }
  /** Sets @type {Array<Ipa | Mute | SemiPitched | OtherPlay>}. */
  setValue(value: Array<Ipa | Mute | SemiPitched | OtherPlay>): this {
    this.contents[0] = value;
    return this;
  }
}

export type AssessAttributes = {
  /**
   * If yes, the note should be assessed; if no, it should not be assessed. If not specified, it is no for notes
   * with a `<cue>` child element and yes otherwise.
   */
  type: 'yes' | 'no';
  /**
   * Restricts the type to apply to a single player. If missing, the type applies to all players. It references the
   * id attribute of a `<player>` element defined within the matching `<score-part>`.
   */
  player: string | null;
  /**
   * Restricts the type to apply to a set of times through a repeated section. If missing, the type applies all
   * times through the repeated section.
   */
  'time-only': string | null;
};

export type AssessContents = [];

/**
 * The `<assess>`` element
 *
 * Parent element: `<listen>`
 *
 * By default, an assessment application should assess all notes without a `<cue>` child element, and not assess any
 * note with a `<cue>` child element. The `<assess>` element allows this default assessment to be overridden for
 * individual notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/assess/}
 */
export class Assess implements XMLElement<'assess', AssessAttributes, AssessContents> {
  static readonly schema = {
    name: 'assess',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['yes', 'no'] } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Assess.schema;

  attributes: AssessAttributes;
  contents: AssessContents;

  constructor(opts?: { attributes?: Partial<AssessAttributes>; contents?: AssessContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Assess.schema);
    this.contents = opts?.contents ?? operations.zero(Assess.schema.contents);
  }
  /** Gets @type {AssessAttributes['type']}. */
  getType(): 'yes' | 'no' {
    return this.attributes['type'];
  }
  /** Sets @type {AssessAttributes['type']}. */
  setType(type: 'yes' | 'no'): Assess {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {AssessAttributes['player']}. */
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  /** Sets @type {AssessAttributes['player']}. */
  setPlayer(player: string | null): Assess {
    this.attributes['player'] = player;
    return this;
  }
  /** Gets @type {AssessAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {AssessAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): Assess {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type WaitAttributes = {
  /**
   * Restricts the `<wait>` to apply to a single player.
   */
  player: string | null;
  /**
   * Restricts the `<wait>` to apply to a set of times through a repeated section.
   */
  'time-only': string | null;
};

export type WaitContents = [];

/**
 * The `<wait>` element
 *
 * Parent element: `<listen>`
 *
 * The `<wait>` element specifies a point where the accompaniment should wait for a performer event before continuing.
 * This typically happens at the start of new sections or after a held note or indeterminate music. These waiting points
 * cannot always be inferred reliably from the contents of the displayed score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wait/}
 */
export class Wait implements XMLElement<'wait', WaitAttributes, WaitContents> {
  static readonly schema = {
    name: 'wait',
    attributes: {
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Wait.schema;

  attributes: WaitAttributes;
  contents: WaitContents;

  constructor(opts?: { attributes?: Partial<WaitAttributes>; contents?: WaitContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Wait.schema);
    this.contents = opts?.contents ?? operations.zero(Wait.schema.contents);
  }
  /** Gets @type {WaitAttributes['player']}. */
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  /** Sets @type {WaitAttributes['player']}. */
  setPlayer(player: string | null): Wait {
    this.attributes['player'] = player;
    return this;
  }
  /** Gets @type {WaitAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {WaitAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): Wait {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type OtherListenAttributes = {
  /**
   * Indicates the type of listening to which the element content applies.
   */
  type: string;
  /**
   * Restricts the element to apply to a single player.
   */
  player: string | null;
  /**
   * Restrict the element to apply to a set of times through a repeated section.
   */
  'time-only': string | null;
};

export type OtherListenContents = [string];

/**
 * The `<other-listen>` element
 *
 * Parent element: `<listen>`
 *
 * The `<other-listen>` element represents other types of listening control and interaction that are specific to a note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-listen/}
 */
export class OtherListen implements XMLElement<'other-listen', OtherListenAttributes, OtherListenContents> {
  static readonly schema = {
    name: 'other-listen',
    attributes: {
      type: { type: 'required', value: { type: 'string' } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherListen.schema;

  attributes: OtherListenAttributes;
  contents: OtherListenContents;

  constructor(opts?: { attributes?: Partial<OtherListenAttributes>; contents?: OtherListenContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherListen.schema);
    this.contents = opts?.contents ?? operations.zero(OtherListen.schema.contents);
  }
  /** Gets @type {OtherListenAttributes['type']}. */
  getType(): string {
    return this.attributes['type'];
  }
  /** Sets @type {OtherListenAttributes['type']}. */
  setType(type: string): OtherListen {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {OtherListenAttributes['player']}. */
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  /** Sets @type {OtherListenAttributes['player']}. */
  setPlayer(player: string | null): OtherListen {
    this.attributes['player'] = player;
    return this;
  }
  /** Gets @type {OtherListenAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {OtherListenAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): OtherListen {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type ListenAttributes = Record<string, unknown>;

export type ListenContents = [Array<Assess | Wait | OtherListen>];

/**
 * The `<listen>` element
 *
 * Parent element: `<note>`
 *
 * The `<listen>` and `<listening>` elements, new in Version 4.0, specify different ways that a score following or
 * machine listening application can interact with a performer. The `<listen>` element handles interactions that are
 * specific to a note. If multiple child elements of the same type are present, they should have distinct player and/or
 * time-only attributes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/listen/}
 */
export class Listen implements XMLElement<'listen', ListenAttributes, ListenContents> {
  static readonly schema = {
    name: 'listen',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'listens',
        value: { type: 'oneOrMore', value: { type: 'choices', choices: [Assess, Wait, OtherListen] } },
      },
    ],
  } as const;

  readonly schema = Listen.schema;

  attributes: ListenAttributes;
  contents: ListenContents;

  constructor(opts?: { attributes?: Partial<ListenAttributes>; contents?: ListenContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Listen.schema);
    this.contents = opts?.contents ?? operations.zero(Listen.schema.contents);
  }

  /** Gets @type {Array<Assess | Wait | OtherListen>}. */
  getListens(): Array<Assess | Wait | OtherListen> {
    return this.contents[0];
  }
  /** Sets @type {Array<Assess | Wait | OtherListen>}. */
  setListens(listens: Array<Assess | Wait | OtherListen>): this {
    this.contents[0] = listens;
    return this;
  }
}

export type TiedNote = [Chord | null, Pitch | Unpitched | Rest, Duration, [] | [Tie] | [Tie, Tie]];

export type CuedNote = [Cue, Chord | null, Pitch | Unpitched | Rest, Duration];

export type TiedGraceNote = [Grace, Chord | null, Pitch | Unpitched | Rest, [] | [Tie] | [Tie, Tie]];

export type CuedGraceNote = [Grace, Cue, Chord | null, Pitch | Unpitched | Rest, Duration];

export type NoteAttributes = {
  /**
   * Alters the starting time of the note from when it would otherwise occur based on the flow of durations -
   * information that is specific to a performance. It is expressed in terms of divisions, either positive or
   * negative. A <note> that stops a tie should not have an attack attribute. The attack and release attributes are
   * independent of each other. The attack attribute only changes the starting time of a note.
   */
  attack: number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the start of the
   * entire current measure, at either the left barline or the start of the system. Positive x is right and negative
   * x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * Corresponds to MIDI 1.0's Note On velocity, expressed in terms of percentage of the default forte value
   * (90 for MIDI 1.0).
   */
  dynamics: number | null;
  /**
   * Corresponds to MIDI 1.0's Note Off velocity, expressed in terms of percentage of the default forte value
   * (90 for MIDI 1.0).
   */
  'end-dynamics': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Used when just this note is sounded pizzicato, vs. the <pizzicato> element which changes overall playback
   * between pizzicato and arco.
   */
  pizzicato: 'yes' | 'no' | null;
  /**
   * Controls the printing of an augmentation dot separately from the rest of the note or rest. This is especially
   * useful for notes that overlap in different voices, or for chord sheets that contain lyrics and chords but no
   * melody. If print-object is set to no, this attribute is also interpreted as being set to no if not present.
   */
  'print-dot': 'yes' | 'no' | null;
  /**
   * Indicates whether leger lines are printed. Notes without leger lines are used to indicate indeterminate high
   * and low notes. It is yes if not present unless print-object is set to no. This attribute is ignored for rests.
   */
  'print-leger': 'yes' | 'no' | null;
  /**
   * Controls the printing of a lyric separately from the rest of the note or rest. This is especially useful for
   * notes that overlap in different voices, or for chord sheets that contain lyrics and chords but no melody. If
   * print-object is set to no, this attribute is also interpreted as being set to no if not present.
   */
  'print-lyric': 'yes' | 'no' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Controls whether or not spacing is left for an invisible note or object. It is used only if no note, dot, or
   * lyric is being printed. The value is yes (leave spacing) if not specified.
   */
  'print-spacing': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Alters the stopping time of the note from when it would otherwise occur based on the flow of durations -
   * information that is specific to a performance. It is expressed in terms of divisions, either positive or
   * negative. A `<note>` that starts a tie should not have a release attribute. The attack and release attributes
   * are independent of each other. The release attribute only changes the stopping time of a note.
   */
  release: number | null;
  /**
   * Shows which times to play the note during a repeated section.
   */
  'time-only': string | null;
};

export type NoteContents = [
  TiedNote | CuedNote | TiedGraceNote | CuedGraceNote,
  Array<Instrument>,
  Footnote | null,
  Level | null,
  Voice | null,
  Type | null,
  Array<Dot>,
  Accidental | null,
  TimeModification | null,
  Stem | null,
  Notehead | null,
  NoteheadText | null,
  Staff | null,
  (
    | []
    | [Beam]
    | [Beam, Beam]
    | [Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]
  ),
  Array<Notations>,
  Array<Lyric>,
  Play | null,
  Listen | null,
];

/**
 * The `<note>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * Notes are the most common type of MusicXML data. The MusicXML format distinguishes between elements used for sound
 * information and elements used for notation information (e.g., `<tie>` is used for sound, `<tied>` for notation). Thus
 * grace notes do not have a `<duration>` element. Cue notes have a `<duration>` element, as do `<forward>` elements,
 * but no `<tie>` elements. Having these two types of information available can make interchange easier, as some
 * programs handle one type of information more readily than the other.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/note/}
 */
export class Note implements XMLElement<'note', NoteAttributes, NoteContents> {
  static readonly schema = {
    name: 'note',
    attributes: {
      attack: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dynamics: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      'end-dynamics': { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      pizzicato: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-dot': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-leger': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-lyric': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      release: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [
      {
        type: 'label',
        label: 'variation',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'tied-note',
              value: [
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'required', value: Duration },
                { type: 'choices', choices: [[], [Tie], [Tie, Tie]] },
              ],
            },
            {
              type: 'label',
              label: 'cued-note',
              value: [
                { type: 'required', value: Cue },
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'required', value: Duration },
              ],
            },
            {
              type: 'label',
              label: 'tied-grace-note',
              value: [
                { type: 'required', value: Grace },
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'choices', choices: [[], [Tie], [Tie, Tie]] },
              ],
            },
            {
              type: 'label',
              label: 'cued-grace-note',
              value: [
                { type: 'required', value: Grace },
                { type: 'required', value: Cue },
                { type: 'optional', value: Chord },
                { type: 'choices', choices: [Pitch, Unpitched, Rest] },
                { type: 'required', value: Duration },
              ],
            },
          ],
        },
      },
      { type: 'label', label: 'instruments', value: { type: 'zeroOrMore', value: Instrument } },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Voice },
      { type: 'optional', value: Type },
      { type: 'label', label: 'dots', value: { type: 'zeroOrMore', value: Dot } },
      { type: 'optional', value: Accidental },
      { type: 'optional', value: TimeModification },
      { type: 'optional', value: Stem },
      { type: 'optional', value: Notehead },
      { type: 'optional', value: NoteheadText },
      { type: 'optional', value: Staff },
      {
        type: 'label',
        label: 'beams',
        value: {
          type: 'choices',
          choices: [
            [],
            [Beam],
            [Beam, Beam],
            [Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam, Beam, Beam],
            [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam],
          ],
        },
      },
      { type: 'label', label: 'notations', value: { type: 'zeroOrMore', value: Notations } },
      { type: 'label', label: 'lyrics', value: { type: 'zeroOrMore', value: Lyric } },
      { type: 'optional', value: Play },
      { type: 'optional', value: Listen },
    ],
  } as const;

  readonly schema = Note.schema;

  attributes: NoteAttributes;
  contents: NoteContents;

  constructor(opts?: { attributes?: Partial<NoteAttributes>; contents?: NoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Note.schema);
    this.contents = opts?.contents ?? operations.zero(Note.schema.contents);
  }
  /** Gets @type {NoteAttributes['attack']}. */
  getAttack(): number | null {
    return this.attributes['attack'];
  }
  /** Sets @type {NoteAttributes['attack']}. */
  setAttack(attack: number | null): Note {
    this.attributes['attack'] = attack;
    return this;
  }
  /** Gets @type {NoteAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {NoteAttributes['color']}. */
  setColor(color: string | null): Note {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {NoteAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {NoteAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Note {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {NoteAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {NoteAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Note {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {NoteAttributes['dynamics']}. */
  getDynamics(): number | null {
    return this.attributes['dynamics'];
  }
  /** Sets @type {NoteAttributes['dynamics']}. */
  setDynamics(dynamics: number | null): Note {
    this.attributes['dynamics'] = dynamics;
    return this;
  }
  /** Gets @type {NoteAttributes['end-dynamics']}. */
  getEndDynamics(): number | null {
    return this.attributes['end-dynamics'];
  }
  /** Sets @type {NoteAttributes['end-dynamics']}. */
  setEndDynamics(endDynamics: number | null): Note {
    this.attributes['end-dynamics'] = endDynamics;
    return this;
  }
  /** Gets @type {NoteAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {NoteAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Note {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {NoteAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {NoteAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Note {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {NoteAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {NoteAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Note {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {NoteAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {NoteAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Note {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {NoteAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {NoteAttributes['id']}. */
  setId(id: string | null): Note {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {NoteAttributes['pizzicato']}. */
  getPizzicato(): 'yes' | 'no' | null {
    return this.attributes['pizzicato'];
  }
  /** Sets @type {NoteAttributes['pizzicato']}. */
  setPizzicato(pizzicato: 'yes' | 'no' | null): Note {
    this.attributes['pizzicato'] = pizzicato;
    return this;
  }
  /** Gets @type {NoteAttributes['print-dot']}. */
  getPrintDot(): 'yes' | 'no' | null {
    return this.attributes['print-dot'];
  }
  /** Sets @type {NoteAttributes['print-dot']}. */
  setPrintDot(printDot: 'yes' | 'no' | null): Note {
    this.attributes['print-dot'] = printDot;
    return this;
  }
  /** Gets @type {NoteAttributes['print-leger']}. */
  getPrintLeger(): 'yes' | 'no' | null {
    return this.attributes['print-leger'];
  }
  /** Sets @type {NoteAttributes['print-leger']}. */
  setPrintLeger(printLeger: 'yes' | 'no' | null): Note {
    this.attributes['print-leger'] = printLeger;
    return this;
  }
  /** Gets @type {NoteAttributes['print-lyric']}. */
  getPrintLyric(): 'yes' | 'no' | null {
    return this.attributes['print-lyric'];
  }
  /** Sets @type {NoteAttributes['print-lyric']}. */
  setPrintLyric(printLyric: 'yes' | 'no' | null): Note {
    this.attributes['print-lyric'] = printLyric;
    return this;
  }
  /** Gets @type {NoteAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {NoteAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Note {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {NoteAttributes['print-spacing']}. */
  getPrintSpacing(): 'yes' | 'no' | null {
    return this.attributes['print-spacing'];
  }
  /** Sets @type {NoteAttributes['print-spacing']}. */
  setPrintSpacing(printSpacing: 'yes' | 'no' | null): Note {
    this.attributes['print-spacing'] = printSpacing;
    return this;
  }
  /** Gets @type {NoteAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {NoteAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Note {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {NoteAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {NoteAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Note {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {NoteAttributes['release']}. */
  getRelease(): number | null {
    return this.attributes['release'];
  }
  /** Sets @type {NoteAttributes['release']}. */
  setRelease(release: number | null): Note {
    this.attributes['release'] = release;
    return this;
  }
  /** Gets @type {NoteAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {NoteAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): Note {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  /** Gets @type {TiedNote | CuedNote | TiedGraceNote | CuedGraceNote}. */
  getVariation(): TiedNote | CuedNote | TiedGraceNote | CuedGraceNote {
    return this.contents[0];
  }
  /** Sets @type {TiedNote | CuedNote | TiedGraceNote | CuedGraceNote}. */
  setVariation(variation: TiedNote | CuedNote | TiedGraceNote | CuedGraceNote): this {
    this.contents[0] = variation;
    return this;
  }
  /** Gets @type {Array<Instrument>}. */
  getInstruments(): Array<Instrument> {
    return this.contents[1];
  }
  /** Sets @type {Array<Instrument>}. */
  setInstruments(instruments: Array<Instrument>): this {
    this.contents[1] = instruments;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[2];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[2] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[3];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[3] = level;
    return this;
  }
  /** Gets @type {Voice | null}. */
  getVoice(): Voice | null {
    return this.contents[4];
  }
  /** Sets @type {Voice | null}. */
  setVoice(voice: Voice | null): this {
    this.contents[4] = voice;
    return this;
  }
  /** Gets @type {Type | null}. */
  getType(): Type | null {
    return this.contents[5];
  }
  /** Sets @type {Type | null}. */
  setType(type: Type | null): this {
    this.contents[5] = type;
    return this;
  }
  /** Gets @type {Array<Dot>}. */
  getDots(): Array<Dot> {
    return this.contents[6];
  }
  /** Sets @type {Array<Dot>}. */
  setDots(dots: Array<Dot>): this {
    this.contents[6] = dots;
    return this;
  }
  /** Gets @type {Accidental | null}. */
  getAccidental(): Accidental | null {
    return this.contents[7];
  }
  /** Sets @type {Accidental | null}. */
  setAccidental(accidental: Accidental | null): this {
    this.contents[7] = accidental;
    return this;
  }
  /** Gets @type {TimeModification | null}. */
  getTimeModification(): TimeModification | null {
    return this.contents[8];
  }
  /** Sets @type {TimeModification | null}. */
  setTimeModification(timeModification: TimeModification | null): this {
    this.contents[8] = timeModification;
    return this;
  }
  /** Gets @type {Stem | null}. */
  getStem(): Stem | null {
    return this.contents[9];
  }
  /** Sets @type {Stem | null}. */
  setStem(stem: Stem | null): this {
    this.contents[9] = stem;
    return this;
  }
  /** Gets @type {Notehead | null}. */
  getNotehead(): Notehead | null {
    return this.contents[10];
  }
  /** Sets @type {Notehead | null}. */
  setNotehead(notehead: Notehead | null): this {
    this.contents[10] = notehead;
    return this;
  }
  /** Gets @type {NoteheadText | null}. */
  getNoteheadText(): NoteheadText | null {
    return this.contents[11];
  }
  /** Sets @type {NoteheadText | null}. */
  setNoteheadText(noteheadText: NoteheadText | null): this {
    this.contents[11] = noteheadText;
    return this;
  }
  /** Gets @type {Staff | null}. */
  getStaff(): Staff | null {
    return this.contents[12];
  }
  /** Sets @type {Staff | null}. */
  setStaff(staff: Staff | null): this {
    this.contents[12] = staff;
    return this;
  }
  /** Gets @type {[] | [Beam] | [Beam, Beam] | [Beam, Beam, Beam] | [Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]}. */
  getBeams():
    | []
    | [Beam]
    | [Beam, Beam]
    | [Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam]
    | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam] {
    return this.contents[13];
  }
  /** Sets @type {[] | [Beam] | [Beam, Beam] | [Beam, Beam, Beam] | [Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam] | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]}. */
  setBeams(
    beams:
      | []
      | [Beam]
      | [Beam, Beam]
      | [Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam, Beam, Beam]
      | [Beam, Beam, Beam, Beam, Beam, Beam, Beam, Beam]
  ): this {
    this.contents[13] = beams;
    return this;
  }
  /** Gets @type {Array<Notations>}. */
  getNotations(): Array<Notations> {
    return this.contents[14];
  }
  /** Sets @type {Array<Notations>}. */
  setNotations(notations: Array<Notations>): this {
    this.contents[14] = notations;
    return this;
  }
  /** Gets @type {Array<Lyric>}. */
  getLyrics(): Array<Lyric> {
    return this.contents[15];
  }
  /** Sets @type {Array<Lyric>}. */
  setLyrics(lyrics: Array<Lyric>): this {
    this.contents[15] = lyrics;
    return this;
  }
  /** Gets @type {Play | null}. */
  getPlay(): Play | null {
    return this.contents[16];
  }
  /** Sets @type {Play | null}. */
  setPlay(play: Play | null): this {
    this.contents[16] = play;
    return this;
  }
  /** Gets @type {Listen | null}. */
  getListen(): Listen | null {
    return this.contents[17];
  }
  /** Sets @type {Listen | null}. */
  setListen(listen: Listen | null): this {
    this.contents[17] = listen;
    return this;
  }
}

export type BackupAttributes = Record<string, unknown>;

export type BackupContents = [Duration, Footnote | null, Level | null];

/**
 * The `<backup> element
 *
 * Parent elements: `<measure> (partwise), `<part> (timewise)
 *
 * The `<backup> and `<forward> elements are required to coordinate multiple voices in one part, including music on
 * multiple staves. The `<backup> element is generally used to move between voices and staves. Thus it does not include
 * `<voice> or `<staff> elements. Duration values should always be positive, and should not cross measure boundaries or
 * mid-measure changes in the `<divisions> value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/backup/}
 */
export class Backup implements XMLElement<'backup', BackupAttributes, BackupContents> {
  static readonly schema = {
    name: 'backup',
    attributes: {},
    contents: [
      { type: 'required', value: Duration },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = Backup.schema;

  attributes: BackupAttributes;
  contents: BackupContents;

  constructor(opts?: { attributes?: Partial<BackupAttributes>; contents?: BackupContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Backup.schema);
    this.contents = opts?.contents ?? operations.zero(Backup.schema.contents);
  }

  /** Gets @type {Duration}. */
  getDuration(): Duration {
    return this.contents[0];
  }
  /** Sets @type {Duration}. */
  setDuration(duration: Duration): this {
    this.contents[0] = duration;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[1];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[1] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[2];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[2] = level;
    return this;
  }
}

export type ForwardAttributes = Record<string, unknown>;

export type ForwardContents = [Duration, Footnote | null, Level | null, Voice | null, Staff | null];

/**
 * The `<forward>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<backup>` and `<forward>` elements are required to coordinate multiple voices in one part, including music on
 * multiple staves. The `<forward>` element is generally used within voices and staves. Duration values should always be
 * positive, and should not cross measure boundaries or mid-measure changes in the `<divisions>` value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/forward/}
 */
export class Forward implements XMLElement<'forward', ForwardAttributes, ForwardContents> {
  static readonly schema = {
    name: 'forward',
    attributes: {},
    contents: [
      { type: 'required', value: Duration },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Voice },
      { type: 'optional', value: Staff },
    ],
  } as const;

  readonly schema = Forward.schema;

  attributes: ForwardAttributes;
  contents: ForwardContents;

  constructor(opts?: { attributes?: Partial<ForwardAttributes>; contents?: ForwardContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Forward.schema);
    this.contents = opts?.contents ?? operations.zero(Forward.schema.contents);
  }

  /** Gets @type {Duration}. */
  getDuration(): Duration {
    return this.contents[0];
  }
  /** Sets @type {Duration}. */
  setDuration(duration: Duration): this {
    this.contents[0] = duration;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[1];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[1] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[2];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[2] = level;
    return this;
  }
  /** Gets @type {Voice | null}. */
  getVoice(): Voice | null {
    return this.contents[3];
  }
  /** Sets @type {Voice | null}. */
  setVoice(voice: Voice | null): this {
    this.contents[3] = voice;
    return this;
  }
  /** Gets @type {Staff | null}. */
  getStaff(): Staff | null {
    return this.contents[4];
  }
  /** Sets @type {Staff | null}. */
  setStaff(staff: Staff | null): this {
    this.contents[4] = staff;
    return this;
  }
}

export type RehearsalAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  /**
   * Specifies the language used in the element content. It is Italian ("it") if not specified.
   */
  'xml:lang': string | null;
  /**
   * Indicates whether white space should be preserved by applications.
   */
  'xml:space': 'default' | 'preserve' | null;
};

export type RehearsalContents = [string];

/**
 * The `<rehearsal>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<rehearsal>` element specifies letters, numbers, and section names that are notated in the score for reference
 * during rehearsal. The enclosure is square if not specified. Left justification is used if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/rehearsal/}
 */
export class Rehearsal implements XMLElement<'rehearsal', RehearsalAttributes, RehearsalContents> {
  static readonly schema = {
    name: 'rehearsal',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Rehearsal.schema;

  attributes: RehearsalAttributes;
  contents: RehearsalContents;

  constructor(opts?: { attributes?: Partial<RehearsalAttributes>; contents?: RehearsalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Rehearsal.schema);
    this.contents = opts?.contents ?? operations.zero(Rehearsal.schema.contents);
  }
  /** Gets @type {RehearsalAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {RehearsalAttributes['color']}. */
  setColor(color: string | null): Rehearsal {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {RehearsalAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {RehearsalAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Rehearsal {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {RehearsalAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {RehearsalAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Rehearsal {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {RehearsalAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {RehearsalAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Rehearsal {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {RehearsalAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {RehearsalAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Rehearsal {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {RehearsalAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {RehearsalAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Rehearsal {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {RehearsalAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {RehearsalAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Rehearsal {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {RehearsalAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {RehearsalAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Rehearsal {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {RehearsalAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {RehearsalAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Rehearsal {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {RehearsalAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {RehearsalAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Rehearsal {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {RehearsalAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {RehearsalAttributes['id']}. */
  setId(id: string | null): Rehearsal {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {RehearsalAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {RehearsalAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): Rehearsal {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {RehearsalAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {RehearsalAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): Rehearsal {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {RehearsalAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {RehearsalAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): Rehearsal {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {RehearsalAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {RehearsalAttributes['overline']}. */
  setOverline(overline: number | null): Rehearsal {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {RehearsalAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {RehearsalAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Rehearsal {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {RehearsalAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {RehearsalAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Rehearsal {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {RehearsalAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {RehearsalAttributes['rotation']}. */
  setRotation(rotation: number | null): Rehearsal {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {RehearsalAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {RehearsalAttributes['underline']}. */
  setUnderline(underline: number | null): Rehearsal {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {RehearsalAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {RehearsalAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Rehearsal {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {RehearsalAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {RehearsalAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): Rehearsal {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {RehearsalAttributes['xml:space']}. */
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  /** Sets @type {RehearsalAttributes['xml:space']}. */
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): Rehearsal {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type SegnoAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Specifies the exact Standard Music Font Layout (SMuFL) accidental character, using its SMuFL canonical glyph
   * name.
   */
  smufl: string | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type SegnoContents = [];

/**
 * The `<segno>` element
 *
 * Parent elements: `<barline>`, `<direction-type>`
 *
 * The `<segno>` element is the visual indicator of a segno sign. A `<sound>` element is also needed to guide playback
 * applications reliably.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/segno/}
 */
export class Segno implements XMLElement<'segno', SegnoAttributes, SegnoContents> {
  static readonly schema = {
    name: 'segno',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Segno.schema;

  attributes: SegnoAttributes;
  contents: SegnoContents;

  constructor(opts?: { attributes?: Partial<SegnoAttributes>; contents?: SegnoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Segno.schema);
    this.contents = opts?.contents ?? operations.zero(Segno.schema.contents);
  }
  /** Gets @type {SegnoAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SegnoAttributes['color']}. */
  setColor(color: string | null): Segno {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SegnoAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SegnoAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Segno {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SegnoAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SegnoAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Segno {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SegnoAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SegnoAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Segno {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SegnoAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SegnoAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Segno {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SegnoAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SegnoAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Segno {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SegnoAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SegnoAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Segno {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SegnoAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {SegnoAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Segno {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {SegnoAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {SegnoAttributes['id']}. */
  setId(id: string | null): Segno {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {SegnoAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SegnoAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Segno {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SegnoAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SegnoAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Segno {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {SegnoAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {SegnoAttributes['smufl']}. */
  setSmufl(smufl: string | null): Segno {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {SegnoAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {SegnoAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Segno {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type CodaAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Specifies the exact Standard Music Font Layout (SMuFL) accidental character, using its SMuFL canonical glyph
   * name.
   */
  smufl: string | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type CodaContents = [];

/**
 * The `<coda>` element
 *
 * Parent elements: `<barline>`, `<direction-type>`
 *
 * The `<coda>` element is the visual indicator of a coda sign. A <sound>` element is also needed to guide playback
 * applications reliably.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/coda/}
 */
export class Coda implements XMLElement<'coda', CodaAttributes, CodaContents> {
  static readonly schema = {
    name: 'coda',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Coda.schema;

  attributes: CodaAttributes;
  contents: CodaContents;

  constructor(opts?: { attributes?: Partial<CodaAttributes>; contents?: CodaContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Coda.schema);
    this.contents = opts?.contents ?? operations.zero(Coda.schema.contents);
  }
  /** Gets @type {CodaAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {CodaAttributes['color']}. */
  setColor(color: string | null): Coda {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {CodaAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {CodaAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Coda {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {CodaAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {CodaAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Coda {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {CodaAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {CodaAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Coda {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {CodaAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {CodaAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Coda {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {CodaAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {CodaAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Coda {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {CodaAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {CodaAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Coda {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {CodaAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {CodaAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Coda {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {CodaAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {CodaAttributes['id']}. */
  setId(id: string | null): Coda {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {CodaAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {CodaAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Coda {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {CodaAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {CodaAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Coda {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {CodaAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {CodaAttributes['smufl']}. */
  setSmufl(smufl: string | null): Coda {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {CodaAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {CodaAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Coda {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type WordsAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  /**
   * Specifies the language used in the element content. It is Italian ("it") if not specified.
   */
  'xml:lang': string | null;
  /**
   * Indicates whether white space should be preserved by applications.
   */
  'xml:space': 'default' | 'preserve' | null;
};

export type WordsContents = [string];

/**
 * The `<words>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<words>` element specifies a standard text direction. The enclosure attribute is none if not specified. Left
 * justification is used if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/words/}
 */
export class Words implements XMLElement<'words', WordsAttributes, WordsContents> {
  static readonly schema = {
    name: 'words',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
      'xml:space': { type: 'optional', value: { type: 'choices', choices: ['default', 'preserve'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Words.schema;

  attributes: WordsAttributes;
  contents: WordsContents;

  constructor(opts?: { attributes?: Partial<WordsAttributes>; contents?: WordsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Words.schema);
    this.contents = opts?.contents ?? operations.zero(Words.schema.contents);
  }
  /** Gets @type {WordsAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {WordsAttributes['color']}. */
  setColor(color: string | null): Words {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {WordsAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {WordsAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Words {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {WordsAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {WordsAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Words {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {WordsAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {WordsAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Words {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {WordsAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {WordsAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Words {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {WordsAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {WordsAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Words {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {WordsAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {WordsAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Words {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {WordsAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {WordsAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Words {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {WordsAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {WordsAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Words {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {WordsAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {WordsAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Words {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {WordsAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {WordsAttributes['id']}. */
  setId(id: string | null): Words {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {WordsAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {WordsAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): Words {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {WordsAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {WordsAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): Words {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {WordsAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {WordsAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): Words {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {WordsAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {WordsAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): Words {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {WordsAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {WordsAttributes['overline']}. */
  setOverline(overline: number | null): Words {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {WordsAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {WordsAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Words {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {WordsAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {WordsAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Words {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {WordsAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {WordsAttributes['rotation']}. */
  setRotation(rotation: number | null): Words {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {WordsAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {WordsAttributes['underline']}. */
  setUnderline(underline: number | null): Words {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {WordsAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {WordsAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Words {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {WordsAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {WordsAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): Words {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {WordsAttributes['xml:space']}. */
  getXmlSpace(): 'default' | 'preserve' | null {
    return this.attributes['xml:space'];
  }
  /** Sets @type {WordsAttributes['xml:space']}. */
  setXmlSpace(xmlSpace: 'default' | 'preserve' | null): Words {
    this.attributes['xml:space'] = xmlSpace;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type SymbolAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * The text-direction attribute is used to adjust and override the Unicode bidirectional text algorithm, similar
   * to the Directionality data category in the
   * [W3C Internationalization Tag Set recommendation.](https://www.w3.org/TR/2007/REC-its-20070403/#directionality)
   * The default value is ltr. This attribute is typically used by applications that store text in left-to-right
   * visual order rather than logical order. Such applications can use the lro value to better communicate with
   * other applications that more fully support bidirectional text.
   */
  dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null;
  /**
   * Formatting of an enclosure around text or symbols.
   */
  enclosure:
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Specifies text tracking. Values are either normal, which allows flexibility of letter-spacing for purposes of
   * text justification. or a number representing the number of ems to add between each letter. The number may be
   * negative in order to subtract space. The value is normal if not specified.
   */
  'letter-spacing': 'normal' | number | null;
  /**
   * Specifies text leading. Values are either normal or a number representing the percentage of the current font
   * height to use for leading. It is normal if not specified. The exact normal value is implementation-dependent,
   * but values between 100 and 120 are recommended.
   */
  'line-height': 'normal' | number | null;
  /**
   * Number of lines to use when striking through text.
   */
  'line-through': number | null;
  /**
   * Number of lines to use when overlining text.
   */
  overline: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Used to rotate text around the alignment point specified by the halign and valign attributes. Positive values
   * are clockwise rotations, while negative values are counter-clockwise rotations.
   */
  rotation: number | null;
  /**
   * Number of lines to use when underlining text.
   */
  underline: number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type SymbolContents = [];

/**
 * The `<symbol>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<symbol>` element specifies a musical symbol using a canonical SMuFL glyph name. It is used when an occasional
 * musical symbol is interspersed into text. It should not be used in place of semantic markup, such as metronome marks
 * that mix text and symbols. Left justification is used if not specified. Enclosure is none if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/direction-type/}
 */
export class Symbol implements XMLElement<'symbol', SymbolAttributes, SymbolContents> {
  static readonly schema = {
    name: 'symbol',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      dir: { type: 'optional', value: { type: 'choices', choices: ['ltr', 'rtl', 'lro', 'rlo'] } },
      enclosure: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            'none',
            'rectangle',
            'square',
            'oval',
            'circle',
            'bracket',
            'inverted-bracket',
            'triangle',
            'diamond',
            'pentagon',
            'hexagon',
            'heptagon',
            'octagon',
            'nonagon',
            'decagon',
          ],
        },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'letter-spacing': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-height': {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', { type: 'float', min: -Infinity, max: Infinity }] },
      },
      'line-through': { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      overline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      rotation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      underline: { type: 'optional', value: { type: 'int', min: 0, max: 3 } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Symbol.schema;

  attributes: SymbolAttributes;
  contents: SymbolContents;

  constructor(opts?: { attributes?: Partial<SymbolAttributes>; contents?: SymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Symbol.schema);
    this.contents = opts?.contents ?? operations.zero(Symbol.schema.contents);
  }
  /** Gets @type {SymbolAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SymbolAttributes['color']}. */
  setColor(color: string | null): Symbol {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SymbolAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SymbolAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Symbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SymbolAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SymbolAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Symbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SymbolAttributes['dir']}. */
  getDir(): 'ltr' | 'rtl' | 'lro' | 'rlo' | null {
    return this.attributes['dir'];
  }
  /** Sets @type {SymbolAttributes['dir']}. */
  setDir(dir: 'ltr' | 'rtl' | 'lro' | 'rlo' | null): Symbol {
    this.attributes['dir'] = dir;
    return this;
  }
  /** Gets @type {SymbolAttributes['enclosure']}. */
  getEnclosure():
    | 'none'
    | 'rectangle'
    | 'square'
    | 'oval'
    | 'circle'
    | 'bracket'
    | 'inverted-bracket'
    | 'triangle'
    | 'diamond'
    | 'pentagon'
    | 'hexagon'
    | 'heptagon'
    | 'octagon'
    | 'nonagon'
    | 'decagon'
    | null {
    return this.attributes['enclosure'];
  }
  /** Sets @type {SymbolAttributes['enclosure']}. */
  setEnclosure(
    enclosure:
      | 'none'
      | 'rectangle'
      | 'square'
      | 'oval'
      | 'circle'
      | 'bracket'
      | 'inverted-bracket'
      | 'triangle'
      | 'diamond'
      | 'pentagon'
      | 'hexagon'
      | 'heptagon'
      | 'octagon'
      | 'nonagon'
      | 'decagon'
      | null
  ): Symbol {
    this.attributes['enclosure'] = enclosure;
    return this;
  }
  /** Gets @type {SymbolAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SymbolAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Symbol {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SymbolAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SymbolAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Symbol {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SymbolAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SymbolAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Symbol {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SymbolAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SymbolAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Symbol {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SymbolAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {SymbolAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Symbol {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {SymbolAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {SymbolAttributes['id']}. */
  setId(id: string | null): Symbol {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {SymbolAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {SymbolAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): Symbol {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {SymbolAttributes['letter-spacing']}. */
  getLetterSpacing(): 'normal' | number | null {
    return this.attributes['letter-spacing'];
  }
  /** Sets @type {SymbolAttributes['letter-spacing']}. */
  setLetterSpacing(letterSpacing: 'normal' | number | null): Symbol {
    this.attributes['letter-spacing'] = letterSpacing;
    return this;
  }
  /** Gets @type {SymbolAttributes['line-height']}. */
  getLineHeight(): 'normal' | number | null {
    return this.attributes['line-height'];
  }
  /** Sets @type {SymbolAttributes['line-height']}. */
  setLineHeight(lineHeight: 'normal' | number | null): Symbol {
    this.attributes['line-height'] = lineHeight;
    return this;
  }
  /** Gets @type {SymbolAttributes['line-through']}. */
  getLineThrough(): number | null {
    return this.attributes['line-through'];
  }
  /** Sets @type {SymbolAttributes['line-through']}. */
  setLineThrough(lineThrough: number | null): Symbol {
    this.attributes['line-through'] = lineThrough;
    return this;
  }
  /** Gets @type {SymbolAttributes['overline']}. */
  getOverline(): number | null {
    return this.attributes['overline'];
  }
  /** Sets @type {SymbolAttributes['overline']}. */
  setOverline(overline: number | null): Symbol {
    this.attributes['overline'] = overline;
    return this;
  }
  /** Gets @type {SymbolAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SymbolAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Symbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SymbolAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SymbolAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Symbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {SymbolAttributes['rotation']}. */
  getRotation(): number | null {
    return this.attributes['rotation'];
  }
  /** Sets @type {SymbolAttributes['rotation']}. */
  setRotation(rotation: number | null): Symbol {
    this.attributes['rotation'] = rotation;
    return this;
  }
  /** Gets @type {SymbolAttributes['underline']}. */
  getUnderline(): number | null {
    return this.attributes['underline'];
  }
  /** Sets @type {SymbolAttributes['underline']}. */
  setUnderline(underline: number | null): Symbol {
    this.attributes['underline'] = underline;
    return this;
  }
  /** Gets @type {SymbolAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {SymbolAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Symbol {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type WedgeAttributes = {
  /**
   * The value is crescendo for the start of a wedge that is closed at the left side, diminuendo for the start of a
   * wedge that is closed on the right side, and stop for the end of a wedge.
   */
  type: 'crescendo' | 'diminuendo' | 'stop' | 'continue';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * A value is yes indicates that a circle appears at the point of the wedge, indicating a crescendo from nothing
   * or diminuendo to nothing. It is no if not specified, and used only when the type is crescendo, or the type is
   * stop for a wedge that began with a diminuendo type.
   */
  niente: 'yes' | 'no' | null;
  /**
   * Distinguishes multiple wedges when they overlap in MusicXML document order.
   */
  number: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
  /**
   * Indicates the gap between the top and bottom of the wedge as measured in tenths. Ignored if specified at the
   * start of a crescendo wedge or the end of a diminuendo wedge.
   */
  spread: number | null;
};

export type WedgeContents = [];

/**
 * The `<wedge>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<wedge>` element represents crescendo and diminuendo wedge symbols. The line-type attribute is solid if not
 * specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wedge/}
 */
export class Wedge implements XMLElement<'wedge', WedgeAttributes, WedgeContents> {
  static readonly schema = {
    name: 'wedge',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['crescendo', 'diminuendo', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      niente: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      spread: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Wedge.schema;

  attributes: WedgeAttributes;
  contents: WedgeContents;

  constructor(opts?: { attributes?: Partial<WedgeAttributes>; contents?: WedgeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Wedge.schema);
    this.contents = opts?.contents ?? operations.zero(Wedge.schema.contents);
  }
  /** Gets @type {WedgeAttributes['type']}. */
  getType(): 'crescendo' | 'diminuendo' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  /** Sets @type {WedgeAttributes['type']}. */
  setType(type: 'crescendo' | 'diminuendo' | 'stop' | 'continue'): Wedge {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {WedgeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {WedgeAttributes['color']}. */
  setColor(color: string | null): Wedge {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {WedgeAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {WedgeAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Wedge {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {WedgeAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {WedgeAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Wedge {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {WedgeAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {WedgeAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Wedge {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {WedgeAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {WedgeAttributes['id']}. */
  setId(id: string | null): Wedge {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {WedgeAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {WedgeAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Wedge {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {WedgeAttributes['niente']}. */
  getNiente(): 'yes' | 'no' | null {
    return this.attributes['niente'];
  }
  /** Sets @type {WedgeAttributes['niente']}. */
  setNiente(niente: 'yes' | 'no' | null): Wedge {
    this.attributes['niente'] = niente;
    return this;
  }
  /** Gets @type {WedgeAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {WedgeAttributes['number']}. */
  setNumber(number: number | null): Wedge {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {WedgeAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {WedgeAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Wedge {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {WedgeAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {WedgeAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Wedge {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {WedgeAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {WedgeAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Wedge {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
  /** Gets @type {WedgeAttributes['spread']}. */
  getSpread(): number | null {
    return this.attributes['spread'];
  }
  /** Sets @type {WedgeAttributes['spread']}. */
  setSpread(spread: number | null): Wedge {
    this.attributes['spread'] = spread;
    return this;
  }
}

export type DashesAttributes = {
  /**
   * Indicates if this is the start, stop, or continuation of the dashes.
   */
  type: 'start' | 'stop' | 'continue';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Distinguishes multiple dashes when they overlap in MusicXML document order.
   */
  number: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line.
   */
  'space-length': number | null;
};

export type DashesContents = [];

/**
 * The `<dashes>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<dashes>` element represents dashes, used for instance with cresc. and dim. marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/dashes/}
 */
export class Dashes implements XMLElement<'dashes', DashesAttributes, DashesContents> {
  static readonly schema = {
    name: 'dashes',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Dashes.schema;

  attributes: DashesAttributes;
  contents: DashesContents;

  constructor(opts?: { attributes?: Partial<DashesAttributes>; contents?: DashesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Dashes.schema);
    this.contents = opts?.contents ?? operations.zero(Dashes.schema.contents);
  }
  /** Gets @type {DashesAttributes['type']}. */
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  /** Sets @type {DashesAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'continue'): Dashes {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {DashesAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DashesAttributes['color']}. */
  setColor(color: string | null): Dashes {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DashesAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {DashesAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Dashes {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {DashesAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DashesAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Dashes {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DashesAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DashesAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Dashes {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DashesAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {DashesAttributes['id']}. */
  setId(id: string | null): Dashes {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {DashesAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {DashesAttributes['number']}. */
  setNumber(number: number | null): Dashes {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {DashesAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DashesAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Dashes {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DashesAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DashesAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Dashes {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DashesAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {DashesAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Dashes {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type BracketAttributes = {
  /**
   * Specifies if there is a jog up or down (or both), an arrow, or nothing at the start or end of the bracket.
   */
  'line-end': 'none' | 'up' | 'down' | 'both' | 'arrow';
  /**
   * Indicates if this is the start, stop, or continuation of the bracket.
   */
  type: 'start' | 'stop' | 'continue';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * Specifies the length of the jog if the line-end attribute is up or down.
   */
  'end-length': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Distinguishes multiple brackets when they overlap in MusicXML document order.
   */
  number: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type BracketContents = [];

/**
 * The `<bracket>` element
 *
 * Parent element: `<direction-type>`
 *
 * Brackets are combined with words in a variety of modern directions. The line-type is solid if not specified.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bracket/}
 */
export class Bracket implements XMLElement<'bracket', BracketAttributes, BracketContents> {
  static readonly schema = {
    name: 'bracket',
    attributes: {
      'line-end': { type: 'required', value: { type: 'choices', choices: ['none', 'up', 'down', 'both', 'arrow'] } },
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'end-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Bracket.schema;

  attributes: BracketAttributes;
  contents: BracketContents;

  constructor(opts?: { attributes?: Partial<BracketAttributes>; contents?: BracketContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bracket.schema);
    this.contents = opts?.contents ?? operations.zero(Bracket.schema.contents);
  }
  /** Gets @type {BracketAttributes['line-end']}. */
  getLineEnd(): 'none' | 'up' | 'down' | 'both' | 'arrow' {
    return this.attributes['line-end'];
  }
  /** Sets @type {BracketAttributes['line-end']}. */
  setLineEnd(lineEnd: 'none' | 'up' | 'down' | 'both' | 'arrow'): Bracket {
    this.attributes['line-end'] = lineEnd;
    return this;
  }
  /** Gets @type {BracketAttributes['type']}. */
  getType(): 'start' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  /** Sets @type {BracketAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'continue'): Bracket {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {BracketAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BracketAttributes['color']}. */
  setColor(color: string | null): Bracket {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BracketAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {BracketAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): Bracket {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {BracketAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {BracketAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Bracket {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {BracketAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {BracketAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Bracket {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {BracketAttributes['end-length']}. */
  getEndLength(): number | null {
    return this.attributes['end-length'];
  }
  /** Sets @type {BracketAttributes['end-length']}. */
  setEndLength(endLength: number | null): Bracket {
    this.attributes['end-length'] = endLength;
    return this;
  }
  /** Gets @type {BracketAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {BracketAttributes['id']}. */
  setId(id: string | null): Bracket {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {BracketAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {BracketAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): Bracket {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {BracketAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {BracketAttributes['number']}. */
  setNumber(number: number | null): Bracket {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {BracketAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {BracketAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Bracket {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {BracketAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {BracketAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Bracket {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {BracketAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {BracketAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): Bracket {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type PedalAttributes = {
  /**
   * Distinguishes different types of pedal directions.
   */
  type: 'start' | 'stop' | 'sostenuto' | 'change' | 'continue' | 'discountiue' | 'resume';
  /**
   * Used only when the sign attribute is yes and the type is start or sostenuto; otherwise it is ignored. If yes,
   * the short P and S signs are used. If no, the full Ped and Sost signs are used. It is no if not specified.
   */
  abbreviated: 'yes' | 'no' | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. If the parent is a `<notehead-text>` element, the
   * origin is changed relative to the left-hand side of the note or the musical position within the bar. Otherwise,
   * the origin is changed relative to the start of the first measure on the system, and these values are used when
   * the current measure or a succeeding measure starts a new system. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * If yes, then pedal lines are used.
   */
  line: 'yes' | 'no' | null;
  /**
   * Distinguishes multiple pedals when they overlap in MusicXML document order.
   */
  number: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * If yes, then Ped, Sost, and  signs are used. For compatibility with older versions, it is yes if not specified
   * if the line attribute is no, and is no if not specified if the line attribute is yes. If no, the alignment
   * attributes are ignored.
   */
  sign: 'yes' | 'no' | null;
};

export type PedalContents = [];

/**
 * The `<pedal>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<pedal>` element represents piano pedal marks, including damper and sostenuto pedal marks. The soft pedal is not
 * included here because there is no special symbol or graphic used for it beyond what can be specified with `<words>`
 * and `<bracket>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal/}
 */
export class Pedal implements XMLElement<'pedal', PedalAttributes, PedalContents> {
  static readonly schema = {
    name: 'pedal',
    attributes: {
      type: {
        type: 'required',
        value: {
          type: 'choices',
          choices: ['start', 'stop', 'sostenuto', 'change', 'continue', 'discountiue', 'resume'],
        },
      },
      abbreviated: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      line: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      sign: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [],
  } as const;

  readonly schema = Pedal.schema;

  attributes: PedalAttributes;
  contents: PedalContents;

  constructor(opts?: { attributes?: Partial<PedalAttributes>; contents?: PedalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pedal.schema);
    this.contents = opts?.contents ?? operations.zero(Pedal.schema.contents);
  }
  /** Gets @type {PedalAttributes['type']}. */
  getType(): 'start' | 'stop' | 'sostenuto' | 'change' | 'continue' | 'discountiue' | 'resume' {
    return this.attributes['type'];
  }
  /** Sets @type {PedalAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'sostenuto' | 'change' | 'continue' | 'discountiue' | 'resume'): Pedal {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {PedalAttributes['abbreviated']}. */
  getAbbreviated(): 'yes' | 'no' | null {
    return this.attributes['abbreviated'];
  }
  /** Sets @type {PedalAttributes['abbreviated']}. */
  setAbbreviated(abbreviated: 'yes' | 'no' | null): Pedal {
    this.attributes['abbreviated'] = abbreviated;
    return this;
  }
  /** Gets @type {PedalAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PedalAttributes['color']}. */
  setColor(color: string | null): Pedal {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PedalAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PedalAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Pedal {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PedalAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PedalAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Pedal {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PedalAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PedalAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Pedal {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PedalAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PedalAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Pedal {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PedalAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PedalAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Pedal {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PedalAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PedalAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Pedal {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PedalAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {PedalAttributes['id']}. */
  setId(id: string | null): Pedal {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {PedalAttributes['line']}. */
  getLine(): 'yes' | 'no' | null {
    return this.attributes['line'];
  }
  /** Sets @type {PedalAttributes['line']}. */
  setLine(line: 'yes' | 'no' | null): Pedal {
    this.attributes['line'] = line;
    return this;
  }
  /** Gets @type {PedalAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {PedalAttributes['number']}. */
  setNumber(number: number | null): Pedal {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {PedalAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PedalAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Pedal {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PedalAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PedalAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Pedal {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {PedalAttributes['sign']}. */
  getSign(): 'yes' | 'no' | null {
    return this.attributes['sign'];
  }
  /** Sets @type {PedalAttributes['sign']}. */
  setSign(sign: 'yes' | 'no' | null): Pedal {
    this.attributes['sign'] = sign;
    return this;
  }
}

export type BeatUnitAttributes = Record<string, unknown>;

export type BeatUnitContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima',
];

/**
 * The `<beat-unit>` element
 *
 * Parent elements: `<beat-unit-tied>`, `<metronome>`
 *
 * The `<beat-unit>` element indicates the graphical note type to use in a metronome mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-unit/}
 */
export class BeatUnit implements XMLElement<'beat-unit', BeatUnitAttributes, BeatUnitContents> {
  static readonly schema = {
    name: 'beat-unit',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = BeatUnit.schema;

  attributes: BeatUnitAttributes;
  contents: BeatUnitContents;

  constructor(opts?: { attributes?: Partial<BeatUnitAttributes>; contents?: BeatUnitContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatUnit.schema);
    this.contents = opts?.contents ?? operations.zero(BeatUnit.schema.contents);
  }

  /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): this {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type BeatUnitDotAttributes = Record<string, unknown>;

export type BeatUnitDotContents = [];

/**
 * The `<beat-unit-dot>` element
 *
 * Parent elements: `<beat-unit-tied>`, `<metronome>`
 *
 * The `<beat-unit-dot>` element is used to specify any augmentation dots for a metronome mark note.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-unit-dot/}
 */
export class BeatUnitDot implements XMLElement<'beat-unit-dot', BeatUnitDotAttributes, BeatUnitDotContents> {
  static readonly schema = { name: 'beat-unit-dot', attributes: {}, contents: [] } as const;

  readonly schema = BeatUnitDot.schema;

  attributes: BeatUnitDotAttributes;
  contents: BeatUnitDotContents;

  constructor(opts?: { attributes?: Partial<BeatUnitDotAttributes>; contents?: BeatUnitDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatUnitDot.schema);
    this.contents = opts?.contents ?? operations.zero(BeatUnitDot.schema.contents);
  }
}

export type BeatUnitTiedAttributes = Record<string, unknown>;

export type BeatUnitTiedContents = [BeatUnit, Array<BeatUnitDot>];

/**
 * The `<beat-unit-tied>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<beat-unit-tied>` element indicates a `<beat-unit>` within a metronome mark that is tied to the preceding
 * `<beat-unit>`. This allows two or more tied notes to be associated with a per-minute value in a metronome mark,
 * whereas the `<metronome-tied>` element is restricted to metric relationship marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-unit-tied/}
 */
export class BeatUnitTied implements XMLElement<'beat-unit-tied', BeatUnitTiedAttributes, BeatUnitTiedContents> {
  static readonly schema = {
    name: 'beat-unit-tied',
    attributes: {},
    contents: [
      { type: 'required', value: BeatUnit },
      { type: 'label', label: 'beat-unit-dots', value: { type: 'zeroOrMore', value: BeatUnitDot } },
    ],
  } as const;

  readonly schema = BeatUnitTied.schema;

  attributes: BeatUnitTiedAttributes;
  contents: BeatUnitTiedContents;

  constructor(opts?: { attributes?: Partial<BeatUnitTiedAttributes>; contents?: BeatUnitTiedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatUnitTied.schema);
    this.contents = opts?.contents ?? operations.zero(BeatUnitTied.schema.contents);
  }

  /** Gets @type {BeatUnit}. */
  getBeatUnit(): BeatUnit {
    return this.contents[0];
  }
  /** Sets @type {BeatUnit}. */
  setBeatUnit(beatUnit: BeatUnit): this {
    this.contents[0] = beatUnit;
    return this;
  }
  /** Gets @type {Array<BeatUnitDot>}. */
  getBeatUnitDots(): Array<BeatUnitDot> {
    return this.contents[1];
  }
  /** Sets @type {Array<BeatUnitDot>}. */
  setBeatUnitDots(beatUnitDots: Array<BeatUnitDot>): this {
    this.contents[1] = beatUnitDots;
    return this;
  }
}

export type PerMinuteAttributes = {
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
};

export type PerMinuteContents = [string];

/**
 * The `<per-minute>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<per-minute>` element can be a number, or a text description including numbers. If a font is specified, it
 * overrides the font specified for the overall `<metronome>` element. This allows separate specification of a music
 * font for the `<beat-unit>` and a text font for the numeric value, in cases where a single metronome font is not used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/per-minute/}
 */
export class PerMinute implements XMLElement<'per-minute', PerMinuteAttributes, PerMinuteContents> {
  static readonly schema = {
    name: 'per-minute',
    attributes: {
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PerMinute.schema;

  attributes: PerMinuteAttributes;
  contents: PerMinuteContents;

  constructor(opts?: { attributes?: Partial<PerMinuteAttributes>; contents?: PerMinuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PerMinute.schema);
    this.contents = opts?.contents ?? operations.zero(PerMinute.schema.contents);
  }
  /** Gets @type {PerMinuteAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PerMinuteAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): PerMinute {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PerMinuteAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PerMinuteAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PerMinute {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PerMinuteAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PerMinuteAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PerMinute {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PerMinuteAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PerMinuteAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PerMinute {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MetronomeArrowsAttributes = Record<string, unknown>;

export type MetronomeArrowsContents = [];

/**
 * The `<metronome-arrows>` element
 *
 * Parent element: `<metronome>`
 *
 * If the `<metronome-arrows>` element is present, it indicates that metric modulation arrows are displayed on both
 * sides of the metronome mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-arrows/}
 */
export class MetronomeArrows
  implements XMLElement<'metronome-arrows', MetronomeArrowsAttributes, MetronomeArrowsContents>
{
  static readonly schema = { name: 'metronome-arrows', attributes: {}, contents: [] } as const;

  readonly schema = MetronomeArrows.schema;

  attributes: MetronomeArrowsAttributes;
  contents: MetronomeArrowsContents;

  constructor(opts?: { attributes?: Partial<MetronomeArrowsAttributes>; contents?: MetronomeArrowsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeArrows.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeArrows.schema.contents);
  }
}

export type MetronomeTypeAttributes = Record<string, unknown>;

export type MetronomeTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima',
];

/**
 * The `<metronome-type>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-type>` element works like the `<type>` element in defining metric relationships.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-type/}
 */
export class MetronomeType implements XMLElement<'metronome-type', MetronomeTypeAttributes, MetronomeTypeContents> {
  static readonly schema = {
    name: 'metronome-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = MetronomeType.schema;

  attributes: MetronomeTypeAttributes;
  contents: MetronomeTypeContents;

  constructor(opts?: { attributes?: Partial<MetronomeTypeAttributes>; contents?: MetronomeTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeType.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeType.schema.contents);
  }

  /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): this {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type MetronomeDotAttributes = Record<string, unknown>;

export type MetronomeDotContents = [];

/**
 * The `<metronome-dot>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The metronome-dot element works like the dot element in defining metric relationships.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-dot/}
 */
export class MetronomeDot implements XMLElement<'metronome-dot', MetronomeDotAttributes, MetronomeDotContents> {
  static readonly schema = { name: 'metronome-dot', attributes: {}, contents: [] } as const;

  readonly schema = MetronomeDot.schema;

  attributes: MetronomeDotAttributes;
  contents: MetronomeDotContents;

  constructor(opts?: { attributes?: Partial<MetronomeDotAttributes>; contents?: MetronomeDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeDot.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeDot.schema.contents);
  }
}

export type MetronomeBeamAttributes = {
  /**
   * Indicates eighth note through 1024th note beams using number values 1 thru 8 respectively. The default value is
   * 1.
   */
  number: number | null;
};

export type MetronomeBeamContents = ['backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'];

/**
 * The `<metronome-beam>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-beam>` element works like the `<beam>` element in defining metric relationships, but does not include
 * all the attributes available in the `<beam>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-beam/}
 */
export class MetronomeBeam implements XMLElement<'metronome-beam', MetronomeBeamAttributes, MetronomeBeamContents> {
  static readonly schema = {
    name: 'metronome-beam',
    attributes: { number: { type: 'optional', value: { type: 'int', min: 1, max: 8 } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'beam-value',
          value: { type: 'choices', choices: ['backward hook', 'begin', 'continue', 'end', 'forward hook'] },
        },
      },
    ],
  } as const;

  readonly schema = MetronomeBeam.schema;

  attributes: MetronomeBeamAttributes;
  contents: MetronomeBeamContents;

  constructor(opts?: { attributes?: Partial<MetronomeBeamAttributes>; contents?: MetronomeBeamContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeBeam.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeBeam.schema.contents);
  }
  /** Gets @type {MetronomeBeamAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {MetronomeBeamAttributes['number']}. */
  setNumber(number: number | null): MetronomeBeam {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
  getBeamValue(): 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook' {
    return this.contents[0];
  }
  /** Sets @type {'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'}. */
  setBeamValue(beamValue: 'backward hook' | 'begin' | 'continue' | 'end' | 'forward hook'): this {
    this.contents[0] = beamValue;
    return this;
  }
}

export type MetronomeTiedAttributes = {
  /**
   * Indicates if this is the start or stop of the tie.
   */
  type: 'start' | 'stop';
};

export type MetronomeTiedContents = [];

/**
 * The `<metronome-tied>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-tied>` element indicates the presence of a tie within a metric relationship mark. As with the
 * `<tied>` element, both the start and stop of the tie should be specified, in this case within separate
 * `<metronome-note>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-tied/}
 */
export class MetronomeTied implements XMLElement<'metronome-tied', MetronomeTiedAttributes, MetronomeTiedContents> {
  static readonly schema = {
    name: 'metronome-tied',
    attributes: { type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } } },
    contents: [],
  } as const;

  readonly schema = MetronomeTied.schema;

  attributes: MetronomeTiedAttributes;
  contents: MetronomeTiedContents;

  constructor(opts?: { attributes?: Partial<MetronomeTiedAttributes>; contents?: MetronomeTiedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeTied.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeTied.schema.contents);
  }
  /** Gets @type {MetronomeTiedAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {MetronomeTiedAttributes['type']}. */
  setType(type: 'start' | 'stop'): MetronomeTied {
    this.attributes['type'] = type;
    return this;
  }
}

export type MetronomeTupletAttributes = {
  /**
   * Indicates if this is the start or stop of the metronome tuplet.
   */
  type: 'start' | 'stop';
  /**
   * Specifies whether or not brackets are put around a symbol for an editorial indication. If not specified, it is
   * left to application defaults.
   */
  bracket: 'yes' | 'no' | null;
  /**
   * Used to display either the number of actual notes, the number of both actual and normal notes, or neither. It
   * is actual if not specified.
   */
  'show-number': 'none' | 'actual' | 'both' | null;
};

export type MetronomeTupletContents = [ActualNotes, NormalNotes, [NormalType, Array<NormalDot>] | null];

/**
 * The `<metronome-tuplet>` element
 *
 * Parent element: `<metronome-note>`
 *
 * The `<metronome-tuplet>` element uses the same element structure as the `<time-modification>` element, along with
 * some attributes from the `<tuplet>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-tuplet/}
 */
export class MetronomeTuplet
  implements XMLElement<'metronome-tuplet', MetronomeTupletAttributes, MetronomeTupletContents>
{
  static readonly schema = {
    name: 'metronome-tuplet',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      bracket: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'show-number': { type: 'optional', value: { type: 'choices', choices: ['none', 'actual', 'both'] } },
    },
    contents: [
      { type: 'required', value: ActualNotes },
      { type: 'required', value: NormalNotes },
      {
        type: 'label',
        label: 'normal',
        value: {
          type: 'optional',
          value: [
            { type: 'required', value: NormalType },
            { type: 'zeroOrMore', value: NormalDot },
          ],
        },
      },
    ],
  } as const;

  readonly schema = MetronomeTuplet.schema;

  attributes: MetronomeTupletAttributes;
  contents: MetronomeTupletContents;

  constructor(opts?: { attributes?: Partial<MetronomeTupletAttributes>; contents?: MetronomeTupletContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeTuplet.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeTuplet.schema.contents);
  }
  /** Gets @type {MetronomeTupletAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {MetronomeTupletAttributes['type']}. */
  setType(type: 'start' | 'stop'): MetronomeTuplet {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {MetronomeTupletAttributes['bracket']}. */
  getBracket(): 'yes' | 'no' | null {
    return this.attributes['bracket'];
  }
  /** Sets @type {MetronomeTupletAttributes['bracket']}. */
  setBracket(bracket: 'yes' | 'no' | null): MetronomeTuplet {
    this.attributes['bracket'] = bracket;
    return this;
  }
  /** Gets @type {MetronomeTupletAttributes['show-number']}. */
  getShowNumber(): 'none' | 'actual' | 'both' | null {
    return this.attributes['show-number'];
  }
  /** Sets @type {MetronomeTupletAttributes['show-number']}. */
  setShowNumber(showNumber: 'none' | 'actual' | 'both' | null): MetronomeTuplet {
    this.attributes['show-number'] = showNumber;
    return this;
  }
  /** Gets @type {ActualNotes}. */
  getActualNotes(): ActualNotes {
    return this.contents[0];
  }
  /** Sets @type {ActualNotes}. */
  setActualNotes(actualNotes: ActualNotes): this {
    this.contents[0] = actualNotes;
    return this;
  }
  /** Gets @type {NormalNotes}. */
  getNormalNotes(): NormalNotes {
    return this.contents[1];
  }
  /** Sets @type {NormalNotes}. */
  setNormalNotes(normalNotes: NormalNotes): this {
    this.contents[1] = normalNotes;
    return this;
  }
  /** Gets @type {[NormalType, Array<NormalDot>] | null}. */
  getNormal(): [NormalType, Array<NormalDot>] | null {
    return this.contents[2];
  }
  /** Sets @type {[NormalType, Array<NormalDot>] | null}. */
  setNormal(normal: [NormalType, Array<NormalDot>] | null): this {
    this.contents[2] = normal;
    return this;
  }
}

export type MetronomeNoteAttributes = Record<string, unknown>;

export type MetronomeNoteContents = [
  MetronomeType,
  Array<MetronomeDot>,
  Array<MetronomeBeam>,
  MetronomeTied | null,
  MetronomeTuplet | null,
];

/**
 * The `<metronome-note>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<metronome-note>` element defines the appearance of a note within a metric relationship mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-note/}
 */
export class MetronomeNote implements XMLElement<'metronome-note', MetronomeNoteAttributes, MetronomeNoteContents> {
  static readonly schema = {
    name: 'metronome-note',
    attributes: {},
    contents: [
      { type: 'required', value: MetronomeType },
      { type: 'label', label: 'metronome-dots', value: { type: 'zeroOrMore', value: MetronomeDot } },
      { type: 'label', label: 'metronome-beams', value: { type: 'zeroOrMore', value: MetronomeBeam } },
      { type: 'optional', value: MetronomeTied },
      { type: 'optional', value: MetronomeTuplet },
    ],
  } as const;

  readonly schema = MetronomeNote.schema;

  attributes: MetronomeNoteAttributes;
  contents: MetronomeNoteContents;

  constructor(opts?: { attributes?: Partial<MetronomeNoteAttributes>; contents?: MetronomeNoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeNote.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeNote.schema.contents);
  }

  /** Gets @type {MetronomeType}. */
  getMetronomeType(): MetronomeType {
    return this.contents[0];
  }
  /** Sets @type {MetronomeType}. */
  setMetronomeType(metronomeType: MetronomeType): this {
    this.contents[0] = metronomeType;
    return this;
  }
  /** Gets @type {Array<MetronomeDot>}. */
  getMetronomeDots(): Array<MetronomeDot> {
    return this.contents[1];
  }
  /** Sets @type {Array<MetronomeDot>}. */
  setMetronomeDots(metronomeDots: Array<MetronomeDot>): this {
    this.contents[1] = metronomeDots;
    return this;
  }
  /** Gets @type {Array<MetronomeBeam>}. */
  getMetronomeBeams(): Array<MetronomeBeam> {
    return this.contents[2];
  }
  /** Sets @type {Array<MetronomeBeam>}. */
  setMetronomeBeams(metronomeBeams: Array<MetronomeBeam>): this {
    this.contents[2] = metronomeBeams;
    return this;
  }
  /** Gets @type {MetronomeTied | null}. */
  getMetronomeTied(): MetronomeTied | null {
    return this.contents[3];
  }
  /** Sets @type {MetronomeTied | null}. */
  setMetronomeTied(metronomeTied: MetronomeTied | null): this {
    this.contents[3] = metronomeTied;
    return this;
  }
  /** Gets @type {MetronomeTuplet | null}. */
  getMetronomeTuplet(): MetronomeTuplet | null {
    return this.contents[4];
  }
  /** Sets @type {MetronomeTuplet | null}. */
  setMetronomeTuplet(metronomeTuplet: MetronomeTuplet | null): this {
    this.contents[4] = metronomeTuplet;
    return this;
  }
}

export type MetronomeRelationAttributes = Record<string, unknown>;

export type MetronomeRelationContents = [string | null];

/**
 * The `<metronome-relation>` element
 *
 * Parent element: `<metronome>`
 *
 * The `<metronome-relation>` element describes the relationship symbol that goes between the two sets of
 * `<metronome-note>` elements. The currently allowed value is equals, but this may expand in future versions. If the
 * element is empty, the equals value is used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome-relation/}
 */
export class MetronomeRelation
  implements XMLElement<'metronome-relation', MetronomeRelationAttributes, MetronomeRelationContents>
{
  static readonly schema = {
    name: 'metronome-relation',
    attributes: {},
    contents: [{ type: 'optional', value: { type: 'string' } }],
  } as const;

  readonly schema = MetronomeRelation.schema;

  attributes: MetronomeRelationAttributes;
  contents: MetronomeRelationContents;

  constructor(opts?: { attributes?: Partial<MetronomeRelationAttributes>; contents?: MetronomeRelationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MetronomeRelation.schema);
    this.contents = opts?.contents ?? operations.zero(MetronomeRelation.schema.contents);
  }

  /** Gets @type {string | null}. */
  getText(): string | null {
    return this.contents[0];
  }
  /** Sets @type {string | null}. */
  setText(text: string | null): this {
    this.contents[0] = text;
    return this;
  }
}

export type BeatSpec = [
  BeatUnit,
  Array<BeatUnitDot>,
  Array<BeatUnitTied>,
  PerMinute | [BeatUnit, Array<BeatUnitDot>, Array<BeatUnitTied>],
];

export type MetronomeSpec = [
  MetronomeArrows | null,
  Array<MetronomeNote>,
  [MetronomeRelation, Array<MetronomeNote>] | null,
];

export type MetronomeAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates left, center, or right justification. The default value varies for different elements. For elements
   * where the justify attribute is present but the halign attribute is not, the justify attribute indicates
   * horizontal alignment as well as justification.
   */
  justify: 'left' | 'center' | 'right' | null;
  /**
   * Indicates whether or not to put the metronome mark in parentheses. It is no if not specified.
   */
  parentheses: 'yes' | 'no' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type MetronomeContents = [BeatSpec | MetronomeSpec];

/**
 * The `<metronome>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<metronome>` element represents metronome marks and other metric relationships. The `<beat-unit>` element group
 * and `<per-minute>` element specify regular metronome marks. The `<metronome-note>` and `<metronome-relation>`
 * elements allow for the specification of metric modulations and other metric relationships, such as swing tempo marks
 * where two eighths are equated to a quarter note / eighth note triplet. Tied notes can be represented in both types of
 * metronome marks by using the `<beat-unit-tied>` and `<metronome-tied>` elements. The print-object attribute is set to
 * no in cases where the `<metronome>` element represents a relationship or range that is not displayed in the music
 * notation.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metronome/}
 */
export class Metronome implements XMLElement<'metronome', MetronomeAttributes, MetronomeContents> {
  static readonly schema = {
    name: 'metronome',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      justify: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'metronome',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'beat-spec',
              value: [
                { type: 'required', value: BeatUnit },
                { type: 'zeroOrMore', value: BeatUnitDot },
                { type: 'zeroOrMore', value: BeatUnitTied },
                {
                  type: 'choices',
                  choices: [
                    PerMinute,
                    [
                      { type: 'required', value: BeatUnit },
                      { type: 'zeroOrMore', value: BeatUnitDot },
                      { type: 'zeroOrMore', value: BeatUnitTied },
                    ],
                  ],
                },
              ],
            },
            {
              type: 'label',
              label: 'metronome-spec',
              value: [
                { type: 'optional', value: MetronomeArrows },
                { type: 'oneOrMore', value: MetronomeNote },
                {
                  type: 'optional',
                  value: [
                    { type: 'required', value: MetronomeRelation },
                    { type: 'oneOrMore', value: MetronomeNote },
                  ],
                },
              ],
            },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Metronome.schema;

  attributes: MetronomeAttributes;
  contents: MetronomeContents;

  constructor(opts?: { attributes?: Partial<MetronomeAttributes>; contents?: MetronomeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Metronome.schema);
    this.contents = opts?.contents ?? operations.zero(Metronome.schema.contents);
  }
  /** Gets @type {MetronomeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {MetronomeAttributes['color']}. */
  setColor(color: string | null): Metronome {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {MetronomeAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {MetronomeAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Metronome {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {MetronomeAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {MetronomeAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Metronome {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {MetronomeAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {MetronomeAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Metronome {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {MetronomeAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {MetronomeAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Metronome {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {MetronomeAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {MetronomeAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Metronome {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {MetronomeAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {MetronomeAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Metronome {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {MetronomeAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {MetronomeAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Metronome {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {MetronomeAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {MetronomeAttributes['id']}. */
  setId(id: string | null): Metronome {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {MetronomeAttributes['justify']}. */
  getJustify(): 'left' | 'center' | 'right' | null {
    return this.attributes['justify'];
  }
  /** Sets @type {MetronomeAttributes['justify']}. */
  setJustify(justify: 'left' | 'center' | 'right' | null): Metronome {
    this.attributes['justify'] = justify;
    return this;
  }
  /** Gets @type {MetronomeAttributes['parentheses']}. */
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  /** Sets @type {MetronomeAttributes['parentheses']}. */
  setParentheses(parentheses: 'yes' | 'no' | null): Metronome {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  /** Gets @type {MetronomeAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {MetronomeAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Metronome {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {MetronomeAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {MetronomeAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Metronome {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {MetronomeAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {MetronomeAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Metronome {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {MetronomeAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {MetronomeAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Metronome {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {BeatSpec | MetronomeSpec}. */
  getMetronome(): BeatSpec | MetronomeSpec {
    return this.contents[0];
  }
  /** Sets @type {BeatSpec | MetronomeSpec}. */
  setMetronome(metronome: BeatSpec | MetronomeSpec): this {
    this.contents[0] = metronome;
    return this;
  }
}

export type OctaveShiftAttributes = {
  /**
   * Indicates if this is the start, stop, or continuation of the octave shift. The start is specified as a shift up
   * or down from their performed values
   */
  type: 'up' | 'down' | 'stop' | 'continue';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * The length of dashes in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'dash-length': number | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive x is right and negative x is left.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the bottom
   * left-hand corner of the specified page. Positive y is up and negative y is down.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Distinguishes multiple octave shifts when they overlap in MusicXML document order.
   */
  number: number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-y attribute. Positive y is up and negative y is down.
   */
  'relative-y': number | null;
  /**
   * 8 indicates one octave; 15 indicates two octaves; 22 indicates 3 octaves. The default value is 8.
   */
  size: number | null;
  /**
   * The length of spaces in a dashed line. Ignored if the corresponding line-type attribute is not dashed.
   */
  'space-length': number | null;
};

export type OctaveShiftContents = [];

/**
 * The `<octave-shift>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<octave-shift>` element indicates where notes are shifted up or down from their performed values because of
 * printing difficulty. Thus a treble clef line noted with 8va will be indicated with an `<octave-shift>` down from the
 * pitch data indicated in the notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/octave-shift/}
 */
export class OctaveShift implements XMLElement<'octave-shift', OctaveShiftAttributes, OctaveShiftContents> {
  static readonly schema = {
    name: 'octave-shift',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['up', 'down', 'stop', 'continue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'dash-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: 16 } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'space-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = OctaveShift.schema;

  attributes: OctaveShiftAttributes;
  contents: OctaveShiftContents;

  constructor(opts?: { attributes?: Partial<OctaveShiftAttributes>; contents?: OctaveShiftContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OctaveShift.schema);
    this.contents = opts?.contents ?? operations.zero(OctaveShift.schema.contents);
  }
  /** Gets @type {OctaveShiftAttributes['type']}. */
  getType(): 'up' | 'down' | 'stop' | 'continue' {
    return this.attributes['type'];
  }
  /** Sets @type {OctaveShiftAttributes['type']}. */
  setType(type: 'up' | 'down' | 'stop' | 'continue'): OctaveShift {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OctaveShiftAttributes['color']}. */
  setColor(color: string | null): OctaveShift {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['dash-length']}. */
  getDashLength(): number | null {
    return this.attributes['dash-length'];
  }
  /** Sets @type {OctaveShiftAttributes['dash-length']}. */
  setDashLength(dashLength: number | null): OctaveShift {
    this.attributes['dash-length'] = dashLength;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OctaveShiftAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): OctaveShift {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OctaveShiftAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): OctaveShift {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {OctaveShiftAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): OctaveShift {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {OctaveShiftAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OctaveShift {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {OctaveShiftAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OctaveShift {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {OctaveShiftAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OctaveShift {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {OctaveShiftAttributes['id']}. */
  setId(id: string | null): OctaveShift {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {OctaveShiftAttributes['number']}. */
  setNumber(number: number | null): OctaveShift {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OctaveShiftAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): OctaveShift {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OctaveShiftAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): OctaveShift {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['size']}. */
  getSize(): number | null {
    return this.attributes['size'];
  }
  /** Sets @type {OctaveShiftAttributes['size']}. */
  setSize(size: number | null): OctaveShift {
    this.attributes['size'] = size;
    return this;
  }
  /** Gets @type {OctaveShiftAttributes['space-length']}. */
  getSpaceLength(): number | null {
    return this.attributes['space-length'];
  }
  /** Sets @type {OctaveShiftAttributes['space-length']}. */
  setSpaceLength(spaceLength: number | null): OctaveShift {
    this.attributes['space-length'] = spaceLength;
    return this;
  }
}

export type PedalStepAttributes = Record<string, unknown>;

export type PedalStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

/**
 * The `<pedal-step>` element
 *
 * Parent element: `<pedal-tuning>`
 *
 * The `<pedal-step>` element defines the pitch step for a single harp pedal.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal-step/}
 */
export class PedalStep implements XMLElement<'pedal-step', PedalStepAttributes, PedalStepContents> {
  static readonly schema = {
    name: 'pedal-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = PedalStep.schema;

  attributes: PedalStepAttributes;
  contents: PedalStepContents;

  constructor(opts?: { attributes?: Partial<PedalStepAttributes>; contents?: PedalStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PedalStep.schema);
    this.contents = opts?.contents ?? operations.zero(PedalStep.schema.contents);
  }

  /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): this {
    this.contents[0] = step;
    return this;
  }
}

export type PedalAlterAttributes = Record<string, unknown>;

export type PedalAlterContents = [number];

/**
 * The `<pedal-alter>` element
 *
 * Parent element: `<pedal-tuning>`
 *
 * The `<pedal-alter>` element defines the chromatic alteration for a single harp pedal.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal-alter/}
 */
export class PedalAlter implements XMLElement<'pedal-alter', PedalAlterAttributes, PedalAlterContents> {
  static readonly schema = {
    name: 'pedal-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = PedalAlter.schema;

  attributes: PedalAlterAttributes;
  contents: PedalAlterContents;

  constructor(opts?: { attributes?: Partial<PedalAlterAttributes>; contents?: PedalAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PedalAlter.schema);
    this.contents = opts?.contents ?? operations.zero(PedalAlter.schema.contents);
  }

  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type PedalTuningAttributes = Record<string, unknown>;

export type PedalTuningContents = [PedalStep, PedalAlter];

/**
 * The `<pedal-tuning>` element
 *
 * Parent element: `<harp-pedals>`
 *
 * The `<pedal-tuning>` element specifies the tuning of a single harp pedal.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pedal-tuning/}
 */
export class PedalTuning implements XMLElement<'pedal-tuning', PedalTuningAttributes, PedalTuningContents> {
  static readonly schema = {
    name: 'pedal-tuning',
    attributes: {},
    contents: [
      { type: 'required', value: PedalStep },
      { type: 'required', value: PedalAlter },
    ],
  } as const;

  readonly schema = PedalTuning.schema;

  attributes: PedalTuningAttributes;
  contents: PedalTuningContents;

  constructor(opts?: { attributes?: Partial<PedalTuningAttributes>; contents?: PedalTuningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PedalTuning.schema);
    this.contents = opts?.contents ?? operations.zero(PedalTuning.schema.contents);
  }

  /** Gets @type {PedalStep}. */
  getPedalStep(): PedalStep {
    return this.contents[0];
  }
  /** Sets @type {PedalStep}. */
  setPedalStep(pedalStep: PedalStep): this {
    this.contents[0] = pedalStep;
    return this;
  }
  /** Gets @type {PedalAlter}. */
  getPedalAlter(): PedalAlter {
    return this.contents[1];
  }
  /** Sets @type {PedalAlter}. */
  setPedalAlter(pedalAlter: PedalAlter): this {
    this.contents[1] = pedalAlter;
    return this;
  }
}

export type HarpPedalsAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type HarpPedalsContents = [Array<PedalTuning>];

/**
 * The `<harp-pedals>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<harp-pedals>` element represents harp pedal diagrams. The `<pedal-step>` and `<pedal-alter>` elements use the
 * same values as the `<step>` and `<alter>` elements. For easiest reading, the `<pedal-tuning>` elements should follow
 * standard harp pedal order, with `<pedal-step>` values of D, C, B, E, F, G, and A.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harp-pedals/}
 */
export class HarpPedals implements XMLElement<'harp-pedals', HarpPedalsAttributes, HarpPedalsContents> {
  static readonly schema = {
    name: 'harp-pedals',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'label', label: 'pedal-tunings', value: { type: 'oneOrMore', value: PedalTuning } }],
  } as const;

  readonly schema = HarpPedals.schema;

  attributes: HarpPedalsAttributes;
  contents: HarpPedalsContents;

  constructor(opts?: { attributes?: Partial<HarpPedalsAttributes>; contents?: HarpPedalsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, HarpPedals.schema);
    this.contents = opts?.contents ?? operations.zero(HarpPedals.schema.contents);
  }
  /** Gets @type {HarpPedalsAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HarpPedalsAttributes['color']}. */
  setColor(color: string | null): HarpPedals {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HarpPedalsAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): HarpPedals {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HarpPedalsAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): HarpPedals {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HarpPedalsAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): HarpPedals {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HarpPedalsAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): HarpPedals {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HarpPedalsAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): HarpPedals {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HarpPedalsAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): HarpPedals {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {HarpPedalsAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): HarpPedals {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {HarpPedalsAttributes['id']}. */
  setId(id: string | null): HarpPedals {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HarpPedalsAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): HarpPedals {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HarpPedalsAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): HarpPedals {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {HarpPedalsAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {HarpPedalsAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): HarpPedals {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {Array<PedalTuning>}. */
  getPedalTunings(): Array<PedalTuning> {
    return this.contents[0];
  }
  /** Sets @type {Array<PedalTuning>}. */
  setPedalTunings(pedalTunings: Array<PedalTuning>): this {
    this.contents[0] = pedalTunings;
    return this;
  }
}

export type DampAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type DampContents = [];

/**
 * The `<damp>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<damp>` element specifies a harp damping mark.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/damp/}
 */
export class Damp implements XMLElement<'damp', DampAttributes, DampContents> {
  static readonly schema = {
    name: 'damp',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Damp.schema;

  attributes: DampAttributes;
  contents: DampContents;

  constructor(opts?: { attributes?: Partial<DampAttributes>; contents?: DampContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Damp.schema);
    this.contents = opts?.contents ?? operations.zero(Damp.schema.contents);
  }
  /** Gets @type {DampAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DampAttributes['color']}. */
  setColor(color: string | null): Damp {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DampAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DampAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Damp {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DampAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DampAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Damp {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DampAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DampAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Damp {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DampAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DampAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Damp {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DampAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DampAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Damp {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DampAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DampAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Damp {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DampAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {DampAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Damp {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {DampAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {DampAttributes['id']}. */
  setId(id: string | null): Damp {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {DampAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DampAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Damp {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DampAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DampAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Damp {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DampAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {DampAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Damp {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type DampAllAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type DampAllContents = [];

/**
 * The `<damp-all>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<damp-all>` element specifies a harp damping mark for all strings.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/damp-all/}
 */
export class DampAll implements XMLElement<'damp-all', DampAllAttributes, DampAllContents> {
  static readonly schema = {
    name: 'damp-all',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = DampAll.schema;

  attributes: DampAllAttributes;
  contents: DampAllContents;

  constructor(opts?: { attributes?: Partial<DampAllAttributes>; contents?: DampAllContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DampAll.schema);
    this.contents = opts?.contents ?? operations.zero(DampAll.schema.contents);
  }
  /** Gets @type {DampAllAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DampAllAttributes['color']}. */
  setColor(color: string | null): DampAll {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DampAllAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DampAllAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DampAll {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DampAllAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DampAllAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DampAll {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DampAllAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DampAllAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DampAll {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DampAllAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DampAllAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DampAll {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DampAllAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DampAllAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DampAll {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DampAllAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DampAllAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DampAll {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DampAllAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {DampAllAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): DampAll {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {DampAllAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {DampAllAttributes['id']}. */
  setId(id: string | null): DampAll {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {DampAllAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DampAllAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DampAll {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DampAllAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DampAllAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DampAll {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DampAllAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {DampAllAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): DampAll {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type EyeglassesAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type EyeglassesContents = [];

/**
 * The `<eyeglasses>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<eyeglasses>` element represents the eyeglasses symbol, common in commercial music.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/eyeglasses/}
 */
export class Eyeglasses implements XMLElement<'eyeglasses', EyeglassesAttributes, EyeglassesContents> {
  static readonly schema = {
    name: 'eyeglasses',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = Eyeglasses.schema;

  attributes: EyeglassesAttributes;
  contents: EyeglassesContents;

  constructor(opts?: { attributes?: Partial<EyeglassesAttributes>; contents?: EyeglassesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Eyeglasses.schema);
    this.contents = opts?.contents ?? operations.zero(Eyeglasses.schema.contents);
  }
  /** Gets @type {EyeglassesAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {EyeglassesAttributes['color']}. */
  setColor(color: string | null): Eyeglasses {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {EyeglassesAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Eyeglasses {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {EyeglassesAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Eyeglasses {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {EyeglassesAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Eyeglasses {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {EyeglassesAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Eyeglasses {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {EyeglassesAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Eyeglasses {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {EyeglassesAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Eyeglasses {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {EyeglassesAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Eyeglasses {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {EyeglassesAttributes['id']}. */
  setId(id: string | null): Eyeglasses {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {EyeglassesAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Eyeglasses {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {EyeglassesAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Eyeglasses {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {EyeglassesAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {EyeglassesAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Eyeglasses {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type StringMuteAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type StringMuteContents = [];

/**
 * The `<string-mute>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<string-mute>` element represents string mute on and mute off symbols.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/string-mute/}
 */
export class StringMute implements XMLElement<'string-mute', StringMuteAttributes, StringMuteContents> {
  static readonly schema = {
    name: 'string-mute',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = StringMute.schema;

  attributes: StringMuteAttributes;
  contents: StringMuteContents;

  constructor(opts?: { attributes?: Partial<StringMuteAttributes>; contents?: StringMuteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StringMute.schema);
    this.contents = opts?.contents ?? operations.zero(StringMute.schema.contents);
  }
  /** Gets @type {StringMuteAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StringMuteAttributes['color']}. */
  setColor(color: string | null): StringMute {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StringMuteAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StringMuteAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): StringMute {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StringMuteAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StringMuteAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): StringMute {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StringMuteAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StringMuteAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): StringMute {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StringMuteAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StringMuteAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): StringMute {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StringMuteAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StringMuteAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): StringMute {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StringMuteAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StringMuteAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): StringMute {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StringMuteAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {StringMuteAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): StringMute {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {StringMuteAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {StringMuteAttributes['id']}. */
  setId(id: string | null): StringMute {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {StringMuteAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StringMuteAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): StringMute {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StringMuteAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StringMuteAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): StringMute {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {StringMuteAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {StringMuteAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): StringMute {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type TuningStepAttributes = Record<string, unknown>;

export type TuningStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

/**
 * The `<tuning-step>` element
 *
 * Parent elements: `<accord>`, `<staff-tuning>`
 *
 * The `<tuning-step>` element is represented like the `<step>` element, with a different name to reflect its different
 * function in string tuning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuning-step/}
 */
export class TuningStep implements XMLElement<'tuning-step', TuningStepAttributes, TuningStepContents> {
  static readonly schema = {
    name: 'tuning-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = TuningStep.schema;

  attributes: TuningStepAttributes;
  contents: TuningStepContents;

  constructor(opts?: { attributes?: Partial<TuningStepAttributes>; contents?: TuningStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TuningStep.schema);
    this.contents = opts?.contents ?? operations.zero(TuningStep.schema.contents);
  }

  /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): this {
    this.contents[0] = step;
    return this;
  }
}

export type TuningAlterAttributes = Record<string, unknown>;

export type TuningAlterContents = [number];

/**
 * The `<tuning-alter>` element
 *
 * Parent elements: `<accord>`, `<staff-tuning>`
 *
 * The `<tuning-alter>` element is represented like the `<alter>` element, with a different name to reflect its
 * different function in string tuning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuning-alter/}
 */
export class TuningAlter implements XMLElement<'tuning-alter', TuningAlterAttributes, TuningAlterContents> {
  static readonly schema = {
    name: 'tuning-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = TuningAlter.schema;

  attributes: TuningAlterAttributes;
  contents: TuningAlterContents;

  constructor(opts?: { attributes?: Partial<TuningAlterAttributes>; contents?: TuningAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TuningAlter.schema);
    this.contents = opts?.contents ?? operations.zero(TuningAlter.schema.contents);
  }

  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type TuningOctaveAttributes = Record<string, unknown>;

export type TuningOctaveContents = [number];

/**
 * The `<tuning-octave>` element
 *
 * Parent elements: `<accord>`, `<staff-tuning>`
 *
 * The `<tuning-octave>` element is represented like the `<octave>` element, with a different name to reflect its
 * different function in string tuning.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/tuning-octave/}
 */
export class TuningOctave implements XMLElement<'tuning-octave', TuningOctaveAttributes, TuningOctaveContents> {
  static readonly schema = {
    name: 'tuning-octave',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = TuningOctave.schema;

  attributes: TuningOctaveAttributes;
  contents: TuningOctaveContents;

  constructor(opts?: { attributes?: Partial<TuningOctaveAttributes>; contents?: TuningOctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TuningOctave.schema);
    this.contents = opts?.contents ?? operations.zero(TuningOctave.schema.contents);
  }

  /** Gets @type {number}. */
  getOctave(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setOctave(octave: number): this {
    this.contents[0] = octave;
    return this;
  }
}

export type AccordAttributes = {
  /**
   *
   */
  string: number | null;
};

export type AccordContents = [TuningStep, TuningAlter | null, TuningOctave];

/**
 * The `<accord>` element
 *
 * Parent element: `<scordatura>`
 *
 * The `<accord>` element represents the tuning of a single string in the `<scordatura>` element. It uses the same group
 * of elements as the `<staff-tuning>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accord/}
 */
export class Accord implements XMLElement<'accord', AccordAttributes, AccordContents> {
  static readonly schema = {
    name: 'accord',
    attributes: { string: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } } },
    contents: [
      { type: 'required', value: TuningStep },
      { type: 'optional', value: TuningAlter },
      { type: 'required', value: TuningOctave },
    ],
  } as const;

  readonly schema = Accord.schema;

  attributes: AccordAttributes;
  contents: AccordContents;

  constructor(opts?: { attributes?: Partial<AccordAttributes>; contents?: AccordContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Accord.schema);
    this.contents = opts?.contents ?? operations.zero(Accord.schema.contents);
  }
  /** Gets @type {AccordAttributes['string']}. */
  getString(): number | null {
    return this.attributes['string'];
  }
  /** Sets @type {AccordAttributes['string']}. */
  setString(string: number | null): Accord {
    this.attributes['string'] = string;
    return this;
  }
  /** Gets @type {TuningStep}. */
  getTuningStep(): TuningStep {
    return this.contents[0];
  }
  /** Sets @type {TuningStep}. */
  setTuningStep(tuningStep: TuningStep): this {
    this.contents[0] = tuningStep;
    return this;
  }
  /** Gets @type {TuningAlter | null}. */
  getTuningAlter(): TuningAlter | null {
    return this.contents[1];
  }
  /** Sets @type {TuningAlter | null}. */
  setTuningAlter(tuningAlter: TuningAlter | null): this {
    this.contents[1] = tuningAlter;
    return this;
  }
  /** Gets @type {TuningOctave}. */
  getTuningOctave(): TuningOctave {
    return this.contents[2];
  }
  /** Sets @type {TuningOctave}. */
  setTuningOctave(tuningOctave: TuningOctave): this {
    this.contents[2] = tuningOctave;
    return this;
  }
}

export type ScordaturaAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
};

export type ScordaturaContents = [Array<Accord>];

/**
 * The `<scordatura>` element
 *
 * Parent element: `<direction-type>`
 *
 * Scordatura string tunings are represented by a series of `<accord>` elements, similar to the `<staff-tuning>`
 * elements. Strings are numbered from high to low.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/scordatura/}
 */
export class Scordatura implements XMLElement<'scordatura', ScordaturaAttributes, ScordaturaContents> {
  static readonly schema = {
    name: 'scordatura',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [{ type: 'label', label: 'accords', value: { type: 'oneOrMore', value: Accord } }],
  } as const;

  readonly schema = Scordatura.schema;

  attributes: ScordaturaAttributes;
  contents: ScordaturaContents;

  constructor(opts?: { attributes?: Partial<ScordaturaAttributes>; contents?: ScordaturaContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Scordatura.schema);
    this.contents = opts?.contents ?? operations.zero(Scordatura.schema.contents);
  }
  /** Gets @type {ScordaturaAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {ScordaturaAttributes['id']}. */
  setId(id: string | null): Scordatura {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Array<Accord>}. */
  getAccords(): Array<Accord> {
    return this.contents[0];
  }
  /** Sets @type {Array<Accord>}. */
  setAccords(accords: Array<Accord>): this {
    this.contents[0] = accords;
    return this;
  }
}

export type ImageAttributes = {
  /**
   * The URL for the image file.
   */
  source: string;
  /**
   * The MIME type for the image file format. Typical choices include application/postscript, image/gif, image/jpeg,
   * image/png, and image/tiff.
   */
  type: string;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
  /**
   * Used to size and scale an image. The image should be scaled independently in X and Y if both height and width
   * are specified. If only width is specified, the image should be scaled proportionally to fit in the specified X
   * dimension.
   */
  width: number | null;
};

export type ImageContents = [];

/**
 * The `<image>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<image>` element is used to include graphical images in a score.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/image/}
 */
export class Image implements XMLElement<'image', ImageAttributes, ImageContents> {
  static readonly schema = {
    name: 'image',
    attributes: {
      source: { type: 'required', value: { type: 'string' } },
      type: { type: 'required', value: { type: 'string' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = Image.schema;

  attributes: ImageAttributes;
  contents: ImageContents;

  constructor(opts?: { attributes?: Partial<ImageAttributes>; contents?: ImageContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Image.schema);
    this.contents = opts?.contents ?? operations.zero(Image.schema.contents);
  }
  /** Gets @type {ImageAttributes['source']}. */
  getSource(): string {
    return this.attributes['source'];
  }
  /** Sets @type {ImageAttributes['source']}. */
  setSource(source: string): Image {
    this.attributes['source'] = source;
    return this;
  }
  /** Gets @type {ImageAttributes['type']}. */
  getType(): string {
    return this.attributes['type'];
  }
  /** Sets @type {ImageAttributes['type']}. */
  setType(type: string): Image {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {ImageAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ImageAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Image {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ImageAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ImageAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Image {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ImageAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {ImageAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Image {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {ImageAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {ImageAttributes['id']}. */
  setId(id: string | null): Image {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {ImageAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ImageAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Image {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ImageAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ImageAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Image {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {ImageAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {ImageAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Image {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {ImageAttributes['width']}. */
  getWidth(): number | null {
    return this.attributes['width'];
  }
  /** Sets @type {ImageAttributes['width']}. */
  setWidth(width: number | null): Image {
    this.attributes['width'] = width;
    return this;
  }
}

export type PrincipalVoiceAttributes = {
  /**
   * Indicates the type of symbol used. When used for analysis separate from any printed score markings, it should
   * be set to none. Otherwise if the type is stop it should be set to plain.
   */
  symbol: 'none' | 'Hauptstimme' | 'Nebenstimme' | 'plain';
  /**
   * Indicates if this is the start or stop of the principal voice.
   */
  type: 'start' | 'stop';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type PrincipalVoiceContents = [string];

/**
 * The `<principal-voice>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<principal-voice>` element represents principal and secondary voices in a score, either for analysis or for
 * square bracket symbols that appear in a score. The content of the `<principal-voice>` element is used for analysis
 * and may be any text value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/principal-voice/}
 */
export class PrincipalVoice implements XMLElement<'principal-voice', PrincipalVoiceAttributes, PrincipalVoiceContents> {
  static readonly schema = {
    name: 'principal-voice',
    attributes: {
      symbol: {
        type: 'required',
        value: { type: 'choices', choices: ['none', 'Hauptstimme', 'Nebenstimme', 'plain'] },
      },
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = PrincipalVoice.schema;

  attributes: PrincipalVoiceAttributes;
  contents: PrincipalVoiceContents;

  constructor(opts?: { attributes?: Partial<PrincipalVoiceAttributes>; contents?: PrincipalVoiceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PrincipalVoice.schema);
    this.contents = opts?.contents ?? operations.zero(PrincipalVoice.schema.contents);
  }
  /** Gets @type {PrincipalVoiceAttributes['symbol']}. */
  getSymbol(): 'none' | 'Hauptstimme' | 'Nebenstimme' | 'plain' {
    return this.attributes['symbol'];
  }
  /** Sets @type {PrincipalVoiceAttributes['symbol']}. */
  setSymbol(symbol: 'none' | 'Hauptstimme' | 'Nebenstimme' | 'plain'): PrincipalVoice {
    this.attributes['symbol'] = symbol;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {PrincipalVoiceAttributes['type']}. */
  setType(type: 'start' | 'stop'): PrincipalVoice {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PrincipalVoiceAttributes['color']}. */
  setColor(color: string | null): PrincipalVoice {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PrincipalVoiceAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): PrincipalVoice {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PrincipalVoiceAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): PrincipalVoice {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PrincipalVoiceAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): PrincipalVoice {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PrincipalVoiceAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PrincipalVoice {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PrincipalVoiceAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PrincipalVoice {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PrincipalVoiceAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PrincipalVoice {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {PrincipalVoiceAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): PrincipalVoice {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {PrincipalVoiceAttributes['id']}. */
  setId(id: string | null): PrincipalVoice {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PrincipalVoiceAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): PrincipalVoice {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PrincipalVoiceAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): PrincipalVoice {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {PrincipalVoiceAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {PrincipalVoiceAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): PrincipalVoice {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type GlassAttributes = {
  /**
   * Distinguishes different SMuFL glyphs for wind chimes in the Chimes pictograms range, including those made of
   * materials other than glass.
   */
  smufl: string | null;
};

export type GlassContents = ['glass harmonica' | 'glass harp' | 'wind chimes'];

/**
 * The `<glass>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<glass>` element represents pictograms for glass percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/glass/}
 */
export class Glass implements XMLElement<'glass', GlassAttributes, GlassContents> {
  static readonly schema = {
    name: 'glass',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'glass-value',
          value: { type: 'choices', choices: ['glass harmonica', 'glass harp', 'wind chimes'] },
        },
      },
    ],
  } as const;

  readonly schema = Glass.schema;

  attributes: GlassAttributes;
  contents: GlassContents;

  constructor(opts?: { attributes?: Partial<GlassAttributes>; contents?: GlassContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Glass.schema);
    this.contents = opts?.contents ?? operations.zero(Glass.schema.contents);
  }
  /** Gets @type {GlassAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {GlassAttributes['smufl']}. */
  setSmufl(smufl: string | null): Glass {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'glass harmonica' | 'glass harp' | 'wind chimes'}. */
  getGlassValue(): 'glass harmonica' | 'glass harp' | 'wind chimes' {
    return this.contents[0];
  }
  /** Sets @type {'glass harmonica' | 'glass harp' | 'wind chimes'}. */
  setGlassValue(glassValue: 'glass harmonica' | 'glass harp' | 'wind chimes'): this {
    this.contents[0] = glassValue;
    return this;
  }
}

export type MetalAttributes = {
  /**
   * Distinguishes different SMuFL stylistic alternates.
   */
  smufl: string | null;
};

export type MetalContents = [
  | 'agogo'
  | 'almglocken'
  | 'bell'
  | 'bell plate'
  | 'bell tree'
  | 'brake drum'
  | 'cencerro'
  | 'chain rattle'
  | 'Chinese cymbal'
  | 'cowbell'
  | 'crash cymbals'
  | 'crotale'
  | 'cymbal tongs'
  | 'domed gong'
  | 'finger cymbals'
  | 'flexatone'
  | 'gong'
  | 'handbell'
  | 'hi-hat'
  | 'high-hat cymbals'
  | 'jaw harp'
  | 'jingle bells'
  | 'musical saw'
  | 'shell bells'
  | 'sistrum'
  | 'sizzle cymbal'
  | 'sleigh bells'
  | 'suspended cymbal'
  | 'tam tam'
  | 'tam tam with beater'
  | 'triangle'
  | 'Vietnamese hat',
];

/**
 * The `<metal>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<metal>` element represents pictograms for metal percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/metal/}
 */
export class Metal implements XMLElement<'metal', MetalAttributes, MetalContents> {
  static readonly schema = {
    name: 'metal',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'metal-value',
          value: {
            type: 'choices',
            choices: [
              'agogo',
              'almglocken',
              'bell',
              'bell plate',
              'bell tree',
              'brake drum',
              'cencerro',
              'chain rattle',
              'Chinese cymbal',
              'cowbell',
              'crash cymbals',
              'crotale',
              'cymbal tongs',
              'domed gong',
              'finger cymbals',
              'flexatone',
              'gong',
              'handbell',
              'hi-hat',
              'high-hat cymbals',
              'jaw harp',
              'jingle bells',
              'musical saw',
              'shell bells',
              'sistrum',
              'sizzle cymbal',
              'sleigh bells',
              'suspended cymbal',
              'tam tam',
              'tam tam with beater',
              'triangle',
              'Vietnamese hat',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Metal.schema;

  attributes: MetalAttributes;
  contents: MetalContents;

  constructor(opts?: { attributes?: Partial<MetalAttributes>; contents?: MetalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Metal.schema);
    this.contents = opts?.contents ?? operations.zero(Metal.schema.contents);
  }
  /** Gets @type {MetalAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {MetalAttributes['smufl']}. */
  setSmufl(smufl: string | null): Metal {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'agogo' | 'almglocken' | 'bell' | 'bell plate' | 'bell tree' | 'brake drum' | 'cencerro' | 'chain rattle' | 'Chinese cymbal' | 'cowbell' | 'crash cymbals' | 'crotale' | 'cymbal tongs' | 'domed gong' | 'finger cymbals' | 'flexatone' | 'gong' | 'handbell' | 'hi-hat' | 'high-hat cymbals' | 'jaw harp' | 'jingle bells' | 'musical saw' | 'shell bells' | 'sistrum' | 'sizzle cymbal' | 'sleigh bells' | 'suspended cymbal' | 'tam tam' | 'tam tam with beater' | 'triangle' | 'Vietnamese hat'}. */
  getMetalValue():
    | 'agogo'
    | 'almglocken'
    | 'bell'
    | 'bell plate'
    | 'bell tree'
    | 'brake drum'
    | 'cencerro'
    | 'chain rattle'
    | 'Chinese cymbal'
    | 'cowbell'
    | 'crash cymbals'
    | 'crotale'
    | 'cymbal tongs'
    | 'domed gong'
    | 'finger cymbals'
    | 'flexatone'
    | 'gong'
    | 'handbell'
    | 'hi-hat'
    | 'high-hat cymbals'
    | 'jaw harp'
    | 'jingle bells'
    | 'musical saw'
    | 'shell bells'
    | 'sistrum'
    | 'sizzle cymbal'
    | 'sleigh bells'
    | 'suspended cymbal'
    | 'tam tam'
    | 'tam tam with beater'
    | 'triangle'
    | 'Vietnamese hat' {
    return this.contents[0];
  }
  /** Sets @type {'agogo' | 'almglocken' | 'bell' | 'bell plate' | 'bell tree' | 'brake drum' | 'cencerro' | 'chain rattle' | 'Chinese cymbal' | 'cowbell' | 'crash cymbals' | 'crotale' | 'cymbal tongs' | 'domed gong' | 'finger cymbals' | 'flexatone' | 'gong' | 'handbell' | 'hi-hat' | 'high-hat cymbals' | 'jaw harp' | 'jingle bells' | 'musical saw' | 'shell bells' | 'sistrum' | 'sizzle cymbal' | 'sleigh bells' | 'suspended cymbal' | 'tam tam' | 'tam tam with beater' | 'triangle' | 'Vietnamese hat'}. */
  setMetalValue(
    metalValue:
      | 'agogo'
      | 'almglocken'
      | 'bell'
      | 'bell plate'
      | 'bell tree'
      | 'brake drum'
      | 'cencerro'
      | 'chain rattle'
      | 'Chinese cymbal'
      | 'cowbell'
      | 'crash cymbals'
      | 'crotale'
      | 'cymbal tongs'
      | 'domed gong'
      | 'finger cymbals'
      | 'flexatone'
      | 'gong'
      | 'handbell'
      | 'hi-hat'
      | 'high-hat cymbals'
      | 'jaw harp'
      | 'jingle bells'
      | 'musical saw'
      | 'shell bells'
      | 'sistrum'
      | 'sizzle cymbal'
      | 'sleigh bells'
      | 'suspended cymbal'
      | 'tam tam'
      | 'tam tam with beater'
      | 'triangle'
      | 'Vietnamese hat'
  ): this {
    this.contents[0] = metalValue;
    return this;
  }
}

export type WoodAttributes = {
  /**
   * Distinguishes different SMuFL stylistic alternates.
   */
  smufl: string | null;
};

export type WoodContents = [
  | 'bamboo scraper'
  | 'board clapper'
  | 'cabasa'
  | 'castanets'
  | 'castanets with handle'
  | 'claves'
  | 'footbal rattle'
  | 'guiro'
  | 'log drum'
  | 'maraca'
  | 'maracas'
  | 'quijada'
  | 'rainstick'
  | 'ratchet'
  | 'reco-reco'
  | 'sandpaper blocks'
  | 'slit drum'
  | 'temple block'
  | 'vibraslap'
  | 'whip'
  | 'wood block',
];

/**
 * The `<wood>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<wood>` element represents pictograms for wood percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/wood/}
 */
export class Wood implements XMLElement<'wood', WoodAttributes, WoodContents> {
  static readonly schema = {
    name: 'wood',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'wood-value',
          value: {
            type: 'choices',
            choices: [
              'bamboo scraper',
              'board clapper',
              'cabasa',
              'castanets',
              'castanets with handle',
              'claves',
              'footbal rattle',
              'guiro',
              'log drum',
              'maraca',
              'maracas',
              'quijada',
              'rainstick',
              'ratchet',
              'reco-reco',
              'sandpaper blocks',
              'slit drum',
              'temple block',
              'vibraslap',
              'whip',
              'wood block',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Wood.schema;

  attributes: WoodAttributes;
  contents: WoodContents;

  constructor(opts?: { attributes?: Partial<WoodAttributes>; contents?: WoodContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Wood.schema);
    this.contents = opts?.contents ?? operations.zero(Wood.schema.contents);
  }
  /** Gets @type {WoodAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {WoodAttributes['smufl']}. */
  setSmufl(smufl: string | null): Wood {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'bamboo scraper' | 'board clapper' | 'cabasa' | 'castanets' | 'castanets with handle' | 'claves' | 'footbal rattle' | 'guiro' | 'log drum' | 'maraca' | 'maracas' | 'quijada' | 'rainstick' | 'ratchet' | 'reco-reco' | 'sandpaper blocks' | 'slit drum' | 'temple block' | 'vibraslap' | 'whip' | 'wood block'}. */
  getWoodValue():
    | 'bamboo scraper'
    | 'board clapper'
    | 'cabasa'
    | 'castanets'
    | 'castanets with handle'
    | 'claves'
    | 'footbal rattle'
    | 'guiro'
    | 'log drum'
    | 'maraca'
    | 'maracas'
    | 'quijada'
    | 'rainstick'
    | 'ratchet'
    | 'reco-reco'
    | 'sandpaper blocks'
    | 'slit drum'
    | 'temple block'
    | 'vibraslap'
    | 'whip'
    | 'wood block' {
    return this.contents[0];
  }
  /** Sets @type {'bamboo scraper' | 'board clapper' | 'cabasa' | 'castanets' | 'castanets with handle' | 'claves' | 'footbal rattle' | 'guiro' | 'log drum' | 'maraca' | 'maracas' | 'quijada' | 'rainstick' | 'ratchet' | 'reco-reco' | 'sandpaper blocks' | 'slit drum' | 'temple block' | 'vibraslap' | 'whip' | 'wood block'}. */
  setWoodValue(
    woodValue:
      | 'bamboo scraper'
      | 'board clapper'
      | 'cabasa'
      | 'castanets'
      | 'castanets with handle'
      | 'claves'
      | 'footbal rattle'
      | 'guiro'
      | 'log drum'
      | 'maraca'
      | 'maracas'
      | 'quijada'
      | 'rainstick'
      | 'ratchet'
      | 'reco-reco'
      | 'sandpaper blocks'
      | 'slit drum'
      | 'temple block'
      | 'vibraslap'
      | 'whip'
      | 'wood block'
  ): this {
    this.contents[0] = woodValue;
    return this;
  }
}

export type PitchedAttributes = {
  /**
   * Distinguishes different SMuFL glyphs for a particular pictogram within the
   * [Tuned mallet percussion pictograms](https://www.w3.org/2021/03/smufl14/tables/tuned-mallet-percussion-pictograms.html)
   * range.
   */
  smufl: string | null;
};

export type PitchedContents = [];

/**
 * The `<pitched>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<pitched>` element represents pictograms for pitched percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/pitched/}
 */
export class Pitched implements XMLElement<'pitched', PitchedAttributes, PitchedContents> {
  static readonly schema = {
    name: 'pitched',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [],
  } as const;

  readonly schema = Pitched.schema;

  attributes: PitchedAttributes;
  contents: PitchedContents;

  constructor(opts?: { attributes?: Partial<PitchedAttributes>; contents?: PitchedContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Pitched.schema);
    this.contents = opts?.contents ?? operations.zero(Pitched.schema.contents);
  }
  /** Gets @type {PitchedAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {PitchedAttributes['smufl']}. */
  setSmufl(smufl: string | null): Pitched {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type MembraneAttributes = {
  /**
   * Distinguishes different SMuFL stylistic alternates.
   */
  smufl: string | null;
};

export type MembraneContents = [
  | 'bass drum'
  | 'bass drum on side'
  | 'bongos'
  | 'Chinese tomtom'
  | 'conga drum'
  | 'cuica'
  | 'goblet drum'
  | 'Indo-American tomtom'
  | 'Japanese tomtom'
  | 'military drum'
  | 'snare drum'
  | 'snare drum snares off'
  | 'tabla'
  | 'tambourine'
  | 'tenor drum'
  | 'timbales'
  | 'tomtom',
];

/**
 * The `<membrane>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<membrane>` element represents pictograms for membrane percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/membrane/}
 */
export class Membrane implements XMLElement<'membrane', MembraneAttributes, MembraneContents> {
  static readonly schema = {
    name: 'membrane',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'membrane-value',
          value: {
            type: 'choices',
            choices: [
              'bass drum',
              'bass drum on side',
              'bongos',
              'Chinese tomtom',
              'conga drum',
              'cuica',
              'goblet drum',
              'Indo-American tomtom',
              'Japanese tomtom',
              'military drum',
              'snare drum',
              'snare drum snares off',
              'tabla',
              'tambourine',
              'tenor drum',
              'timbales',
              'tomtom',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Membrane.schema;

  attributes: MembraneAttributes;
  contents: MembraneContents;

  constructor(opts?: { attributes?: Partial<MembraneAttributes>; contents?: MembraneContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Membrane.schema);
    this.contents = opts?.contents ?? operations.zero(Membrane.schema.contents);
  }
  /** Gets @type {MembraneAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {MembraneAttributes['smufl']}. */
  setSmufl(smufl: string | null): Membrane {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'bass drum' | 'bass drum on side' | 'bongos' | 'Chinese tomtom' | 'conga drum' | 'cuica' | 'goblet drum' | 'Indo-American tomtom' | 'Japanese tomtom' | 'military drum' | 'snare drum' | 'snare drum snares off' | 'tabla' | 'tambourine' | 'tenor drum' | 'timbales' | 'tomtom'}. */
  getMembraneValue():
    | 'bass drum'
    | 'bass drum on side'
    | 'bongos'
    | 'Chinese tomtom'
    | 'conga drum'
    | 'cuica'
    | 'goblet drum'
    | 'Indo-American tomtom'
    | 'Japanese tomtom'
    | 'military drum'
    | 'snare drum'
    | 'snare drum snares off'
    | 'tabla'
    | 'tambourine'
    | 'tenor drum'
    | 'timbales'
    | 'tomtom' {
    return this.contents[0];
  }
  /** Sets @type {'bass drum' | 'bass drum on side' | 'bongos' | 'Chinese tomtom' | 'conga drum' | 'cuica' | 'goblet drum' | 'Indo-American tomtom' | 'Japanese tomtom' | 'military drum' | 'snare drum' | 'snare drum snares off' | 'tabla' | 'tambourine' | 'tenor drum' | 'timbales' | 'tomtom'}. */
  setMembraneValue(
    membraneValue:
      | 'bass drum'
      | 'bass drum on side'
      | 'bongos'
      | 'Chinese tomtom'
      | 'conga drum'
      | 'cuica'
      | 'goblet drum'
      | 'Indo-American tomtom'
      | 'Japanese tomtom'
      | 'military drum'
      | 'snare drum'
      | 'snare drum snares off'
      | 'tabla'
      | 'tambourine'
      | 'tenor drum'
      | 'timbales'
      | 'tomtom'
  ): this {
    this.contents[0] = membraneValue;
    return this;
  }
}

export type EffectAttributes = {
  /**
   * Distinguishes different SMuFL stylistic alternates.
   */
  smufl: string | null;
};

export type EffectContents = [
  | 'anvil'
  | 'auto horn'
  | 'bird whistle'
  | 'cannon'
  | 'duck call'
  | 'gun shot'
  | 'klaxon horn'
  | 'lions roar'
  | 'lotus flute'
  | 'megaphone'
  | 'police whistle'
  | 'siren'
  | 'slide whistle'
  | 'thunder sheet'
  | 'wind machine'
  | 'wind whistle',
];

/**
 * The `<effect>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<effect>` element represents pictograms for sound effect percussion instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/effect/}
 */
export class Effect implements XMLElement<'effect', EffectAttributes, EffectContents> {
  static readonly schema = {
    name: 'effect',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'effect-value',
          value: {
            type: 'choices',
            choices: [
              'anvil',
              'auto horn',
              'bird whistle',
              'cannon',
              'duck call',
              'gun shot',
              'klaxon horn',
              'lions roar',
              'lotus flute',
              'megaphone',
              'police whistle',
              'siren',
              'slide whistle',
              'thunder sheet',
              'wind machine',
              'wind whistle',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Effect.schema;

  attributes: EffectAttributes;
  contents: EffectContents;

  constructor(opts?: { attributes?: Partial<EffectAttributes>; contents?: EffectContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Effect.schema);
    this.contents = opts?.contents ?? operations.zero(Effect.schema.contents);
  }
  /** Gets @type {EffectAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {EffectAttributes['smufl']}. */
  setSmufl(smufl: string | null): Effect {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'anvil' | 'auto horn' | 'bird whistle' | 'cannon' | 'duck call' | 'gun shot' | 'klaxon horn' | 'lions roar' | 'lotus flute' | 'megaphone' | 'police whistle' | 'siren' | 'slide whistle' | 'thunder sheet' | 'wind machine' | 'wind whistle'}. */
  getEffectValue():
    | 'anvil'
    | 'auto horn'
    | 'bird whistle'
    | 'cannon'
    | 'duck call'
    | 'gun shot'
    | 'klaxon horn'
    | 'lions roar'
    | 'lotus flute'
    | 'megaphone'
    | 'police whistle'
    | 'siren'
    | 'slide whistle'
    | 'thunder sheet'
    | 'wind machine'
    | 'wind whistle' {
    return this.contents[0];
  }
  /** Sets @type {'anvil' | 'auto horn' | 'bird whistle' | 'cannon' | 'duck call' | 'gun shot' | 'klaxon horn' | 'lions roar' | 'lotus flute' | 'megaphone' | 'police whistle' | 'siren' | 'slide whistle' | 'thunder sheet' | 'wind machine' | 'wind whistle'}. */
  setEffectValue(
    effectValue:
      | 'anvil'
      | 'auto horn'
      | 'bird whistle'
      | 'cannon'
      | 'duck call'
      | 'gun shot'
      | 'klaxon horn'
      | 'lions roar'
      | 'lotus flute'
      | 'megaphone'
      | 'police whistle'
      | 'siren'
      | 'slide whistle'
      | 'thunder sheet'
      | 'wind machine'
      | 'wind whistle'
  ): this {
    this.contents[0] = effectValue;
    return this;
  }
}

export type TimpaniAttributes = {
  /**
   * Distinguishes different SMuFL stylistic alternates.
   */
  smufl: string | null;
};

export type TimpaniContents = [];

/**
 * The `<timpani>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<timpani>` element represents the timpani pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/timpani/}
 */
export class Timpani implements XMLElement<'timpani', TimpaniAttributes, TimpaniContents> {
  static readonly schema = {
    name: 'timpani',
    attributes: { smufl: { type: 'optional', value: { type: 'regex', pattern: /pict/, zero: 'pict' } } },
    contents: [],
  } as const;

  readonly schema = Timpani.schema;

  attributes: TimpaniAttributes;
  contents: TimpaniContents;

  constructor(opts?: { attributes?: Partial<TimpaniAttributes>; contents?: TimpaniContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Timpani.schema);
    this.contents = opts?.contents ?? operations.zero(Timpani.schema.contents);
  }
  /** Gets @type {TimpaniAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {TimpaniAttributes['smufl']}. */
  setSmufl(smufl: string | null): Timpani {
    this.attributes['smufl'] = smufl;
    return this;
  }
}

export type BeaterAttributes = {
  /**
   * Indicates the direction in which the tip of the beater points.
   */
  tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null;
};

export type BeaterContents = [
  | 'bow'
  | 'chime hammer'
  | 'coin'
  | 'drum stick'
  | 'finger'
  | 'fingernail'
  | 'fist'
  | 'guiro scraper'
  | 'hammer'
  | 'hand'
  | 'jazz stick'
  | 'knitting needle'
  | 'metal hammer'
  | 'slide brush on gong'
  | 'snare stick'
  | 'spoon mallet'
  | 'superball'
  | 'triangle beater'
  | 'triangle beater plain'
  | 'wire brush',
];

/**
 * The `<beater>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<beater>` element represents pictograms for beaters, mallets, and sticks that do not have different materials
 * represented in the pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beater/}
 */
export class Beater implements XMLElement<'beater', BeaterAttributes, BeaterContents> {
  static readonly schema = {
    name: 'beater',
    attributes: {
      tip: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: ['down', 'left', 'northeast', 'northwest', 'right', 'southeast', 'southwest', 'up'],
        },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'beater-value',
          value: {
            type: 'choices',
            choices: [
              'bow',
              'chime hammer',
              'coin',
              'drum stick',
              'finger',
              'fingernail',
              'fist',
              'guiro scraper',
              'hammer',
              'hand',
              'jazz stick',
              'knitting needle',
              'metal hammer',
              'slide brush on gong',
              'snare stick',
              'spoon mallet',
              'superball',
              'triangle beater',
              'triangle beater plain',
              'wire brush',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Beater.schema;

  attributes: BeaterAttributes;
  contents: BeaterContents;

  constructor(opts?: { attributes?: Partial<BeaterAttributes>; contents?: BeaterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Beater.schema);
    this.contents = opts?.contents ?? operations.zero(Beater.schema.contents);
  }
  /** Gets @type {BeaterAttributes['tip']}. */
  getTip(): 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null {
    return this.attributes['tip'];
  }
  /** Sets @type {BeaterAttributes['tip']}. */
  setTip(tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null): Beater {
    this.attributes['tip'] = tip;
    return this;
  }
  /** Gets @type {'bow' | 'chime hammer' | 'coin' | 'drum stick' | 'finger' | 'fingernail' | 'fist' | 'guiro scraper' | 'hammer' | 'hand' | 'jazz stick' | 'knitting needle' | 'metal hammer' | 'slide brush on gong' | 'snare stick' | 'spoon mallet' | 'superball' | 'triangle beater' | 'triangle beater plain' | 'wire brush'}. */
  getBeaterValue():
    | 'bow'
    | 'chime hammer'
    | 'coin'
    | 'drum stick'
    | 'finger'
    | 'fingernail'
    | 'fist'
    | 'guiro scraper'
    | 'hammer'
    | 'hand'
    | 'jazz stick'
    | 'knitting needle'
    | 'metal hammer'
    | 'slide brush on gong'
    | 'snare stick'
    | 'spoon mallet'
    | 'superball'
    | 'triangle beater'
    | 'triangle beater plain'
    | 'wire brush' {
    return this.contents[0];
  }
  /** Sets @type {'bow' | 'chime hammer' | 'coin' | 'drum stick' | 'finger' | 'fingernail' | 'fist' | 'guiro scraper' | 'hammer' | 'hand' | 'jazz stick' | 'knitting needle' | 'metal hammer' | 'slide brush on gong' | 'snare stick' | 'spoon mallet' | 'superball' | 'triangle beater' | 'triangle beater plain' | 'wire brush'}. */
  setBeaterValue(
    beaterValue:
      | 'bow'
      | 'chime hammer'
      | 'coin'
      | 'drum stick'
      | 'finger'
      | 'fingernail'
      | 'fist'
      | 'guiro scraper'
      | 'hammer'
      | 'hand'
      | 'jazz stick'
      | 'knitting needle'
      | 'metal hammer'
      | 'slide brush on gong'
      | 'snare stick'
      | 'spoon mallet'
      | 'superball'
      | 'triangle beater'
      | 'triangle beater plain'
      | 'wire brush'
  ): this {
    this.contents[0] = beaterValue;
    return this;
  }
}

export type StickTypeAttributes = Record<string, unknown>;

export type StickTypeContents = [
  | 'bass drum'
  | 'double bass drum'
  | 'glockenspiel'
  | 'gum'
  | 'hammer'
  | 'superball'
  | 'timpani'
  | 'wound'
  | 'xylophone'
  | 'yarn',
];

/**
 * The `<stick-type>` element
 *
 * Parent element: `<stick>`
 *
 * The `<stick-type>` element represents the shape of pictograms where the material in the stick, mallet, or beater is
 * represented in the pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick-type/}
 */
export class StickType implements XMLElement<'stick-type', StickTypeAttributes, StickTypeContents> {
  static readonly schema = {
    name: 'stick-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'stick-type',
          value: {
            type: 'choices',
            choices: [
              'bass drum',
              'double bass drum',
              'glockenspiel',
              'gum',
              'hammer',
              'superball',
              'timpani',
              'wound',
              'xylophone',
              'yarn',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = StickType.schema;

  attributes: StickTypeAttributes;
  contents: StickTypeContents;

  constructor(opts?: { attributes?: Partial<StickTypeAttributes>; contents?: StickTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StickType.schema);
    this.contents = opts?.contents ?? operations.zero(StickType.schema.contents);
  }

  /** Gets @type {'bass drum' | 'double bass drum' | 'glockenspiel' | 'gum' | 'hammer' | 'superball' | 'timpani' | 'wound' | 'xylophone' | 'yarn'}. */
  getStickType():
    | 'bass drum'
    | 'double bass drum'
    | 'glockenspiel'
    | 'gum'
    | 'hammer'
    | 'superball'
    | 'timpani'
    | 'wound'
    | 'xylophone'
    | 'yarn' {
    return this.contents[0];
  }
  /** Sets @type {'bass drum' | 'double bass drum' | 'glockenspiel' | 'gum' | 'hammer' | 'superball' | 'timpani' | 'wound' | 'xylophone' | 'yarn'}. */
  setStickType(
    stickType:
      | 'bass drum'
      | 'double bass drum'
      | 'glockenspiel'
      | 'gum'
      | 'hammer'
      | 'superball'
      | 'timpani'
      | 'wound'
      | 'xylophone'
      | 'yarn'
  ): this {
    this.contents[0] = stickType;
    return this;
  }
}

export type StickMaterialAttributes = Record<string, unknown>;

export type StickMaterialContents = ['x' | 'hard' | 'medium' | 'shaded' | 'soft'];

/**
 * The `<stick-material>` element
 *
 * Parent element: `<stick>`
 *
 * The `<stick-material>` element represents the material being displayed in a stick pictogram.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick-material/}
 */
export class StickMaterial implements XMLElement<'stick-material', StickMaterialAttributes, StickMaterialContents> {
  static readonly schema = {
    name: 'stick-material',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'stick-material',
          value: { type: 'choices', choices: ['x', 'hard', 'medium', 'shaded', 'soft'] },
        },
      },
    ],
  } as const;

  readonly schema = StickMaterial.schema;

  attributes: StickMaterialAttributes;
  contents: StickMaterialContents;

  constructor(opts?: { attributes?: Partial<StickMaterialAttributes>; contents?: StickMaterialContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StickMaterial.schema);
    this.contents = opts?.contents ?? operations.zero(StickMaterial.schema.contents);
  }

  /** Gets @type {'x' | 'hard' | 'medium' | 'shaded' | 'soft'}. */
  getStickMaterial(): 'x' | 'hard' | 'medium' | 'shaded' | 'soft' {
    return this.contents[0];
  }
  /** Sets @type {'x' | 'hard' | 'medium' | 'shaded' | 'soft'}. */
  setStickMaterial(stickMaterial: 'x' | 'hard' | 'medium' | 'shaded' | 'soft'): this {
    this.contents[0] = stickMaterial;
    return this;
  }
}

export type StickAttributes = {
  /**
   * Indicates the presence of a dashed circle around the round beater part of a pictogram. The value is no if not
   * specified.
   */
  'dashed-circle': 'yes' | 'no' | null;
  /**
   * Indicates the presence of parentheses around the round beater part of a pictogram. The value is no if not
   * specified.
   */
  parentheses: 'yes' | 'no' | null;
  /**
   * Represents the direction in which the tip of a stick or beater points, using Unicode arrow terminology.
   */
  tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null;
};

export type StickContents = [StickType, StickMaterial];

/**
 * The `<stick>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<stick>` element represents pictograms where the material of the stick, mallet, or beater is included.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick/}
 */
export class Stick implements XMLElement<'stick', StickAttributes, StickContents> {
  static readonly schema = {
    name: 'stick',
    attributes: {
      'dashed-circle': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      tip: {
        type: 'optional',
        value: {
          type: 'choices',
          choices: ['down', 'left', 'northeast', 'northwest', 'right', 'southeast', 'southwest', 'up'],
        },
      },
    },
    contents: [
      { type: 'required', value: StickType },
      { type: 'required', value: StickMaterial },
    ],
  } as const;

  readonly schema = Stick.schema;

  attributes: StickAttributes;
  contents: StickContents;

  constructor(opts?: { attributes?: Partial<StickAttributes>; contents?: StickContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Stick.schema);
    this.contents = opts?.contents ?? operations.zero(Stick.schema.contents);
  }
  /** Gets @type {StickAttributes['dashed-circle']}. */
  getDashedCircle(): 'yes' | 'no' | null {
    return this.attributes['dashed-circle'];
  }
  /** Sets @type {StickAttributes['dashed-circle']}. */
  setDashedCircle(dashedCircle: 'yes' | 'no' | null): Stick {
    this.attributes['dashed-circle'] = dashedCircle;
    return this;
  }
  /** Gets @type {StickAttributes['parentheses']}. */
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  /** Sets @type {StickAttributes['parentheses']}. */
  setParentheses(parentheses: 'yes' | 'no' | null): Stick {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  /** Gets @type {StickAttributes['tip']}. */
  getTip(): 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null {
    return this.attributes['tip'];
  }
  /** Sets @type {StickAttributes['tip']}. */
  setTip(tip: 'down' | 'left' | 'northeast' | 'northwest' | 'right' | 'southeast' | 'southwest' | 'up' | null): Stick {
    this.attributes['tip'] = tip;
    return this;
  }
  /** Gets @type {StickType}. */
  getStickType(): StickType {
    return this.contents[0];
  }
  /** Sets @type {StickType}. */
  setStickType(stickType: StickType): this {
    this.contents[0] = stickType;
    return this;
  }
  /** Gets @type {StickMaterial}. */
  getStickMaterial(): StickMaterial {
    return this.contents[1];
  }
  /** Sets @type {StickMaterial}. */
  setStickMaterial(stickMaterial: StickMaterial): this {
    this.contents[1] = stickMaterial;
    return this;
  }
}

export type StickLocationAttributes = Record<string, unknown>;

export type StickLocationContents = ['center' | 'cymbal bell' | 'cymbal edge' | 'rim'];

/**
 * The `<stick-location>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<stick-location>` element represents pictograms for the location of sticks, beaters, or mallets on cymbals,
 * gongs, drums, and other instruments.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/stick-location/}
 */
export class StickLocation implements XMLElement<'stick-location', StickLocationAttributes, StickLocationContents> {
  static readonly schema = {
    name: 'stick-location',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'stick-location',
          value: { type: 'choices', choices: ['center', 'cymbal bell', 'cymbal edge', 'rim'] },
        },
      },
    ],
  } as const;

  readonly schema = StickLocation.schema;

  attributes: StickLocationAttributes;
  contents: StickLocationContents;

  constructor(opts?: { attributes?: Partial<StickLocationAttributes>; contents?: StickLocationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StickLocation.schema);
    this.contents = opts?.contents ?? operations.zero(StickLocation.schema.contents);
  }

  /** Gets @type {'center' | 'cymbal bell' | 'cymbal edge' | 'rim'}. */
  getStickLocation(): 'center' | 'cymbal bell' | 'cymbal edge' | 'rim' {
    return this.contents[0];
  }
  /** Sets @type {'center' | 'cymbal bell' | 'cymbal edge' | 'rim'}. */
  setStickLocation(stickLocation: 'center' | 'cymbal bell' | 'cymbal edge' | 'rim'): this {
    this.contents[0] = stickLocation;
    return this;
  }
}

export type OtherPercussionAttributes = {
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes this
   * is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
};

export type OtherPercussionContents = [string];

/**
 * The `<other-percussion>` element
 *
 * Parent element: `<percussion>`
 *
 * The `<other-percussion>` element represents percussion pictograms not defined elsewhere.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-percussion/}
 */
export class OtherPercussion
  implements XMLElement<'other-percussion', OtherPercussionAttributes, OtherPercussionContents>
{
  static readonly schema = {
    name: 'other-percussion',
    attributes: { smufl: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherPercussion.schema;

  attributes: OtherPercussionAttributes;
  contents: OtherPercussionContents;

  constructor(opts?: { attributes?: Partial<OtherPercussionAttributes>; contents?: OtherPercussionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherPercussion.schema);
    this.contents = opts?.contents ?? operations.zero(OtherPercussion.schema.contents);
  }
  /** Gets @type {OtherPercussionAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OtherPercussionAttributes['smufl']}. */
  setSmufl(smufl: string | null): OtherPercussion {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type PercussionAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type PercussionContents = [
  Glass | Metal | Wood | Pitched | Membrane | Effect | Timpani | Beater | Stick | StickLocation | OtherPercussion,
];

/**
 * The `<percussion>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<percussion>` element is used to define percussion pictogram symbols. The organization of these symbols follows
 * the definitions in Kurt Stone's "Music Notation in the Twentieth Century" on pages 206-212 and 223. More pictograms
 * have been added to the ones listed in Stone, based on how usage has evolved since the book was published in 1980.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/percussion/}
 */
export class Percussion implements XMLElement<'percussion', PercussionAttributes, PercussionContents> {
  static readonly schema = {
    name: 'percussion',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'choices',
          choices: [
            Glass,
            Metal,
            Wood,
            Pitched,
            Membrane,
            Effect,
            Timpani,
            Beater,
            Stick,
            StickLocation,
            OtherPercussion,
          ],
        },
      },
    ],
  } as const;

  readonly schema = Percussion.schema;

  attributes: PercussionAttributes;
  contents: PercussionContents;

  constructor(opts?: { attributes?: Partial<PercussionAttributes>; contents?: PercussionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Percussion.schema);
    this.contents = opts?.contents ?? operations.zero(Percussion.schema.contents);
  }
  /** Gets @type {PercussionAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PercussionAttributes['color']}. */
  setColor(color: string | null): Percussion {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PercussionAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PercussionAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Percussion {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PercussionAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PercussionAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Percussion {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PercussionAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PercussionAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Percussion {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PercussionAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PercussionAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Percussion {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PercussionAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PercussionAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Percussion {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PercussionAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PercussionAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Percussion {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PercussionAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {PercussionAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Percussion {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {PercussionAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {PercussionAttributes['id']}. */
  setId(id: string | null): Percussion {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {PercussionAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PercussionAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Percussion {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PercussionAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PercussionAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Percussion {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {PercussionAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {PercussionAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Percussion {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {Glass | Metal | Wood | Pitched | Membrane | Effect | Timpani | Beater | Stick | StickLocation | OtherPercussion}. */
  getValue():
    | Glass
    | Metal
    | Wood
    | Pitched
    | Membrane
    | Effect
    | Timpani
    | Beater
    | Stick
    | StickLocation
    | OtherPercussion {
    return this.contents[0];
  }
  /** Sets @type {Glass | Metal | Wood | Pitched | Membrane | Effect | Timpani | Beater | Stick | StickLocation | OtherPercussion}. */
  setValue(
    value:
      | Glass
      | Metal
      | Wood
      | Pitched
      | Membrane
      | Effect
      | Timpani
      | Beater
      | Stick
      | StickLocation
      | OtherPercussion
  ): this {
    this.contents[0] = value;
    return this;
  }
}

export type AccordionHighAttributes = Record<string, unknown>;

export type AccordionHighContents = [];

/**
 * The `<accordion-high>` element
 *
 * Parent element: `<accordion-registration>`
 *
 * The `<accordion-high>` element indicates the presence of a dot in the high (4') section of the registration symbol.
 * This element is omitted if no dot is present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-high/}
 */
export class AccordionHigh implements XMLElement<'accordion-high', AccordionHighAttributes, AccordionHighContents> {
  static readonly schema = { name: 'accordion-high', attributes: {}, contents: [] } as const;

  readonly schema = AccordionHigh.schema;

  attributes: AccordionHighAttributes;
  contents: AccordionHighContents;

  constructor(opts?: { attributes?: Partial<AccordionHighAttributes>; contents?: AccordionHighContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionHigh.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionHigh.schema.contents);
  }
}

export type AccordionMiddleAttributes = Record<string, unknown>;

export type AccordionMiddleContents = [number];

/**
 * The `<accordion-middle>` element
 *
 * Parent element: `<accordion-registration>`
 *
 * The `<accordion-middle>` element indicates the presence of 1 to 3 dots in the middle (8') section of the registration
 * symbol. This element is omitted if no dots are present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-middle/}
 */
export class AccordionMiddle
  implements XMLElement<'accordion-middle', AccordionMiddleAttributes, AccordionMiddleContents>
{
  static readonly schema = {
    name: 'accordion-middle',
    attributes: {},
    contents: [{ type: 'label', label: 'value', value: { type: 'int', min: 1, max: 3 } }],
  } as const;

  readonly schema = AccordionMiddle.schema;

  attributes: AccordionMiddleAttributes;
  contents: AccordionMiddleContents;

  constructor(opts?: { attributes?: Partial<AccordionMiddleAttributes>; contents?: AccordionMiddleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionMiddle.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionMiddle.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type AccordionLowAttributes = Record<string, unknown>;

export type AccordionLowContents = [];

/**
 * The `<accordion-low>` element
 *
 * Parent element: `<accordion-registration>`
 *
 * The `<accordion-low>` element indicates the presence of a dot in the low (16') section of the registration symbol.
 * This element is omitted if no dot is present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-low/}
 */
export class AccordionLow implements XMLElement<'accordion-low', AccordionLowAttributes, AccordionLowContents> {
  static readonly schema = { name: 'accordion-low', attributes: {}, contents: [] } as const;

  readonly schema = AccordionLow.schema;

  attributes: AccordionLowAttributes;
  contents: AccordionLowContents;

  constructor(opts?: { attributes?: Partial<AccordionLowAttributes>; contents?: AccordionLowContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionLow.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionLow.schema.contents);
  }
}

export type AccordionRegistrationAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type AccordionRegistrationContents = [AccordionHigh | null, AccordionMiddle | null, AccordionLow | null];

/**
 * The `<accordion-registration>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<accordion-registration>` element is used for accordion registration symbols. These are circular symbols divided
 * horizontally into high, middle, and low sections that correspond to 4', 8', and 16' pipes. Each `<accordion-high>`,
 * `<accordion-middle>`, and `<accordion-low>` element represents the presence of one or more dots in the registration
 * diagram. An `<accordion-registration>` element needs to have at least one of the child elements present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/accordion-registration/}
 */
export class AccordionRegistration
  implements XMLElement<'accordion-registration', AccordionRegistrationAttributes, AccordionRegistrationContents>
{
  static readonly schema = {
    name: 'accordion-registration',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      { type: 'optional', value: AccordionHigh },
      { type: 'optional', value: AccordionMiddle },
      { type: 'optional', value: AccordionLow },
    ],
  } as const;

  readonly schema = AccordionRegistration.schema;

  attributes: AccordionRegistrationAttributes;
  contents: AccordionRegistrationContents;

  constructor(opts?: {
    attributes?: Partial<AccordionRegistrationAttributes>;
    contents?: AccordionRegistrationContents;
  }) {
    this.attributes = operations.merge(opts?.attributes || {}, AccordionRegistration.schema);
    this.contents = opts?.contents ?? operations.zero(AccordionRegistration.schema.contents);
  }
  /** Gets @type {AccordionRegistrationAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {AccordionRegistrationAttributes['color']}. */
  setColor(color: string | null): AccordionRegistration {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {AccordionRegistrationAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): AccordionRegistration {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {AccordionRegistrationAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): AccordionRegistration {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {AccordionRegistrationAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): AccordionRegistration {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {AccordionRegistrationAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): AccordionRegistration {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {AccordionRegistrationAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): AccordionRegistration {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {AccordionRegistrationAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): AccordionRegistration {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {AccordionRegistrationAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): AccordionRegistration {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {AccordionRegistrationAttributes['id']}. */
  setId(id: string | null): AccordionRegistration {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {AccordionRegistrationAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): AccordionRegistration {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {AccordionRegistrationAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): AccordionRegistration {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {AccordionRegistrationAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {AccordionRegistrationAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): AccordionRegistration {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {AccordionHigh | null}. */
  getAccordionHigh(): AccordionHigh | null {
    return this.contents[0];
  }
  /** Sets @type {AccordionHigh | null}. */
  setAccordionHigh(accordionHigh: AccordionHigh | null): this {
    this.contents[0] = accordionHigh;
    return this;
  }
  /** Gets @type {AccordionMiddle | null}. */
  getAccordionMiddle(): AccordionMiddle | null {
    return this.contents[1];
  }
  /** Sets @type {AccordionMiddle | null}. */
  setAccordionMiddle(accordionMiddle: AccordionMiddle | null): this {
    this.contents[1] = accordionMiddle;
    return this;
  }
  /** Gets @type {AccordionLow | null}. */
  getAccordionLow(): AccordionLow | null {
    return this.contents[2];
  }
  /** Sets @type {AccordionLow | null}. */
  setAccordionLow(accordionLow: AccordionLow | null): this {
    this.contents[2] = accordionLow;
    return this;
  }
}

export type StaffDivideAttributes = {
  /**
   * Specifies the type of staff division symbol.
   */
  type: 'down' | 'up' | 'up-down';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type StaffDivideContents = [];

/**
 * The `<staff-divide>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<staff-divide>` element represents the staff division arrow symbols found in the Standard Music Font Layout
 * (SMuFL) Staff brackets and dividers range at code points U+E00B, U+E00C, and U+E00D.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-divide/}
 */
export class StaffDivide implements XMLElement<'staff-divide', StaffDivideAttributes, StaffDivideContents> {
  static readonly schema = {
    name: 'staff-divide',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['down', 'up', 'up-down'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [],
  } as const;

  readonly schema = StaffDivide.schema;

  attributes: StaffDivideAttributes;
  contents: StaffDivideContents;

  constructor(opts?: { attributes?: Partial<StaffDivideAttributes>; contents?: StaffDivideContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffDivide.schema);
    this.contents = opts?.contents ?? operations.zero(StaffDivide.schema.contents);
  }
  /** Gets @type {StaffDivideAttributes['type']}. */
  getType(): 'down' | 'up' | 'up-down' {
    return this.attributes['type'];
  }
  /** Sets @type {StaffDivideAttributes['type']}. */
  setType(type: 'down' | 'up' | 'up-down'): StaffDivide {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {StaffDivideAttributes['color']}. */
  setColor(color: string | null): StaffDivide {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {StaffDivideAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): StaffDivide {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {StaffDivideAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): StaffDivide {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {StaffDivideAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): StaffDivide {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {StaffDivideAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): StaffDivide {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {StaffDivideAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): StaffDivide {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {StaffDivideAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): StaffDivide {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {StaffDivideAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): StaffDivide {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {StaffDivideAttributes['id']}. */
  setId(id: string | null): StaffDivide {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {StaffDivideAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): StaffDivide {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {StaffDivideAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): StaffDivide {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {StaffDivideAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {StaffDivideAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): StaffDivide {
    this.attributes['valign'] = valign;
    return this;
  }
}

export type OtherDirectionAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates a particular Standard Music Font Layout (SMuFL) character using its canonical glyph name. Sometimes
   * this is a formatting choice, and sometimes this is a refinement of the semantic meaning of an element.
   */
  smufl: string | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type OtherDirectionContents = [string];

/**
 * The `<other-direction>` element
 *
 * Parent element: `<direction-type>`
 *
 * The `<other-direction>` element is used to define any `<direction>` symbols not yet in the MusicXML format. The smufl
 * attribute can be used to specify a particular direction symbol, allowing application interoperability without
 * requiring every SMuFL glyph to have a MusicXML element equivalent. Using the <other-direction> element without the
 * smufl attribute allows for extended representation, though without application interoperability.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-direction/}
 */
export class OtherDirection implements XMLElement<'other-direction', OtherDirectionAttributes, OtherDirectionContents> {
  static readonly schema = {
    name: 'other-direction',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      smufl: { type: 'optional', value: { type: 'string' } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = OtherDirection.schema;

  attributes: OtherDirectionAttributes;
  contents: OtherDirectionContents;

  constructor(opts?: { attributes?: Partial<OtherDirectionAttributes>; contents?: OtherDirectionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherDirection.schema);
    this.contents = opts?.contents ?? operations.zero(OtherDirection.schema.contents);
  }
  /** Gets @type {OtherDirectionAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {OtherDirectionAttributes['color']}. */
  setColor(color: string | null): OtherDirection {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {OtherDirectionAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): OtherDirection {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {OtherDirectionAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): OtherDirection {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {OtherDirectionAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): OtherDirection {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {OtherDirectionAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): OtherDirection {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {OtherDirectionAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): OtherDirection {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {OtherDirectionAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): OtherDirection {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {OtherDirectionAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): OtherDirection {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {OtherDirectionAttributes['id']}. */
  setId(id: string | null): OtherDirection {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {OtherDirectionAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): OtherDirection {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {OtherDirectionAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): OtherDirection {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {OtherDirectionAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): OtherDirection {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {OtherDirectionAttributes['smufl']}. */
  setSmufl(smufl: string | null): OtherDirection {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {OtherDirectionAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {OtherDirectionAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): OtherDirection {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type Rehearsals = Array<Rehearsal>;

export type Segnos = Array<Segno>;

export type Codas = Array<Coda>;

export type Tokens = Array<Words | Symbol>;

export type DynamicsList = Array<Dynamics>;

export type Percussions = Array<Percussion>;

export type DirectionTypeAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
};

export type DirectionTypeContents = [
  | Rehearsals
  | Segnos
  | Codas
  | Tokens
  | Wedge
  | DynamicsList
  | Dashes
  | Bracket
  | Pedal
  | Metronome
  | OctaveShift
  | HarpPedals
  | Damp
  | DampAll
  | Eyeglasses
  | StringMute
  | Scordatura
  | Image
  | PrincipalVoice
  | Percussions
  | AccordionRegistration
  | StaffDivide
  | OtherDirection,
];

/**
 * The `<direction-type>` element
 *
 * Parent element: `<direction>`
 *
 * Textual direction types may have more than 1 component due to multiple fonts. The `<dynamics>` element may also be
 * used in the `<notations>` element. Child element attributes related to print suggestions apply to the individual
 * `<direction-type>`, not to the overall `<direction>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/direction-type/}
 */
export class DirectionType implements XMLElement<'direction-type', DirectionTypeAttributes, DirectionTypeContents> {
  static readonly schema = {
    name: 'direction-type',
    attributes: { id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      {
        type: 'label',
        label: 'direction-type',
        value: {
          type: 'choices',
          choices: [
            { type: 'label', label: 'rehearsals', value: { type: 'oneOrMore', value: Rehearsal } },
            { type: 'label', label: 'segnos', value: { type: 'oneOrMore', value: Segno } },
            { type: 'label', label: 'codas', value: { type: 'oneOrMore', value: Coda } },
            {
              type: 'label',
              label: 'tokens',
              value: { type: 'oneOrMore', value: { type: 'choices', choices: [Words, Symbol] } },
            },
            Wedge,
            { type: 'label', label: 'dynamics-list', value: { type: 'oneOrMore', value: Dynamics } },
            Dashes,
            Bracket,
            Pedal,
            Metronome,
            OctaveShift,
            HarpPedals,
            Damp,
            DampAll,
            Eyeglasses,
            StringMute,
            Scordatura,
            Image,
            PrincipalVoice,
            { type: 'label', label: 'percussions', value: { type: 'oneOrMore', value: Percussion } },
            AccordionRegistration,
            StaffDivide,
            OtherDirection,
          ],
        },
      },
    ],
  } as const;

  readonly schema = DirectionType.schema;

  attributes: DirectionTypeAttributes;
  contents: DirectionTypeContents;

  constructor(opts?: { attributes?: Partial<DirectionTypeAttributes>; contents?: DirectionTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DirectionType.schema);
    this.contents = opts?.contents ?? operations.zero(DirectionType.schema.contents);
  }
  /** Gets @type {DirectionTypeAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {DirectionTypeAttributes['id']}. */
  setId(id: string | null): DirectionType {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Rehearsals | Segnos | Codas | Tokens | Wedge | DynamicsList | Dashes | Bracket | Pedal | Metronome | OctaveShift | HarpPedals | Damp | DampAll | Eyeglasses | StringMute | Scordatura | Image | PrincipalVoice | Percussions | AccordionRegistration | StaffDivide | OtherDirection}. */
  getDirectionType():
    | Rehearsals
    | Segnos
    | Codas
    | Tokens
    | Wedge
    | DynamicsList
    | Dashes
    | Bracket
    | Pedal
    | Metronome
    | OctaveShift
    | HarpPedals
    | Damp
    | DampAll
    | Eyeglasses
    | StringMute
    | Scordatura
    | Image
    | PrincipalVoice
    | Percussions
    | AccordionRegistration
    | StaffDivide
    | OtherDirection {
    return this.contents[0];
  }
  /** Sets @type {Rehearsals | Segnos | Codas | Tokens | Wedge | DynamicsList | Dashes | Bracket | Pedal | Metronome | OctaveShift | HarpPedals | Damp | DampAll | Eyeglasses | StringMute | Scordatura | Image | PrincipalVoice | Percussions | AccordionRegistration | StaffDivide | OtherDirection}. */
  setDirectionType(
    directionType:
      | Rehearsals
      | Segnos
      | Codas
      | Tokens
      | Wedge
      | DynamicsList
      | Dashes
      | Bracket
      | Pedal
      | Metronome
      | OctaveShift
      | HarpPedals
      | Damp
      | DampAll
      | Eyeglasses
      | StringMute
      | Scordatura
      | Image
      | PrincipalVoice
      | Percussions
      | AccordionRegistration
      | StaffDivide
      | OtherDirection
  ): this {
    this.contents[0] = directionType;
    return this;
  }
}

export type OffsetAttributes = {
  /**
   * The offset affects the visual appearance of the direction. If the sound attribute is yes, then the offset
   * affects playback and listening too. If it is no, then any `<sound>` or `<listening>` associated with the
   * `<direction>` takes effect at the current location. It is no if not specified for compatibility with earlier
   * MusicXML versions.
   */
  sound: 'yes' | 'no' | null;
};

export type OffsetContents = [number];

/**
 * The `<offset>` element
 *
 * Parent elements: `<direction>`, `<harmony>`, `<listening>`, `<sound>`
 *
 * An `<offset>` is represented in terms of divisions, and indicates where the direction will appear relative to the
 * current musical location. The current musical location is always within the current measure, even at the end of a
 * measure. If an element within a `<direction>` includes a default-x attribute, the `<offset>` value will be ignored
 * when determining the appearance of that element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/offset/}
 */
export class Offset implements XMLElement<'offset', OffsetAttributes, OffsetContents> {
  static readonly schema = {
    name: 'offset',
    attributes: { sound: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Offset.schema;

  attributes: OffsetAttributes;
  contents: OffsetContents;

  constructor(opts?: { attributes?: Partial<OffsetAttributes>; contents?: OffsetContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Offset.schema);
    this.contents = opts?.contents ?? operations.zero(Offset.schema.contents);
  }
  /** Gets @type {OffsetAttributes['sound']}. */
  getSound(): 'yes' | 'no' | null {
    return this.attributes['sound'];
  }
  /** Sets @type {OffsetAttributes['sound']}. */
  setSound(sound: 'yes' | 'no' | null): Offset {
    this.attributes['sound'] = sound;
    return this;
  }
  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type InstrumentChangeAttributes = {
  /**
   * Refers to the `<score-instrument>` affected by the change.
   */
  id: string;
};

export type InstrumentChangeContents = [InstrumentSound | null, Array<Solo | Ensemble>, VirtualInstrument | null];

/**
 * The `<instrument-change>` element
 *
 * Parent element: `<sound>`
 *
 * The `<instrument-change>` element type represents a change to the virtual instrument sound for a given
 * `<score-instrument>`. All `<instrument-change>` child elements can also be initially specified within the
 * `<score-instrument>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instrument-change/}
 */
export class InstrumentChange
  implements XMLElement<'instrument-change', InstrumentChangeAttributes, InstrumentChangeContents>
{
  static readonly schema = {
    name: 'instrument-change',
    attributes: { id: { type: 'required', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } } },
    contents: [
      { type: 'optional', value: InstrumentSound },
      {
        type: 'label',
        label: 'instrument-types',
        value: { type: 'zeroOrMore', value: { type: 'choices', choices: [Solo, Ensemble] } },
      },
      { type: 'optional', value: VirtualInstrument },
    ],
  } as const;

  readonly schema = InstrumentChange.schema;

  attributes: InstrumentChangeAttributes;
  contents: InstrumentChangeContents;

  constructor(opts?: { attributes?: Partial<InstrumentChangeAttributes>; contents?: InstrumentChangeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, InstrumentChange.schema);
    this.contents = opts?.contents ?? operations.zero(InstrumentChange.schema.contents);
  }
  /** Gets @type {InstrumentChangeAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {InstrumentChangeAttributes['id']}. */
  setId(id: string): InstrumentChange {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {InstrumentSound | null}. */
  getInstrumentSound(): InstrumentSound | null {
    return this.contents[0];
  }
  /** Sets @type {InstrumentSound | null}. */
  setInstrumentSound(instrumentSound: InstrumentSound | null): this {
    this.contents[0] = instrumentSound;
    return this;
  }
  /** Gets @type {Array<Solo | Ensemble>}. */
  getInstrumentTypes(): Array<Solo | Ensemble> {
    return this.contents[1];
  }
  /** Sets @type {Array<Solo | Ensemble>}. */
  setInstrumentTypes(instrumentTypes: Array<Solo | Ensemble>): this {
    this.contents[1] = instrumentTypes;
    return this;
  }
  /** Gets @type {VirtualInstrument | null}. */
  getVirtualInstrument(): VirtualInstrument | null {
    return this.contents[2];
  }
  /** Sets @type {VirtualInstrument | null}. */
  setVirtualInstrument(virtualInstrument: VirtualInstrument | null): this {
    this.contents[2] = virtualInstrument;
    return this;
  }
}

export type StraightAttributes = Record<string, unknown>;

export type StraightContents = [];

/**
 * The `<straight>` element
 *
 * Parent element: `<swing>`
 *
 * The `<straight>` element specifies that no swing is present, so consecutive notes have equal durations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/straight/}
 */
export class Straight implements XMLElement<'straight', StraightAttributes, StraightContents> {
  static readonly schema = { name: 'straight', attributes: {}, contents: [] } as const;

  readonly schema = Straight.schema;

  attributes: StraightAttributes;
  contents: StraightContents;

  constructor(opts?: { attributes?: Partial<StraightAttributes>; contents?: StraightContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Straight.schema);
    this.contents = opts?.contents ?? operations.zero(Straight.schema.contents);
  }
}

export type FirstAttributes = Record<string, unknown>;

export type FirstContents = [number];

/**
 * The `<first>` element
 *
 * Parent element: `<swing>`
 *
 * The `<first>` element is the part of the swing ratio that refers to the first of two consecutive notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/first/}
 */
export class First implements XMLElement<'first', FirstAttributes, FirstContents> {
  static readonly schema = {
    name: 'first',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'swing-ratio',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = First.schema;

  attributes: FirstAttributes;
  contents: FirstContents;

  constructor(opts?: { attributes?: Partial<FirstAttributes>; contents?: FirstContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, First.schema);
    this.contents = opts?.contents ?? operations.zero(First.schema.contents);
  }

  /** Gets @type {number}. */
  getSwingRatio(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSwingRatio(swingRatio: number): this {
    this.contents[0] = swingRatio;
    return this;
  }
}

export type SecondAttributes = Record<string, unknown>;

export type SecondContents = [number];

/**
 * The `<second>` element
 *
 * Parent element: `<swing>`
 *
 * The `<second>` element is the part of the swing ratio that refers to the second of two consecutive notes.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/second/}
 */
export class Second implements XMLElement<'second', SecondAttributes, SecondContents> {
  static readonly schema = {
    name: 'second',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
    ],
  } as const;

  readonly schema = Second.schema;

  attributes: SecondAttributes;
  contents: SecondContents;

  constructor(opts?: { attributes?: Partial<SecondAttributes>; contents?: SecondContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Second.schema);
    this.contents = opts?.contents ?? operations.zero(Second.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type SwingTypeAttributes = Record<string, unknown>;

export type SwingTypeContents = ['eighth' | '16th'];

/**
 * The `<swing-type>` element
 *
 * Parent element: `<swing>`
 *
 * The `<swing-type>` element specifies the note type, either eighth or 16th, to which the `<first>` to `<second>` ratio
 * is applied. The value is eighth if this element is not present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/swing-type/}
 */
export class SwingType implements XMLElement<'swing-type', SwingTypeAttributes, SwingTypeContents> {
  static readonly schema = {
    name: 'swing-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'eighth', value: { type: 'choices', choices: ['eighth', '16th'] } },
      },
    ],
  } as const;

  readonly schema = SwingType.schema;

  attributes: SwingTypeAttributes;
  contents: SwingTypeContents;

  constructor(opts?: { attributes?: Partial<SwingTypeAttributes>; contents?: SwingTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SwingType.schema);
    this.contents = opts?.contents ?? operations.zero(SwingType.schema.contents);
  }

  /** Gets @type {'eighth' | '16th'}. */
  getEighth(): 'eighth' | '16th' {
    return this.contents[0];
  }
  /** Sets @type {'eighth' | '16th'}. */
  setEighth(eighth: 'eighth' | '16th'): this {
    this.contents[0] = eighth;
    return this;
  }
}

export type SwingStyleAttributes = Record<string, unknown>;

export type SwingStyleContents = [string];

/**
 * The `<swing-style>` element
 *
 * Parent element: `<swing>`
 *
 * The `<swing-style>` element is a string describing the style of swing used.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/swing-style/}
 */
export class SwingStyle implements XMLElement<'swing-style', SwingStyleAttributes, SwingStyleContents> {
  static readonly schema = {
    name: 'swing-style',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = SwingStyle.schema;

  attributes: SwingStyleAttributes;
  contents: SwingStyleContents;

  constructor(opts?: { attributes?: Partial<SwingStyleAttributes>; contents?: SwingStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SwingStyle.schema);
    this.contents = opts?.contents ?? operations.zero(SwingStyle.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type AlternateSwing = [First, Second, SwingType | null];

export type SwingAttributes = Record<string, unknown>;

export type SwingContents = [Straight | AlternateSwing, SwingStyle | null];

/**
 * The `<swing>` element
 *
 * Parent element: `<sound>`
 *
 * The `<swing>` element specifies whether or not to use swing playback, where consecutive on-beat / off-beat eighth or
 * 16th notes are played with unequal nominal durations.
 *
 * The `<first>` and `<second>` elements are positive integers that specify the ratio between durations of consecutive
 * notes. For example, a `<first>` element with a value of 2 and a `<second>` element with a value of 1 applied to
 * eighth notes specifies a quarter note / eighth note tuplet playback, where the first note is twice as long as the
 * second note. Ratios should be specified with the smallest integers possible. For example, a ratio of 6 to 4 should be
 * specified as 3 to 2 instead.
 *
 * The `<swing>` element has no effect for playback of grace notes, notes where a `<type>` element is not present, and
 * notes where the specified `<duration>` is different than the nominal value associated with the specified `<type>`. If
 * a swung note has attack and release attributes, those values modify the swung playback.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/swing/}
 */
export class Swing implements XMLElement<'swing', SwingAttributes, SwingContents> {
  static readonly schema = {
    name: 'swing',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'choices',
          choices: [
            Straight,
            {
              type: 'label',
              label: 'alternate-swing',
              value: [
                { type: 'required', value: First },
                { type: 'required', value: Second },
                { type: 'optional', value: SwingType },
              ],
            },
          ],
        },
      },
      { type: 'optional', value: SwingStyle },
    ],
  } as const;

  readonly schema = Swing.schema;

  attributes: SwingAttributes;
  contents: SwingContents;

  constructor(opts?: { attributes?: Partial<SwingAttributes>; contents?: SwingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Swing.schema);
    this.contents = opts?.contents ?? operations.zero(Swing.schema.contents);
  }

  /** Gets @type {Straight | AlternateSwing}. */
  getValue(): Straight | AlternateSwing {
    return this.contents[0];
  }
  /** Sets @type {Straight | AlternateSwing}. */
  setValue(value: Straight | AlternateSwing): this {
    this.contents[0] = value;
    return this;
  }
  /** Gets @type {SwingStyle | null}. */
  getSwingStyle(): SwingStyle | null {
    return this.contents[1];
  }
  /** Sets @type {SwingStyle | null}. */
  setSwingStyle(swingStyle: SwingStyle | null): this {
    this.contents[1] = swingStyle;
    return this;
  }
}

export type SoundAttributes = {
  /**
   * Indicates the end point for a forward jump to a coda sign. If there are multiple jumps, the value of these
   * parameters can be used to name and distinguish them.
   */
  coda: string | null;
  /**
   * Indicates to go back to the beginning of the movement. When used it always has the value "yes".
   *
   * By default, a dacapo attribute indicates that the jump should occur the first time through. The times that
   * jumps occur can be changed by using the time-only attribute.
   */
  dacapo: 'yes' | 'no' | null;
  /**
   * Indicates the starting point for a backward jump to a segno sign. If there are multiple jumps, the value of
   * these parameters can be used to name and distinguish them.
   *
   * By default, a dalsegno attribute indicates that the jump should occur the first time through. The times that
   * jumps occur can be changed by using the time-only attribute.
   */
  dalsegno: string | null;
  /**
   * Effects playback of the the common right piano pedal and its MIDI controller equivalent. The yes value
   * indicates the pedal is depressed; no indicates the pedal is released. A numeric value from 0 to 100 may also be
   * used for half pedaling. This value is the percentage that the pedal is depressed. A value of 0 is equivalent to
   * no, and a value of 100 is equivalent to yes.
   */
  'damper-pedal': 'no' | 'yes' | 0 | 1 | null;
  /**
   * If the segno or coda attributes are used, the divisions attribute can be used to indicate the number of
   * divisions per quarter note. Otherwise sound and MIDI generating programs may have to recompute this.
   */
  divisions: number | null;
  /**
   * Dynamics (or MIDI velocity) are expressed as a percentage of the default forte value (90 for MIDI 1.0).
   */
  dynamics: number | null;
  /**
   * Allows placing of sound in a 3-D space relative to the listener, expressed in degrees ranging from -180 to 180.
   * 0 is level with the listener, 90 is directly above, and -90 is directly below.
   *
   * Deprecated as of Version 2.0. The `<elevation>` element in the `<midi-instrument>` element should be used
   * instead. If both are present, the `<elevation>` element takes priority.
   */
  elevation: number | null;
  /**
   * Follows the final note or rest in a movement with a da capo or dal segno direction. If numeric, the value
   * represents the actual duration of the final note or rest, which can be ambiguous in written notation and
   * different among parts and voices. The value may also be "yes" to indicate no change to the final duration.
   */
  fine: string | null;
  /**
   * Indicates that a forward repeat sign is implied but not displayed. It is used for example in two-part forms
   * with repeats, such as a minuet and trio where no repeat is displayed at the start of the trio. This usually
   * occurs after a barline. When used it always has the value of "yes".
   */
  'forward-repeat': 'yes' | 'no' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Allows placing of sound in a 3-D space relative to the listener, expressed in degrees ranging from -180 to 180.
   * 0 is straight ahead, -90 is hard left, 90 is hard right, and -180 and 180 are directly behind the listener.
   *
   * Deprecated as of Version 2.0. The `<pan>` element in the `<midi-instrument>` element should be used instead. If
   * both are present, the `<pan>` element takes priority.
   */
  pan: number | null;
  /**
   * Affects all following notes. Yes indicates pizzicato, no indicates arco.
   */
  pizzicato: 'yes' | 'no' | null;
  /**
   * Indicates the end point for a backward jump to a segno sign. If there are multiple jumps, the value of these
   * parameters can be used to name and distinguish them.
   */
  segno: string | null;
  /**
   * Effects playback of the the common left piano pedal and its MIDI controller equivalent. The yes value indicates
   * the pedal is depressed; no indicates the pedal is released. A numeric value from 0 to 100 may also be used for
   * half pedaling. This value is the percentage that the pedal is depressed. A value of 0 is equivalent to no, and
   * a value of 100 is equivalent to yes.
   */
  'soft-pedal': 'no' | 'yes' | 0 | 1 | null;
  /**
   * Effects playback of the the common center piano pedal and its MIDI controller equivalent. The yes value
   * indicates the pedal is depressed; no indicates the pedal is released. A numeric value from 0 to 100 may also be
   * used for half pedaling. This value is the percentage that the pedal is depressed. A value of 0 is equivalent to
   * no, and a value of 100 is equivalent to yes.
   */
  'sostenuto-pedal': 'no' | 'yes' | 0 | 1 | null;
  /**
   * Tempo is expressed in quarter notes per minute. If 0, the sound-generating program should prompt the user at
   * the time of compiling a sound (MIDI) file.
   */
  tempo: number | null;
  /**
   * Indicates which times to apply the sound element if the <sound> element applies only particular times through a
   * repeat.
   */
  'time-only': string | null;
  /**
   * Indicates the starting point for a forward jump to a coda sign. If there are multiple jumps, the value of these
   * parameters can be used to name and distinguish them.
   *
   * By default, a tocoda attribute indicates the jump should occur the second time through. The times that jumps
   * occur can be changed by using the time-only attribute.
   */
  tocoda: string | null;
};

export type SoundContents = [
  Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>,
  Swing | null,
  Offset | null,
];

/**
 * The `<sound>` element
 *
 * Parent elements: `<direction>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<sound>` element contains general playback parameters. They can stand alone within a part/measure, or be a
 * component element within a direction.
 *
 * Instrument changes, MIDI devices, MIDI instruments, and playback techniques are changed using the
 * `<instrument-change>`, `<midi-device>`, `<midi-instrument>`, and `<play>` elements. When there are multiple instances
 * of these elements, they should be grouped together by instrument using the id attribute values.
 *
 * The `<offset>` element is used to indicate that the sound takes place offset from the current score position. If the
 * `<sound>` element is a child of a `<direction>` element, the sound `<offset>` element overrides the direction
 * `<offset>` element if both elements are present. Note that the offset reflects the intended musical position for the
 * change in sound. It should not be used to compensate for latency issues in particular hardware configurations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sound/}
 */
export class Sound implements XMLElement<'sound', SoundAttributes, SoundContents> {
  static readonly schema = {
    name: 'sound',
    attributes: {
      coda: { type: 'optional', value: { type: 'string' } },
      dacapo: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      dalsegno: { type: 'optional', value: { type: 'string' } },
      'damper-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
      divisions: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      dynamics: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      elevation: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      fine: { type: 'optional', value: { type: 'string' } },
      'forward-repeat': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      pan: { type: 'optional', value: { type: 'float', min: -180, max: 180 } },
      pizzicato: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      segno: { type: 'optional', value: { type: 'string' } },
      'soft-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
      'sostenuto-pedal': { type: 'optional', value: { type: 'choices', choices: ['no', 'yes', 0, 1] } },
      tempo: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
      tocoda: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'label',
        label: 'playbacks',
        value: {
          type: 'zeroOrMore',
          value: [
            { type: 'optional', value: InstrumentChange },
            { type: 'optional', value: MidiDevice },
            { type: 'optional', value: MidiInstrument },
            { type: 'optional', value: Play },
          ],
        },
      },
      { type: 'optional', value: Swing },
      { type: 'optional', value: Offset },
    ],
  } as const;

  readonly schema = Sound.schema;

  attributes: SoundAttributes;
  contents: SoundContents;

  constructor(opts?: { attributes?: Partial<SoundAttributes>; contents?: SoundContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sound.schema);
    this.contents = opts?.contents ?? operations.zero(Sound.schema.contents);
  }
  /** Gets @type {SoundAttributes['coda']}. */
  getCoda(): string | null {
    return this.attributes['coda'];
  }
  /** Sets @type {SoundAttributes['coda']}. */
  setCoda(coda: string | null): Sound {
    this.attributes['coda'] = coda;
    return this;
  }
  /** Gets @type {SoundAttributes['dacapo']}. */
  getDacapo(): 'yes' | 'no' | null {
    return this.attributes['dacapo'];
  }
  /** Sets @type {SoundAttributes['dacapo']}. */
  setDacapo(dacapo: 'yes' | 'no' | null): Sound {
    this.attributes['dacapo'] = dacapo;
    return this;
  }
  /** Gets @type {SoundAttributes['dalsegno']}. */
  getDalsegno(): string | null {
    return this.attributes['dalsegno'];
  }
  /** Sets @type {SoundAttributes['dalsegno']}. */
  setDalsegno(dalsegno: string | null): Sound {
    this.attributes['dalsegno'] = dalsegno;
    return this;
  }
  /** Gets @type {SoundAttributes['damper-pedal']}. */
  getDamperPedal(): 'no' | 'yes' | 0 | 1 | null {
    return this.attributes['damper-pedal'];
  }
  /** Sets @type {SoundAttributes['damper-pedal']}. */
  setDamperPedal(damperPedal: 'no' | 'yes' | 0 | 1 | null): Sound {
    this.attributes['damper-pedal'] = damperPedal;
    return this;
  }
  /** Gets @type {SoundAttributes['divisions']}. */
  getDivisions(): number | null {
    return this.attributes['divisions'];
  }
  /** Sets @type {SoundAttributes['divisions']}. */
  setDivisions(divisions: number | null): Sound {
    this.attributes['divisions'] = divisions;
    return this;
  }
  /** Gets @type {SoundAttributes['dynamics']}. */
  getDynamics(): number | null {
    return this.attributes['dynamics'];
  }
  /** Sets @type {SoundAttributes['dynamics']}. */
  setDynamics(dynamics: number | null): Sound {
    this.attributes['dynamics'] = dynamics;
    return this;
  }
  /** Gets @type {SoundAttributes['elevation']}. */
  getElevation(): number | null {
    return this.attributes['elevation'];
  }
  /** Sets @type {SoundAttributes['elevation']}. */
  setElevation(elevation: number | null): Sound {
    this.attributes['elevation'] = elevation;
    return this;
  }
  /** Gets @type {SoundAttributes['fine']}. */
  getFine(): string | null {
    return this.attributes['fine'];
  }
  /** Sets @type {SoundAttributes['fine']}. */
  setFine(fine: string | null): Sound {
    this.attributes['fine'] = fine;
    return this;
  }
  /** Gets @type {SoundAttributes['forward-repeat']}. */
  getForwardRepeat(): 'yes' | 'no' | null {
    return this.attributes['forward-repeat'];
  }
  /** Sets @type {SoundAttributes['forward-repeat']}. */
  setForwardRepeat(forwardRepeat: 'yes' | 'no' | null): Sound {
    this.attributes['forward-repeat'] = forwardRepeat;
    return this;
  }
  /** Gets @type {SoundAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {SoundAttributes['id']}. */
  setId(id: string | null): Sound {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {SoundAttributes['pan']}. */
  getPan(): number | null {
    return this.attributes['pan'];
  }
  /** Sets @type {SoundAttributes['pan']}. */
  setPan(pan: number | null): Sound {
    this.attributes['pan'] = pan;
    return this;
  }
  /** Gets @type {SoundAttributes['pizzicato']}. */
  getPizzicato(): 'yes' | 'no' | null {
    return this.attributes['pizzicato'];
  }
  /** Sets @type {SoundAttributes['pizzicato']}. */
  setPizzicato(pizzicato: 'yes' | 'no' | null): Sound {
    this.attributes['pizzicato'] = pizzicato;
    return this;
  }
  /** Gets @type {SoundAttributes['segno']}. */
  getSegno(): string | null {
    return this.attributes['segno'];
  }
  /** Sets @type {SoundAttributes['segno']}. */
  setSegno(segno: string | null): Sound {
    this.attributes['segno'] = segno;
    return this;
  }
  /** Gets @type {SoundAttributes['soft-pedal']}. */
  getSoftPedal(): 'no' | 'yes' | 0 | 1 | null {
    return this.attributes['soft-pedal'];
  }
  /** Sets @type {SoundAttributes['soft-pedal']}. */
  setSoftPedal(softPedal: 'no' | 'yes' | 0 | 1 | null): Sound {
    this.attributes['soft-pedal'] = softPedal;
    return this;
  }
  /** Gets @type {SoundAttributes['sostenuto-pedal']}. */
  getSostenutoPedal(): 'no' | 'yes' | 0 | 1 | null {
    return this.attributes['sostenuto-pedal'];
  }
  /** Sets @type {SoundAttributes['sostenuto-pedal']}. */
  setSostenutoPedal(sostenutoPedal: 'no' | 'yes' | 0 | 1 | null): Sound {
    this.attributes['sostenuto-pedal'] = sostenutoPedal;
    return this;
  }
  /** Gets @type {SoundAttributes['tempo']}. */
  getTempo(): number | null {
    return this.attributes['tempo'];
  }
  /** Sets @type {SoundAttributes['tempo']}. */
  setTempo(tempo: number | null): Sound {
    this.attributes['tempo'] = tempo;
    return this;
  }
  /** Gets @type {SoundAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {SoundAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): Sound {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  /** Gets @type {SoundAttributes['tocoda']}. */
  getTocoda(): string | null {
    return this.attributes['tocoda'];
  }
  /** Sets @type {SoundAttributes['tocoda']}. */
  setTocoda(tocoda: string | null): Sound {
    this.attributes['tocoda'] = tocoda;
    return this;
  }
  /** Gets @type {Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>}. */
  getPlaybacks(): Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]> {
    return this.contents[0];
  }
  /** Sets @type {Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>}. */
  setPlaybacks(
    playbacks: Array<[InstrumentChange | null, MidiDevice | null, MidiInstrument | null, Play | null]>
  ): this {
    this.contents[0] = playbacks;
    return this;
  }
  /** Gets @type {Swing | null}. */
  getSwing(): Swing | null {
    return this.contents[1];
  }
  /** Sets @type {Swing | null}. */
  setSwing(swing: Swing | null): this {
    this.contents[1] = swing;
    return this;
  }
  /** Gets @type {Offset | null}. */
  getOffset(): Offset | null {
    return this.contents[2];
  }
  /** Sets @type {Offset | null}. */
  setOffset(offset: Offset | null): this {
    this.contents[2] = offset;
    return this;
  }
}

export type SyncAttributes = {
  /**
   * Specifies the style that a score following application should use to synchronize an accompaniment with a
   * performer.
   */
  type: 'none' | 'tempo' | 'mostly-tempo' | 'mostly-event' | 'event' | 'always-event';
  /**
   * Specifies a latency time in milliseconds that the listening application should expect from the performer.
   */
  latency: number | null;
  /**
   * Restricts the element to apply to a single `<player>`.
   */
  player: string | null;
  /**
   * Restricts the element to apply to a set of times through a repeated section.
   */
  'time-only': string | null;
};

export type SyncContents = [];

/**
 * The `<sync>` element
 *
 * Parent element: `<listening>`
 *
 * The `<sync>` element specifies the style that a score following application should use the synchronize an
 * accompaniment with a performer. If this element is not included in a score, default synchronization depends on the
 * application.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sync/}
 */
export class Sync implements XMLElement<'sync', SyncAttributes, SyncContents> {
  static readonly schema = {
    name: 'sync',
    attributes: {
      type: {
        type: 'required',
        value: { type: 'choices', choices: ['none', 'tempo', 'mostly-tempo', 'mostly-event', 'event', 'always-event'] },
      },
      latency: { type: 'optional', value: { type: 'int', min: 0, max: Infinity } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [],
  } as const;

  readonly schema = Sync.schema;

  attributes: SyncAttributes;
  contents: SyncContents;

  constructor(opts?: { attributes?: Partial<SyncAttributes>; contents?: SyncContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sync.schema);
    this.contents = opts?.contents ?? operations.zero(Sync.schema.contents);
  }
  /** Gets @type {SyncAttributes['type']}. */
  getType(): 'none' | 'tempo' | 'mostly-tempo' | 'mostly-event' | 'event' | 'always-event' {
    return this.attributes['type'];
  }
  /** Sets @type {SyncAttributes['type']}. */
  setType(type: 'none' | 'tempo' | 'mostly-tempo' | 'mostly-event' | 'event' | 'always-event'): Sync {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {SyncAttributes['latency']}. */
  getLatency(): number | null {
    return this.attributes['latency'];
  }
  /** Sets @type {SyncAttributes['latency']}. */
  setLatency(latency: number | null): Sync {
    this.attributes['latency'] = latency;
    return this;
  }
  /** Gets @type {SyncAttributes['player']}. */
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  /** Sets @type {SyncAttributes['player']}. */
  setPlayer(player: string | null): Sync {
    this.attributes['player'] = player;
    return this;
  }
  /** Gets @type {SyncAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {SyncAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): Sync {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
}

export type OtherListeningAttributes = {
  /**
   * Indicates the type of listening to which the element content applies.
   */
  type: string;
  /**
   * Restricts the element to apply to a single player.
   */
  player: string | null;
  /**
   * Restrict the element to apply to a set of times through a repeated section.
   */
  'time-only': string | null;
};

export type OtherListeningContents = [string];

/**
 * The `<other-listening>` element
 *
 * Parent element: `<listening>`
 *
 * The `<other-listening>` element represents other types of listening control and interaction that change the state of
 * the listening application from the specified point in the performance onward.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/other-listening/}
 */
export class OtherListening implements XMLElement<'other-listening', OtherListeningAttributes, OtherListeningContents> {
  static readonly schema = {
    name: 'other-listening',
    attributes: {
      type: { type: 'required', value: { type: 'string' } },
      player: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'time-only': { type: 'optional', value: { type: 'regex', pattern: /[1-9][0-9]*(, ?[1-9][0-9]*)*/, zero: '1' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = OtherListening.schema;

  attributes: OtherListeningAttributes;
  contents: OtherListeningContents;

  constructor(opts?: { attributes?: Partial<OtherListeningAttributes>; contents?: OtherListeningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OtherListening.schema);
    this.contents = opts?.contents ?? operations.zero(OtherListening.schema.contents);
  }
  /** Gets @type {OtherListeningAttributes['type']}. */
  getType(): string {
    return this.attributes['type'];
  }
  /** Sets @type {OtherListeningAttributes['type']}. */
  setType(type: string): OtherListening {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {OtherListeningAttributes['player']}. */
  getPlayer(): string | null {
    return this.attributes['player'];
  }
  /** Sets @type {OtherListeningAttributes['player']}. */
  setPlayer(player: string | null): OtherListening {
    this.attributes['player'] = player;
    return this;
  }
  /** Gets @type {OtherListeningAttributes['time-only']}. */
  getTimeOnly(): string | null {
    return this.attributes['time-only'];
  }
  /** Sets @type {OtherListeningAttributes['time-only']}. */
  setTimeOnly(timeOnly: string | null): OtherListening {
    this.attributes['time-only'] = timeOnly;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type ListeningAttributes = Record<string, unknown>;

export type ListeningContents = [Array<Sync | OtherListening>, Offset | null];

/**
 * The `<listening>` element
 *
 * Parent elements: `<direction>`, `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<listen>` and `<listening>` elements, new in Version 4.0, specify different ways that a score following or
 * machine listening application can interact with a performer. The `<listening>` element handles interactions that
 * change the state of the listening application from the specified point in the performance onward. If multiple child
 * elements of the same type are present, they should have distinct player and/or time-only attributes.
 *
 * The `<offset>` element is used to indicate that the listening change takes place offset from the current score
 * position. If the `<listening>` element is a child of a `<direction>` element, the listening `<offset>` element
 * overrides the direction `<offset>` element if both elements are present.
 *
 * Note that the `<offset>` reflects the intended musical position for the change in state. It should not be used to
 * compensate for latency issues in particular hardware configurations.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/listening/}
 */
export class Listening implements XMLElement<'listening', ListeningAttributes, ListeningContents> {
  static readonly schema = {
    name: 'listening',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'listening',
        value: { type: 'oneOrMore', value: { type: 'choices', choices: [Sync, OtherListening] } },
      },
      { type: 'optional', value: Offset },
    ],
  } as const;

  readonly schema = Listening.schema;

  attributes: ListeningAttributes;
  contents: ListeningContents;

  constructor(opts?: { attributes?: Partial<ListeningAttributes>; contents?: ListeningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Listening.schema);
    this.contents = opts?.contents ?? operations.zero(Listening.schema.contents);
  }

  /** Gets @type {Array<Sync | OtherListening>}. */
  getListening(): Array<Sync | OtherListening> {
    return this.contents[0];
  }
  /** Sets @type {Array<Sync | OtherListening>}. */
  setListening(listening: Array<Sync | OtherListening>): this {
    this.contents[0] = listening;
    return this;
  }
  /** Gets @type {Offset | null}. */
  getOffset(): Offset | null {
    return this.contents[1];
  }
  /** Sets @type {Offset | null}. */
  setOffset(offset: Offset | null): this {
    this.contents[1] = offset;
    return this;
  }
}

export type DirectionAttributes = {
  /**
   * Changes the default-x position of a direction. It indicates that the left-hand side of the direction is aligned
   * with the left-hand side of the time signature. If no time signature is present, the direction is aligned with the
   * left-hand side of the first music notational element in the measure. If a default-x, justify, or halign attribute
   * is present, it overrides this attribute.
   */
  directive: 'yes' | 'no' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Distinguishes elements that are associated with a system rather than the particular part where the element
   * appears.
   */
  system: 'none' | 'only-top' | 'also-top' | null;
};

export type DirectionContents = [
  Array<DirectionType>,
  Offset | null,
  Footnote | null,
  Level | null,
  Voice | null,
  Staff | null,
  Sound | null,
  Listening | null,
];

/**
 * The `<direction>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * A direction is a musical indication that is not necessarily attached to a specific note. Two or more may be combined
 * to indicate words followed by the start of a dashed line, the end of a wedge followed by dynamics, etc. For
 * applications where a specific direction is indeed attached to a specific note, the `<direction>` element can be
 * associated with the first `<note>` element that follows it in score order that is not in a different voice.
 *
 * By default, a series of `<direction-type>` elements and a series of child elements of a `<direction-type>` within a
 * single `<direction>` element follow one another in sequence visually. For a series of `<direction-type>` children,
 * non-positional formatting attributes are carried over from the previous element by default.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/direction/}
 */
export class Direction implements XMLElement<'direction', DirectionAttributes, DirectionContents> {
  static readonly schema = {
    name: 'direction',
    attributes: {
      directive: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
    },
    contents: [
      { type: 'label', label: 'direction-types', value: { type: 'oneOrMore', value: DirectionType } },
      { type: 'optional', value: Offset },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Voice },
      { type: 'optional', value: Staff },
      { type: 'optional', value: Sound },
      { type: 'optional', value: Listening },
    ],
  } as const;

  readonly schema = Direction.schema;

  attributes: DirectionAttributes;
  contents: DirectionContents;

  constructor(opts?: { attributes?: Partial<DirectionAttributes>; contents?: DirectionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Direction.schema);
    this.contents = opts?.contents ?? operations.zero(Direction.schema.contents);
  }
  /** Gets @type {DirectionAttributes['directive']}. */
  getDirective(): 'yes' | 'no' | null {
    return this.attributes['directive'];
  }
  /** Sets @type {DirectionAttributes['directive']}. */
  setDirective(directive: 'yes' | 'no' | null): Direction {
    this.attributes['directive'] = directive;
    return this;
  }
  /** Gets @type {DirectionAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {DirectionAttributes['id']}. */
  setId(id: string | null): Direction {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {DirectionAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {DirectionAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Direction {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {DirectionAttributes['system']}. */
  getSystem(): 'none' | 'only-top' | 'also-top' | null {
    return this.attributes['system'];
  }
  /** Sets @type {DirectionAttributes['system']}. */
  setSystem(system: 'none' | 'only-top' | 'also-top' | null): Direction {
    this.attributes['system'] = system;
    return this;
  }
  /** Gets @type {Array<DirectionType>}. */
  getDirectionTypes(): Array<DirectionType> {
    return this.contents[0];
  }
  /** Sets @type {Array<DirectionType>}. */
  setDirectionTypes(directionTypes: Array<DirectionType>): this {
    this.contents[0] = directionTypes;
    return this;
  }
  /** Gets @type {Offset | null}. */
  getOffset(): Offset | null {
    return this.contents[1];
  }
  /** Sets @type {Offset | null}. */
  setOffset(offset: Offset | null): this {
    this.contents[1] = offset;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[2];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[2] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[3];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[3] = level;
    return this;
  }
  /** Gets @type {Voice | null}. */
  getVoice(): Voice | null {
    return this.contents[4];
  }
  /** Sets @type {Voice | null}. */
  setVoice(voice: Voice | null): this {
    this.contents[4] = voice;
    return this;
  }
  /** Gets @type {Staff | null}. */
  getStaff(): Staff | null {
    return this.contents[5];
  }
  /** Sets @type {Staff | null}. */
  setStaff(staff: Staff | null): this {
    this.contents[5] = staff;
    return this;
  }
  /** Gets @type {Sound | null}. */
  getSound(): Sound | null {
    return this.contents[6];
  }
  /** Sets @type {Sound | null}. */
  setSound(sound: Sound | null): this {
    this.contents[6] = sound;
    return this;
  }
  /** Gets @type {Listening | null}. */
  getListening(): Listening | null {
    return this.contents[7];
  }
  /** Sets @type {Listening | null}. */
  setListening(listening: Listening | null): this {
    this.contents[7] = listening;
    return this;
  }
}

export type DivisionsAttributes = Record<string, unknown>;

export type DivisionsContents = [number];

/**
 * The `<divisions>` element
 *
 * Parent element: `<attributes>`
 *
 * Musical notation duration is commonly represented as fractions. The `<divisions>` element indicates how many
 * divisions per quarter note are used to indicate a note's duration. For example, if duration = 1 and divisions = 2,
 * this is an eighth note duration. Duration and divisions are used directly for generating sound output, so they must
 * be chosen to take tuplets into account.
 *
 * Using a `<divisions>` element lets us use just one number to represent a duration for each note in the score, while
 * retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is
 * important, do not have the divisions value exceed 16383.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/divisions/}
 */
export class Divisions implements XMLElement<'divisions', DivisionsAttributes, DivisionsContents> {
  static readonly schema = {
    name: 'divisions',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'positive-divisions', value: { type: 'float', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Divisions.schema;

  attributes: DivisionsAttributes;
  contents: DivisionsContents;

  constructor(opts?: { attributes?: Partial<DivisionsAttributes>; contents?: DivisionsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Divisions.schema);
    this.contents = opts?.contents ?? operations.zero(Divisions.schema.contents);
  }

  /** Gets @type {number}. */
  getPositiveDivisions(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setPositiveDivisions(positiveDivisions: number): this {
    this.contents[0] = positiveDivisions;
    return this;
  }
}

export type CancelAttributes = {
  /**
   * Indicates where the cancellation appears relative to the new key signature. It is left if not specified.
   */
  location: 'left' | 'right' | 'beforeBarline' | null;
};

export type CancelContents = [number];

/**
 * The `<cancel>` element
 *
 * Parent element: `<key>`
 *
 * The `<cancel>` element indicates that the old key signature should be cancelled before the new one appears. This will
 * always happen when changing to C major or A minor and need not be specified then. The `<cancel>` element value
 * matches the fifths value of the cancelled key signature (e.g., a cancel of -2 will provide an explicit cancellation
 * for changing from B flat major to F major).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/cancel/}
 */
export class Cancel implements XMLElement<'cancel', CancelAttributes, CancelContents> {
  static readonly schema = {
    name: 'cancel',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right', 'beforeBarline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'fifths',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Cancel.schema;

  attributes: CancelAttributes;
  contents: CancelContents;

  constructor(opts?: { attributes?: Partial<CancelAttributes>; contents?: CancelContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Cancel.schema);
    this.contents = opts?.contents ?? operations.zero(Cancel.schema.contents);
  }
  /** Gets @type {CancelAttributes['location']}. */
  getLocation(): 'left' | 'right' | 'beforeBarline' | null {
    return this.attributes['location'];
  }
  /** Sets @type {CancelAttributes['location']}. */
  setLocation(location: 'left' | 'right' | 'beforeBarline' | null): Cancel {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {number}. */
  getFifths(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setFifths(fifths: number): this {
    this.contents[0] = fifths;
    return this;
  }
}

export type FifthsAttributes = Record<string, unknown>;

export type FifthsContents = [number | null];

/**
 * The `<fifths>` element
 *
 * Parent element: `<key>`
 *
 * The `<fifths>` element represents the number of flats or sharps in a traditional key signature. Negative numbers are
 * used for flats and positive numbers for sharps, reflecting the key's placement within the circle of fifths (hence the
 * element name).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/fifths/}
 */
export class Fifths implements XMLElement<'fifths', FifthsAttributes, FifthsContents> {
  static readonly schema = {
    name: 'fifths',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'optional', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Fifths.schema;

  attributes: FifthsAttributes;
  contents: FifthsContents;

  constructor(opts?: { attributes?: Partial<FifthsAttributes>; contents?: FifthsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Fifths.schema);
    this.contents = opts?.contents ?? operations.zero(Fifths.schema.contents);
  }

  /** Gets @type {number | null}. */
  getValue(): number | null {
    return this.contents[0];
  }
  /** Sets @type {number | null}. */
  setValue(value: number | null): this {
    this.contents[0] = value;
    return this;
  }
}

export type ModeAttributes = Record<string, unknown>;

export type ModeContents = [
  | 'none'
  | 'major'
  | 'minor'
  | 'dorian'
  | 'phrygian'
  | 'lydian'
  | 'mixolydian'
  | 'aeolian'
  | 'ionian'
  | 'locrian'
  | string,
];

/**
 * The `<mode>` element
 *
 * Parent element: `<key>`
 *
 * The `<mode>` element is used to specify major/minor and other mode distinctions. Valid mode values include major,
 * minor, dorian, phrygian, lydian, mixolydian, aeolian, ionian, locrian, and none.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/mode/}
 */
export class Mode implements XMLElement<'mode', ModeAttributes, ModeContents> {
  static readonly schema = {
    name: 'mode',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'mode',
          value: {
            type: 'choices',
            choices: [
              'none',
              'major',
              'minor',
              'dorian',
              'phrygian',
              'lydian',
              'mixolydian',
              'aeolian',
              'ionian',
              'locrian',
              { type: 'string' },
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Mode.schema;

  attributes: ModeAttributes;
  contents: ModeContents;

  constructor(opts?: { attributes?: Partial<ModeAttributes>; contents?: ModeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Mode.schema);
    this.contents = opts?.contents ?? operations.zero(Mode.schema.contents);
  }

  /** Gets @type {'none' | 'major' | 'minor' | 'dorian' | 'phrygian' | 'lydian' | 'mixolydian' | 'aeolian' | 'ionian' | 'locrian' | string}. */
  getMode():
    | 'none'
    | 'major'
    | 'minor'
    | 'dorian'
    | 'phrygian'
    | 'lydian'
    | 'mixolydian'
    | 'aeolian'
    | 'ionian'
    | 'locrian'
    | string {
    return this.contents[0];
  }
  /** Sets @type {'none' | 'major' | 'minor' | 'dorian' | 'phrygian' | 'lydian' | 'mixolydian' | 'aeolian' | 'ionian' | 'locrian' | string}. */
  setMode(
    mode:
      | 'none'
      | 'major'
      | 'minor'
      | 'dorian'
      | 'phrygian'
      | 'lydian'
      | 'mixolydian'
      | 'aeolian'
      | 'ionian'
      | 'locrian'
      | string
  ): this {
    this.contents[0] = mode;
    return this;
  }
}

export type KeyStepAttributes = Record<string, unknown>;

export type KeyStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

/**
 * The `<key>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<key>` element represents a key signature. Both traditional and non-traditional key signatures are supported.
 * Key signatures appear at the start of each system unless the print-object attribute has been set to "no".
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key/}
 */
export class KeyStep implements XMLElement<'key-step', KeyStepAttributes, KeyStepContents> {
  static readonly schema = {
    name: 'key-step',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = KeyStep.schema;

  attributes: KeyStepAttributes;
  contents: KeyStepContents;

  constructor(opts?: { attributes?: Partial<KeyStepAttributes>; contents?: KeyStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyStep.schema);
    this.contents = opts?.contents ?? operations.zero(KeyStep.schema.contents);
  }

  /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): this {
    this.contents[0] = step;
    return this;
  }
}

export type KeyAlterAttributes = Record<string, unknown>;

export type KeyAlterContents = [number];

/**
 * The `<key-alter>` element
 *
 * Parent element: `<key>`
 *
 * Non-traditional key signatures are represented using a list of altered tones. The `<key-alter>` element represents
 * the alteration for a given pitch step, represented with semitones in the same manner as the `<alter>` element. The
 * different element names indicate the different meaning of altering notes in a scale versus altering a sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key-alter/}
 */
export class KeyAlter implements XMLElement<'key-alter', KeyAlterAttributes, KeyAlterContents> {
  static readonly schema = {
    name: 'key-alter',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = KeyAlter.schema;

  attributes: KeyAlterAttributes;
  contents: KeyAlterContents;

  constructor(opts?: { attributes?: Partial<KeyAlterAttributes>; contents?: KeyAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyAlter.schema);
    this.contents = opts?.contents ?? operations.zero(KeyAlter.schema.contents);
  }

  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type KeyAccidentalAttributes = {
  /**
   * Specifies a Standard Music Font Layout (SMuFL) accidental character by its canonical glyph name.
   */
  smufl: string | null;
};

export type KeyAccidentalContents = [
  | 'other'
  | 'sharp'
  | 'natural'
  | 'flat'
  | 'double-sharp'
  | 'sharp-sharp'
  | 'flat-flat'
  | 'natural-sharp'
  | 'natural-flat'
  | 'quarter-flat'
  | 'quarter-sharp'
  | 'three-quarters-flat'
  | 'three-quarters-sharp'
  | 'sharp-down'
  | 'sharp-up'
  | 'natural-down'
  | 'natural-up'
  | 'flat-down'
  | 'flat-up'
  | 'double-sharp-down'
  | 'double-sharp-up'
  | 'flat-flat-down'
  | 'flat-flat-up'
  | 'arrow-down'
  | 'arrow-up'
  | 'triple-sharp'
  | 'triple-flat'
  | 'slash-quarter-sharp'
  | 'slash-sharp'
  | 'slash-flat'
  | 'double-slash-flat'
  | 'sharp-1'
  | 'sharp-2'
  | 'sharp-3'
  | 'sharp-5'
  | 'flat-1'
  | 'flat-2'
  | 'flat-3'
  | 'flat-4'
  | 'sori'
  | 'koron',
];

/**
 * The `<key-accidental>` element
 *
 * Parent element: `<key>`
 *
 * Non-traditional key signatures are represented using a list of altered tones. The `<key-accidental>` element
 * indicates the accidental to be displayed in the key signature, represented in the same manner as the `<accidental>`
 * element. It is used for disambiguating microtonal accidentals. The different element names indicate the different
 * meaning of altering notes in a scale versus altering a sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key-accidental/}
 */
export class KeyAccidental implements XMLElement<'key-accidental', KeyAccidentalAttributes, KeyAccidentalContents> {
  static readonly schema = {
    name: 'key-accidental',
    attributes: {
      smufl: {
        type: 'optional',
        value: { type: 'regex', pattern: /(acc|medRenFla|medRenNatura|medRenShar|kievanAccidental)/, zero: 'acc' },
      },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'accidental-value',
          value: {
            type: 'choices',
            choices: [
              'other',
              'sharp',
              'natural',
              'flat',
              'double-sharp',
              'sharp-sharp',
              'flat-flat',
              'natural-sharp',
              'natural-flat',
              'quarter-flat',
              'quarter-sharp',
              'three-quarters-flat',
              'three-quarters-sharp',
              'sharp-down',
              'sharp-up',
              'natural-down',
              'natural-up',
              'flat-down',
              'flat-up',
              'double-sharp-down',
              'double-sharp-up',
              'flat-flat-down',
              'flat-flat-up',
              'arrow-down',
              'arrow-up',
              'triple-sharp',
              'triple-flat',
              'slash-quarter-sharp',
              'slash-sharp',
              'slash-flat',
              'double-slash-flat',
              'sharp-1',
              'sharp-2',
              'sharp-3',
              'sharp-5',
              'flat-1',
              'flat-2',
              'flat-3',
              'flat-4',
              'sori',
              'koron',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = KeyAccidental.schema;

  attributes: KeyAccidentalAttributes;
  contents: KeyAccidentalContents;

  constructor(opts?: { attributes?: Partial<KeyAccidentalAttributes>; contents?: KeyAccidentalContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyAccidental.schema);
    this.contents = opts?.contents ?? operations.zero(KeyAccidental.schema.contents);
  }
  /** Gets @type {KeyAccidentalAttributes['smufl']}. */
  getSmufl(): string | null {
    return this.attributes['smufl'];
  }
  /** Sets @type {KeyAccidentalAttributes['smufl']}. */
  setSmufl(smufl: string | null): KeyAccidental {
    this.attributes['smufl'] = smufl;
    return this;
  }
  /** Gets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  getAccidentalValue():
    | 'other'
    | 'sharp'
    | 'natural'
    | 'flat'
    | 'double-sharp'
    | 'sharp-sharp'
    | 'flat-flat'
    | 'natural-sharp'
    | 'natural-flat'
    | 'quarter-flat'
    | 'quarter-sharp'
    | 'three-quarters-flat'
    | 'three-quarters-sharp'
    | 'sharp-down'
    | 'sharp-up'
    | 'natural-down'
    | 'natural-up'
    | 'flat-down'
    | 'flat-up'
    | 'double-sharp-down'
    | 'double-sharp-up'
    | 'flat-flat-down'
    | 'flat-flat-up'
    | 'arrow-down'
    | 'arrow-up'
    | 'triple-sharp'
    | 'triple-flat'
    | 'slash-quarter-sharp'
    | 'slash-sharp'
    | 'slash-flat'
    | 'double-slash-flat'
    | 'sharp-1'
    | 'sharp-2'
    | 'sharp-3'
    | 'sharp-5'
    | 'flat-1'
    | 'flat-2'
    | 'flat-3'
    | 'flat-4'
    | 'sori'
    | 'koron' {
    return this.contents[0];
  }
  /** Sets @type {'other' | 'sharp' | 'natural' | 'flat' | 'double-sharp' | 'sharp-sharp' | 'flat-flat' | 'natural-sharp' | 'natural-flat' | 'quarter-flat' | 'quarter-sharp' | 'three-quarters-flat' | 'three-quarters-sharp' | 'sharp-down' | 'sharp-up' | 'natural-down' | 'natural-up' | 'flat-down' | 'flat-up' | 'double-sharp-down' | 'double-sharp-up' | 'flat-flat-down' | 'flat-flat-up' | 'arrow-down' | 'arrow-up' | 'triple-sharp' | 'triple-flat' | 'slash-quarter-sharp' | 'slash-sharp' | 'slash-flat' | 'double-slash-flat' | 'sharp-1' | 'sharp-2' | 'sharp-3' | 'sharp-5' | 'flat-1' | 'flat-2' | 'flat-3' | 'flat-4' | 'sori' | 'koron'}. */
  setAccidentalValue(
    accidentalValue:
      | 'other'
      | 'sharp'
      | 'natural'
      | 'flat'
      | 'double-sharp'
      | 'sharp-sharp'
      | 'flat-flat'
      | 'natural-sharp'
      | 'natural-flat'
      | 'quarter-flat'
      | 'quarter-sharp'
      | 'three-quarters-flat'
      | 'three-quarters-sharp'
      | 'sharp-down'
      | 'sharp-up'
      | 'natural-down'
      | 'natural-up'
      | 'flat-down'
      | 'flat-up'
      | 'double-sharp-down'
      | 'double-sharp-up'
      | 'flat-flat-down'
      | 'flat-flat-up'
      | 'arrow-down'
      | 'arrow-up'
      | 'triple-sharp'
      | 'triple-flat'
      | 'slash-quarter-sharp'
      | 'slash-sharp'
      | 'slash-flat'
      | 'double-slash-flat'
      | 'sharp-1'
      | 'sharp-2'
      | 'sharp-3'
      | 'sharp-5'
      | 'flat-1'
      | 'flat-2'
      | 'flat-3'
      | 'flat-4'
      | 'sori'
      | 'koron'
  ): this {
    this.contents[0] = accidentalValue;
    return this;
  }
}

export type KeyOctaveAttributes = {
  /**
   * A positive integer that refers to the key signature element in left-to-right order.
   */
  number: number;
  /**
   * If set to yes, then the number refers to the canceling key signature specified by the `<cancel>` element in the
   * parent `<key>` element. It cannot be set to yes if there is no corresponding `<cancel>` element within the
   * parent `<key>` element. It is no if absent.
   */
  cancel: 'yes' | 'no' | null;
};

export type KeyOctaveContents = [number];

/**
 * The `<key-octave>` element
 *
 * Parent element: `<key>`
 *
 * The `<key-octave>` element specifies in which octave an element of a key signature appears. The content specifies the
 * octave value using the same values as the `<display-octave>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key-octave/}
 */
export class KeyOctave implements XMLElement<'key-octave', KeyOctaveAttributes, KeyOctaveContents> {
  static readonly schema = {
    name: 'key-octave',
    attributes: {
      number: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      cancel: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [{ type: 'required', value: { type: 'label', label: 'octave', value: { type: 'int', min: 0, max: 9 } } }],
  } as const;

  readonly schema = KeyOctave.schema;

  attributes: KeyOctaveAttributes;
  contents: KeyOctaveContents;

  constructor(opts?: { attributes?: Partial<KeyOctaveAttributes>; contents?: KeyOctaveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, KeyOctave.schema);
    this.contents = opts?.contents ?? operations.zero(KeyOctave.schema.contents);
  }
  /** Gets @type {KeyOctaveAttributes['number']}. */
  getNumber(): number {
    return this.attributes['number'];
  }
  /** Sets @type {KeyOctaveAttributes['number']}. */
  setNumber(number: number): KeyOctave {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {KeyOctaveAttributes['cancel']}. */
  getCancel(): 'yes' | 'no' | null {
    return this.attributes['cancel'];
  }
  /** Sets @type {KeyOctaveAttributes['cancel']}. */
  setCancel(cancel: 'yes' | 'no' | null): KeyOctave {
    this.attributes['cancel'] = cancel;
    return this;
  }
  /** Gets @type {number}. */
  getOctave(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setOctave(octave: number): this {
    this.contents[0] = octave;
    return this;
  }
}

export type TranditionalKey = [Cancel | null, Fifths, Mode | null];

export type AlternateKey = Array<[KeyStep, KeyAlter, KeyAccidental | null]>;

export type KeyAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Allows a key signature to apply to only the specified staff in the part. If absent, the key signature applies
   * to all staves in the part.
   */
  number: number | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type KeyContents = [TranditionalKey | AlternateKey, Array<KeyOctave>];

/**
 * The `<key>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<key>` element represents a key signature. Both traditional and non-traditional key signatures are supported.
 * Key signatures appear at the start of each system unless the print-object attribute has been set to "no".
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/key/}
 */
export class Key implements XMLElement<'key', KeyAttributes, KeyContents> {
  static readonly schema = {
    name: 'key',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'tranditional-key',
              value: [
                { type: 'optional', value: Cancel },
                { type: 'required', value: Fifths },
                { type: 'optional', value: Mode },
              ],
            },
            {
              type: 'label',
              label: 'alternate-key',
              value: {
                type: 'zeroOrMore',
                value: [
                  { type: 'required', value: KeyStep },
                  { type: 'required', value: KeyAlter },
                  { type: 'optional', value: KeyAccidental },
                ],
              },
            },
          ],
        },
      },
      { type: 'label', label: 'key-octaves', value: { type: 'zeroOrMore', value: KeyOctave } },
    ],
  } as const;

  readonly schema = Key.schema;

  attributes: KeyAttributes;
  contents: KeyContents;

  constructor(opts?: { attributes?: Partial<KeyAttributes>; contents?: KeyContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Key.schema);
    this.contents = opts?.contents ?? operations.zero(Key.schema.contents);
  }
  /** Gets @type {KeyAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {KeyAttributes['color']}. */
  setColor(color: string | null): Key {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {KeyAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {KeyAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Key {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {KeyAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {KeyAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Key {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {KeyAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {KeyAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Key {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {KeyAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {KeyAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Key {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {KeyAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {KeyAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Key {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {KeyAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {KeyAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Key {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {KeyAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {KeyAttributes['id']}. */
  setId(id: string | null): Key {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {KeyAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {KeyAttributes['number']}. */
  setNumber(number: number | null): Key {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {KeyAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {KeyAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Key {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {KeyAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {KeyAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Key {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {KeyAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {KeyAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Key {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {TranditionalKey | AlternateKey}. */
  getValue(): TranditionalKey | AlternateKey {
    return this.contents[0];
  }
  /** Sets @type {TranditionalKey | AlternateKey}. */
  setValue(value: TranditionalKey | AlternateKey): this {
    this.contents[0] = value;
    return this;
  }
  /** Gets @type {Array<KeyOctave>}. */
  getKeyOctaves(): Array<KeyOctave> {
    return this.contents[1];
  }
  /** Sets @type {Array<KeyOctave>}. */
  setKeyOctaves(keyOctaves: Array<KeyOctave>): this {
    this.contents[1] = keyOctaves;
    return this;
  }
}

export type BeatsAttributes = Record<string, unknown>;

export type BeatsContents = [string];

/**
 * The `<beats>` element
 *
 * Parent elements: `<interchangeable>`, `<time>`
 *
 * The `<beats>` element indicates the number of beats, as found in the numerator of a time signature.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beats/}
 */
export class Beats implements XMLElement<'beats', BeatsAttributes, BeatsContents> {
  static readonly schema = {
    name: 'beats',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Beats.schema;

  attributes: BeatsAttributes;
  contents: BeatsContents;

  constructor(opts?: { attributes?: Partial<BeatsAttributes>; contents?: BeatsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Beats.schema);
    this.contents = opts?.contents ?? operations.zero(Beats.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type BeatTypeAttributes = Record<string, unknown>;

export type BeatTypeContents = [string];

/**
 * The `<beat-type>` element
 *
 * Parent elements: `<interchangeable>`, `<time>`
 *
 * The `<beat-type>` element indicates the beat unit, as found in the denominator of a time signature.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-type/}
 */
export class BeatType implements XMLElement<'beat-type', BeatTypeAttributes, BeatTypeContents> {
  static readonly schema = {
    name: 'beat-type',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = BeatType.schema;

  attributes: BeatTypeAttributes;
  contents: BeatTypeContents;

  constructor(opts?: { attributes?: Partial<BeatTypeAttributes>; contents?: BeatTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatType.schema);
    this.contents = opts?.contents ?? operations.zero(BeatType.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type TimeRelationAttributes = Record<string, unknown>;

export type TimeRelationContents = ['space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'];

/**
 * The `<time-relation>` element
 *
 * Parent element: `<interchangeable>`
 *
 * The `<time-relation>` element indicates the symbol used to represent the interchangeable aspect of dual time
 * signatures, as specified in the time-relation type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/time-relation/}
 */
export class TimeRelation implements XMLElement<'time-relation', TimeRelationAttributes, TimeRelationContents> {
  static readonly schema = {
    name: 'time-relation',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'time-relation',
          value: { type: 'choices', choices: ['space', 'bracket', 'equals', 'hyphen', 'parentheses', 'slash'] },
        },
      },
    ],
  } as const;

  readonly schema = TimeRelation.schema;

  attributes: TimeRelationAttributes;
  contents: TimeRelationContents;

  constructor(opts?: { attributes?: Partial<TimeRelationAttributes>; contents?: TimeRelationContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, TimeRelation.schema);
    this.contents = opts?.contents ?? operations.zero(TimeRelation.schema.contents);
  }

  /** Gets @type {'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'}. */
  getTimeRelation(): 'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash' {
    return this.contents[0];
  }
  /** Sets @type {'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'}. */
  setTimeRelation(timeRelation: 'space' | 'bracket' | 'equals' | 'hyphen' | 'parentheses' | 'slash'): this {
    this.contents[0] = timeRelation;
    return this;
  }
}

export type InterchangeableAttributes = {
  /**
   * Indicates how to display the arrangement between the `<beats>` and `<beat-type>` values in the second of the dual
   * time signatures.
   */
  separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null;
  /**
   * Indicates how to display the second of the dual time signatures, such as by using common and cut time symbols
   * or a single number display.
   */
  symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null;
};

export type InterchangeableContents = [TimeRelation | null, Array<[Beats, BeatType]>];

/**
 * The `<interchangeable>` element
 *
 * Parent element: `<time>`
 *
 * The `<interchangeable>` element is used to represent the second in a pair of interchangeable dual time signatures,
 * such as the 6/8 in 3/4 (6/8).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/interchangeable/}
 */
export class Interchangeable
  implements XMLElement<'interchangeable', InterchangeableAttributes, InterchangeableContents>
{
  static readonly schema = {
    name: 'interchangeable',
    attributes: {
      separator: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'adjacent', 'diagonal', 'horizontal', 'vertical'] },
      },
      symbol: {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', 'common', 'cut', 'dotted-note', 'note', 'single-number'] },
      },
    },
    contents: [
      { type: 'optional', value: TimeRelation },
      {
        type: 'label',
        label: 'beats',
        value: {
          type: 'oneOrMore',
          value: [
            { type: 'required', value: Beats },
            { type: 'required', value: BeatType },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Interchangeable.schema;

  attributes: InterchangeableAttributes;
  contents: InterchangeableContents;

  constructor(opts?: { attributes?: Partial<InterchangeableAttributes>; contents?: InterchangeableContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Interchangeable.schema);
    this.contents = opts?.contents ?? operations.zero(Interchangeable.schema.contents);
  }
  /** Gets @type {InterchangeableAttributes['separator']}. */
  getSeparator(): 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null {
    return this.attributes['separator'];
  }
  /** Sets @type {InterchangeableAttributes['separator']}. */
  setSeparator(separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null): Interchangeable {
    this.attributes['separator'] = separator;
    return this;
  }
  /** Gets @type {InterchangeableAttributes['symbol']}. */
  getSymbol(): 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null {
    return this.attributes['symbol'];
  }
  /** Sets @type {InterchangeableAttributes['symbol']}. */
  setSymbol(symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null): Interchangeable {
    this.attributes['symbol'] = symbol;
    return this;
  }
  /** Gets @type {TimeRelation | null}. */
  getTimeRelation(): TimeRelation | null {
    return this.contents[0];
  }
  /** Sets @type {TimeRelation | null}. */
  setTimeRelation(timeRelation: TimeRelation | null): this {
    this.contents[0] = timeRelation;
    return this;
  }
  /** Gets @type {Array<[Beats, BeatType]>}. */
  getBeats(): Array<[Beats, BeatType]> {
    return this.contents[1];
  }
  /** Sets @type {Array<[Beats, BeatType]>}. */
  setBeats(beats: Array<[Beats, BeatType]>): this {
    this.contents[1] = beats;
    return this;
  }
}

export type SenzaMisuraAttributes = Record<string, unknown>;

export type SenzaMisuraContents = [string];

/**
 * The `<senza-misura>` element
 *
 * Parent element: `<time>`
 *
 * A `<senza-misura>` element explicitly indicates that no time signature is present. The optional element content
 * indicates the symbol to be used, if any, such as an X. The `<time>` element's symbol attribute is not used when a
 * `<senza-misura>` element is present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/senza-misura/}
 */
export class SenzaMisura implements XMLElement<'senza-misura', SenzaMisuraAttributes, SenzaMisuraContents> {
  static readonly schema = {
    name: 'senza-misura',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = SenzaMisura.schema;

  attributes: SenzaMisuraAttributes;
  contents: SenzaMisuraContents;

  constructor(opts?: { attributes?: Partial<SenzaMisuraAttributes>; contents?: SenzaMisuraContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SenzaMisura.schema);
    this.contents = opts?.contents ?? operations.zero(SenzaMisura.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type TimeSignature = [Array<[Beats, BeatType]>, Interchangeable | null];

export type TimeAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Allows a time signature to apply to only the specified staff in the part. If absent, the time signature applies
   * to all staves in the part.
   */
  number: number | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual program,
   * or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be interpreted
   * in the context of the `<offset>` element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the vertical position relative to the default position, either as computed by the individual program, or
   * as overridden by the default-y attribute. Positive y is up and negative y is down. It should be interpreted in
   * the context of the placement attribute if that is present.
   */
  'relative-y': number | null;
  /**
   * Indicates how to display the arrangement between the `<beats>` and `<beat-type>` values in a time signature.
   */
  separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null;
  /**
   * Indicates how to display a time signature, such as by using common and cut time symbols or a single number
   * display.
   */
  symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type TimeContents = [TimeSignature | SenzaMisura];

/**
 * The `<time>` element
 *
 * Parent element: `<attributes>`
 *
 * Time signatures are represented by the `<beats>` element for the numerator and the `<beat-type>` element for the
 * denominator. Multiple pairs of `<beat>` and `<beat-type>` elements are used for composite time signatures with
 * multiple denominators, such as 2/4 + 3/8. A composite such as 3+2/8 requires only one `<beat>`/`<beat-type>` pair.
 *
 * The print-object attribute allows a time signature to be specified but not printed, as is the case for excerpts from
 * the middle of a score. The value is "yes" if not present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/time/}
 */
export class Time implements XMLElement<'time', TimeAttributes, TimeContents> {
  static readonly schema = {
    name: 'time',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'relative-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      separator: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'adjacent', 'diagonal', 'horizontal', 'vertical'] },
      },
      symbol: {
        type: 'optional',
        value: { type: 'choices', choices: ['normal', 'common', 'cut', 'dotted-note', 'note', 'single-number'] },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'choices',
          choices: [
            {
              type: 'label',
              label: 'time-signature',
              value: [
                {
                  type: 'oneOrMore',
                  value: [
                    { type: 'required', value: Beats },
                    { type: 'required', value: BeatType },
                  ],
                },
                { type: 'optional', value: Interchangeable },
              ],
            },
            SenzaMisura,
          ],
        },
      },
    ],
  } as const;

  readonly schema = Time.schema;

  attributes: TimeAttributes;
  contents: TimeContents;

  constructor(opts?: { attributes?: Partial<TimeAttributes>; contents?: TimeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Time.schema);
    this.contents = opts?.contents ?? operations.zero(Time.schema.contents);
  }
  /** Gets @type {TimeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {TimeAttributes['color']}. */
  setColor(color: string | null): Time {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {TimeAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {TimeAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Time {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {TimeAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {TimeAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Time {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {TimeAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {TimeAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Time {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {TimeAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {TimeAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Time {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {TimeAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {TimeAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Time {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {TimeAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {TimeAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Time {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {TimeAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {TimeAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Time {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {TimeAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {TimeAttributes['id']}. */
  setId(id: string | null): Time {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {TimeAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {TimeAttributes['number']}. */
  setNumber(number: number | null): Time {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {TimeAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {TimeAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Time {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {TimeAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {TimeAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Time {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {TimeAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {TimeAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Time {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {TimeAttributes['separator']}. */
  getSeparator(): 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null {
    return this.attributes['separator'];
  }
  /** Sets @type {TimeAttributes['separator']}. */
  setSeparator(separator: 'none' | 'adjacent' | 'diagonal' | 'horizontal' | 'vertical' | null): Time {
    this.attributes['separator'] = separator;
    return this;
  }
  /** Gets @type {TimeAttributes['symbol']}. */
  getSymbol(): 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null {
    return this.attributes['symbol'];
  }
  /** Sets @type {TimeAttributes['symbol']}. */
  setSymbol(symbol: 'normal' | 'common' | 'cut' | 'dotted-note' | 'note' | 'single-number' | null): Time {
    this.attributes['symbol'] = symbol;
    return this;
  }
  /** Gets @type {TimeAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {TimeAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Time {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {TimeSignature | SenzaMisura}. */
  getValue(): TimeSignature | SenzaMisura {
    return this.contents[0];
  }
  /** Sets @type {TimeSignature | SenzaMisura}. */
  setValue(value: TimeSignature | SenzaMisura): this {
    this.contents[0] = value;
    return this;
  }
}

export type StavesAttributes = Record<string, unknown>;

export type StavesContents = [number];

/**
 * The `<staves>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<staves>` element is used if there is more than one staff represented in the given part (e.g., 2 staves for
 * typical piano parts). If absent, a value of 1 is assumed. Staves are ordered from top to bottom in a part in
 * numerical order, with staff 1 above staff 2.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staves/}
 */
export class Staves implements XMLElement<'staves', StavesAttributes, StavesContents> {
  static readonly schema = {
    name: 'staves',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Staves.schema;

  attributes: StavesAttributes;
  contents: StavesContents;

  constructor(opts?: { attributes?: Partial<StavesAttributes>; contents?: StavesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Staves.schema);
    this.contents = opts?.contents ?? operations.zero(Staves.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type PartSymbolAttributes = {
  /**
   * Specifies the bottom staff of the symbol when it does not extend across the entire part.
   */
  'bottom-staff': number | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Specifies the top staff of the symbol when it does not extend across the entire part.
   */
  'top-staff': number | null;
};

export type PartSymbolContents = ['none' | 'brace' | 'bracket' | 'line' | 'square'];

/**
 * The `<part-symbol>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<part-symbol>` element indicates how a symbol for a multi-staff part is indicated in the score; brace is the
 * default value.
 *
 * The top-staff and bottom-staff attributes are used when the brace does not extend across the entire part. For
 * example, in a 3-staff organ part, the top-staff will typically be 1 for the right hand, while the bottom-staff will
 * typically be 2 for the left hand. Staff 3 for the pedals is usually outside the brace. By default, the presence of a
 * `<part-symbol>` element that does not extend across the entire part also indicates a corresponding change in the
 * common barlines within a part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-symbol/}
 */
export class PartSymbol implements XMLElement<'part-symbol', PartSymbolAttributes, PartSymbolContents> {
  static readonly schema = {
    name: 'part-symbol',
    attributes: {
      'bottom-staff': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'top-staff': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'group-symbol-value',
          value: { type: 'choices', choices: ['none', 'brace', 'bracket', 'line', 'square'] },
        },
      },
    ],
  } as const;

  readonly schema = PartSymbol.schema;

  attributes: PartSymbolAttributes;
  contents: PartSymbolContents;

  constructor(opts?: { attributes?: Partial<PartSymbolAttributes>; contents?: PartSymbolContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartSymbol.schema);
    this.contents = opts?.contents ?? operations.zero(PartSymbol.schema.contents);
  }
  /** Gets @type {PartSymbolAttributes['bottom-staff']}. */
  getBottomStaff(): number | null {
    return this.attributes['bottom-staff'];
  }
  /** Sets @type {PartSymbolAttributes['bottom-staff']}. */
  setBottomStaff(bottomStaff: number | null): PartSymbol {
    this.attributes['bottom-staff'] = bottomStaff;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PartSymbolAttributes['color']}. */
  setColor(color: string | null): PartSymbol {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PartSymbolAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): PartSymbol {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PartSymbolAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): PartSymbol {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PartSymbolAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): PartSymbol {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PartSymbolAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): PartSymbol {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PartSymbolAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): PartSymbol {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PartSymbolAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): PartSymbol {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PartSymbolAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): PartSymbol {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PartSymbolAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): PartSymbol {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {PartSymbolAttributes['top-staff']}. */
  getTopStaff(): number | null {
    return this.attributes['top-staff'];
  }
  /** Sets @type {PartSymbolAttributes['top-staff']}. */
  setTopStaff(topStaff: number | null): PartSymbol {
    this.attributes['top-staff'] = topStaff;
    return this;
  }
  /** Gets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
  getGroupSymbolValue(): 'none' | 'brace' | 'bracket' | 'line' | 'square' {
    return this.contents[0];
  }
  /** Sets @type {'none' | 'brace' | 'bracket' | 'line' | 'square'}. */
  setGroupSymbolValue(groupSymbolValue: 'none' | 'brace' | 'bracket' | 'line' | 'square'): this {
    this.contents[0] = groupSymbolValue;
    return this;
  }
}

export type InstrumentsAttributes = Record<string, unknown>;

export type InstrumentsContents = [number];

/**
 * The `<instruments>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<instruments>` element is only used if more than one instrument is represented in the part (e.g., oboe I and II
 * where they play together most of the time). If absent, a value of 1 is assumed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/instruments/}
 */
export class Instruments implements XMLElement<'instruments', InstrumentsAttributes, InstrumentsContents> {
  static readonly schema = {
    name: 'instruments',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Instruments.schema;

  attributes: InstrumentsAttributes;
  contents: InstrumentsContents;

  constructor(opts?: { attributes?: Partial<InstrumentsAttributes>; contents?: InstrumentsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Instruments.schema);
    this.contents = opts?.contents ?? operations.zero(Instruments.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type SignAttributes = Record<string, unknown>;

export type SignContents = ['G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'];

/**
 * The `<sign>` element
 *
 * Parent elements: `<clef>`, `<part-clef>`
 *
 * The `<sign>` element represents the clef symbol.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/sign/}
 */
export class Sign implements XMLElement<'sign', SignAttributes, SignContents> {
  static readonly schema = {
    name: 'sign',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'clef-sign',
          value: { type: 'choices', choices: ['G', 'F', 'C', 'percussion', 'TAB', 'jianpu', 'none'] },
        },
      },
    ],
  } as const;

  readonly schema = Sign.schema;

  attributes: SignAttributes;
  contents: SignContents;

  constructor(opts?: { attributes?: Partial<SignAttributes>; contents?: SignContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Sign.schema);
    this.contents = opts?.contents ?? operations.zero(Sign.schema.contents);
  }

  /** Gets @type {'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'}. */
  getClefSign(): 'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none' {
    return this.contents[0];
  }
  /** Sets @type {'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'}. */
  setClefSign(clefSign: 'G' | 'F' | 'C' | 'percussion' | 'TAB' | 'jianpu' | 'none'): this {
    this.contents[0] = clefSign;
    return this;
  }
}

export type LineAttributes = Record<string, unknown>;

export type LineContents = [number];

/**
 * The `<line>` element
 *
 * Parent elements: `<clef>`, `<part-clef>`
 *
 * Line numbers are counted from the bottom of the staff. They are only needed with the G, F, and C signs in order to
 * position a pitch correctly on the staff. Standard values are 2 for the G sign (treble clef), 4 for the F sign (bass
 * clef), and 3 for the C sign (alto clef). Line values can be used to specify positions outside the staff, such as a
 * C clef positioned in the middle of a grand staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/line/}
 */
export class Line implements XMLElement<'line', LineAttributes, LineContents> {
  static readonly schema = {
    name: 'line',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'staff-line-position', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Line.schema;

  attributes: LineAttributes;
  contents: LineContents;

  constructor(opts?: { attributes?: Partial<LineAttributes>; contents?: LineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Line.schema);
    this.contents = opts?.contents ?? operations.zero(Line.schema.contents);
  }

  /** Gets @type {number}. */
  getStaffLinePosition(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setStaffLinePosition(staffLinePosition: number): this {
    this.contents[0] = staffLinePosition;
    return this;
  }
}

export type ClefOctaveChangeAttributes = Record<string, unknown>;

export type ClefOctaveChangeContents = [number];

/**
 * The `<clef-octave-change>` element
 *
 * Parent elements: `<clef>`, `<part-clef>`
 *
 * The `<clef-octave-change>` element is used for transposing clefs. A treble clef for tenors would have a value of -1.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/clef-octave-change/}
 */
export class ClefOctaveChange
  implements XMLElement<'clef-octave-change', ClefOctaveChangeAttributes, ClefOctaveChangeContents>
{
  static readonly schema = {
    name: 'clef-octave-change',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'clef-octave-change',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = ClefOctaveChange.schema;

  attributes: ClefOctaveChangeAttributes;
  contents: ClefOctaveChangeContents;

  constructor(opts?: { attributes?: Partial<ClefOctaveChangeAttributes>; contents?: ClefOctaveChangeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ClefOctaveChange.schema);
    this.contents = opts?.contents ?? operations.zero(ClefOctaveChange.schema.contents);
  }

  /** Gets @type {number}. */
  getClefOctaveChange(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setClefOctaveChange(clefOctaveChange: number): this {
    this.contents[0] = clefOctaveChange;
    return this;
  }
}

export type ClefAttributes = {
  /**
   * Sometimes clefs are added to the staff in non-standard line positions, either to indicate cue passages, or when
   * there are multiple clefs present simultaneously on one staff. In this situation, the additional attribute is
   * set to "yes" and the line value is ignored.
   */
  additional: 'yes' | 'no' | null;
  /**
   * Sometimes clefs at the start of a measure need to appear after the barline rather than before, as for cues or
   * for use after a repeated section. The after-barline attribute is set to "yes" in this situation. This attribute
   * is ignored for mid-measure clefs.
   */
  'after-barline': 'yes' | 'no' | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Specifies the staff number from top to bottom within the part. The value is 1 if not present.
   */
  number: number | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * The size attribute is used for clefs where the additional attribute is "yes". It is typically used to indicate
   * cue clefs.
   */
  size: 'cue' | 'full' | 'grace-cue' | 'large' | null;
};

export type ClefContents = [Sign, Line | null, ClefOctaveChange | null];

/**
 * The `<clef>` element
 *
 * Parent element: `<attributes>`
 *
 * Clefs are represented by a combination of `<sign>`, `<line>`, and `<clef-octave-change>` elements.
 *
 * Clefs appear at the start of each system unless the print-object attribute has been set to "no" or the additional
 * attribute has been set to "yes".
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/clef/}
 */
export class Clef implements XMLElement<'clef', ClefAttributes, ClefContents> {
  static readonly schema = {
    name: 'clef',
    attributes: {
      additional: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'after-barline': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      size: { type: 'optional', value: { type: 'choices', choices: ['cue', 'full', 'grace-cue', 'large'] } },
    },
    contents: [
      { type: 'required', value: Sign },
      { type: 'optional', value: Line },
      { type: 'optional', value: ClefOctaveChange },
    ],
  } as const;

  readonly schema = Clef.schema;

  attributes: ClefAttributes;
  contents: ClefContents;

  constructor(opts?: { attributes?: Partial<ClefAttributes>; contents?: ClefContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Clef.schema);
    this.contents = opts?.contents ?? operations.zero(Clef.schema.contents);
  }
  /** Gets @type {ClefAttributes['additional']}. */
  getAdditional(): 'yes' | 'no' | null {
    return this.attributes['additional'];
  }
  /** Sets @type {ClefAttributes['additional']}. */
  setAdditional(additional: 'yes' | 'no' | null): Clef {
    this.attributes['additional'] = additional;
    return this;
  }
  /** Gets @type {ClefAttributes['after-barline']}. */
  getAfterBarline(): 'yes' | 'no' | null {
    return this.attributes['after-barline'];
  }
  /** Sets @type {ClefAttributes['after-barline']}. */
  setAfterBarline(afterBarline: 'yes' | 'no' | null): Clef {
    this.attributes['after-barline'] = afterBarline;
    return this;
  }
  /** Gets @type {ClefAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {ClefAttributes['color']}. */
  setColor(color: string | null): Clef {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {ClefAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {ClefAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Clef {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {ClefAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {ClefAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Clef {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {ClefAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {ClefAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Clef {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {ClefAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {ClefAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Clef {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {ClefAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {ClefAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Clef {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {ClefAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {ClefAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Clef {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {ClefAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {ClefAttributes['id']}. */
  setId(id: string | null): Clef {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {ClefAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {ClefAttributes['number']}. */
  setNumber(number: number | null): Clef {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {ClefAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {ClefAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Clef {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {ClefAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {ClefAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Clef {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {ClefAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {ClefAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Clef {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {ClefAttributes['size']}. */
  getSize(): 'cue' | 'full' | 'grace-cue' | 'large' | null {
    return this.attributes['size'];
  }
  /** Sets @type {ClefAttributes['size']}. */
  setSize(size: 'cue' | 'full' | 'grace-cue' | 'large' | null): Clef {
    this.attributes['size'] = size;
    return this;
  }
  /** Gets @type {Sign}. */
  getSign(): Sign {
    return this.contents[0];
  }
  /** Sets @type {Sign}. */
  setSign(sign: Sign): this {
    this.contents[0] = sign;
    return this;
  }
  /** Gets @type {Line | null}. */
  getLine(): Line | null {
    return this.contents[1];
  }
  /** Sets @type {Line | null}. */
  setLine(line: Line | null): this {
    this.contents[1] = line;
    return this;
  }
  /** Gets @type {ClefOctaveChange | null}. */
  getClefOctaveChange(): ClefOctaveChange | null {
    return this.contents[2];
  }
  /** Sets @type {ClefOctaveChange | null}. */
  setClefOctaveChange(clefOctaveChange: ClefOctaveChange | null): this {
    this.contents[2] = clefOctaveChange;
    return this;
  }
}

export type StaffTypeAttributes = Record<string, unknown>;

export type StaffTypeContents = ['regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'];

/**
 * The <staff-type> element
 *
 * Parent element: <staff-details>
 *
 * The <staff-type> element specifies different uses for the staff, as listed in the staff-type data type.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-type/}
 */
export class StaffType implements XMLElement<'staff-type', StaffTypeAttributes, StaffTypeContents> {
  static readonly schema = {
    name: 'staff-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'staff-type',
          value: { type: 'choices', choices: ['regular', 'alternate', 'cue', 'editorial', 'ossia'] },
        },
      },
    ],
  } as const;

  readonly schema = StaffType.schema;

  attributes: StaffTypeAttributes;
  contents: StaffTypeContents;

  constructor(opts?: { attributes?: Partial<StaffTypeAttributes>; contents?: StaffTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffType.schema);
    this.contents = opts?.contents ?? operations.zero(StaffType.schema.contents);
  }

  /** Gets @type {'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'}. */
  getStaffType(): 'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia' {
    return this.contents[0];
  }
  /** Sets @type {'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'}. */
  setStaffType(staffType: 'regular' | 'alternate' | 'cue' | 'editorial' | 'ossia'): this {
    this.contents[0] = staffType;
    return this;
  }
}

export type StaffLinesAttributes = Record<string, unknown>;

export type StaffLinesContents = [number];

/**
 * The `<staff-lines>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<staff-lines>` element specifies the number of lines and is usually used for a non 5-line staff. If the
 * `<staff-lines>` element is present, the appearance of each line may be individually specified with a `<line-detail>`
 * element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-lines/}
 */
export class StaffLines implements XMLElement<'staff-lines', StaffLinesAttributes, StaffLinesContents> {
  static readonly schema = {
    name: 'staff-lines',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = StaffLines.schema;

  attributes: StaffLinesAttributes;
  contents: StaffLinesContents;

  constructor(opts?: { attributes?: Partial<StaffLinesAttributes>; contents?: StaffLinesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffLines.schema);
    this.contents = opts?.contents ?? operations.zero(StaffLines.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type LineDetailAttributes = {
  /**
   * Indicates the staff line affected, numbered from bottom to top.
   */
  line: number;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Specifies if the line is solid, dashed, dotted, or wavy.
   */
  'line-type': 'dashed' | 'dotted' | 'solid' | 'wavy' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Staff line width in tenths.
   */
  width: number | null;
};

export type LineDetailContents = [];

/**
 * The `<line-detail>` element
 *
 * Parent element: `<staff-details>`
 *
 * If the `<staff-lines>` element is present, the appearance of each line may be individually specified with a
 * `<line-detail>` element.
 *
 * The print-object attribute allows lines to be hidden within a staff. This is used in special situations such as a
 * widely-spaced percussion staff where a note placed below the higher line is distinct from a note placed above the
 * lower line. Hidden staff lines are included when specifying clef lines and determining `<display-step>` /
 * `<display-octave>` values, but are not counted as lines for the purposes of the `<system-layout>` and
 * `<staff-layout>` elements.
 *
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/line-detail/}
 */
export class LineDetail implements XMLElement<'line-detail', LineDetailAttributes, LineDetailContents> {
  static readonly schema = {
    name: 'line-detail',
    attributes: {
      line: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'line-type': { type: 'optional', value: { type: 'choices', choices: ['dashed', 'dotted', 'solid', 'wavy'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [],
  } as const;

  readonly schema = LineDetail.schema;

  attributes: LineDetailAttributes;
  contents: LineDetailContents;

  constructor(opts?: { attributes?: Partial<LineDetailAttributes>; contents?: LineDetailContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, LineDetail.schema);
    this.contents = opts?.contents ?? operations.zero(LineDetail.schema.contents);
  }
  /** Gets @type {LineDetailAttributes['line']}. */
  getLine(): number {
    return this.attributes['line'];
  }
  /** Sets @type {LineDetailAttributes['line']}. */
  setLine(line: number): LineDetail {
    this.attributes['line'] = line;
    return this;
  }
  /** Gets @type {LineDetailAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {LineDetailAttributes['color']}. */
  setColor(color: string | null): LineDetail {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {LineDetailAttributes['line-type']}. */
  getLineType(): 'dashed' | 'dotted' | 'solid' | 'wavy' | null {
    return this.attributes['line-type'];
  }
  /** Sets @type {LineDetailAttributes['line-type']}. */
  setLineType(lineType: 'dashed' | 'dotted' | 'solid' | 'wavy' | null): LineDetail {
    this.attributes['line-type'] = lineType;
    return this;
  }
  /** Gets @type {LineDetailAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {LineDetailAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): LineDetail {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {LineDetailAttributes['width']}. */
  getWidth(): number | null {
    return this.attributes['width'];
  }
  /** Sets @type {LineDetailAttributes['width']}. */
  setWidth(width: number | null): LineDetail {
    this.attributes['width'] = width;
    return this;
  }
}

export type StaffTuningAttributes = {
  /**
   * Indicates the staff line for this tuning, numbered from bottom to top.
   */
  line: number;
};

export type StaffTuningContents = [TuningStep, TuningAlter | null, TuningOctave];

/**
 * The `<staff-tuning>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<staff-tuning>` element specifies the open, non-capo tuning of the lines on a tablature staff.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-details/}
 */
export class StaffTuning implements XMLElement<'staff-tuning', StaffTuningAttributes, StaffTuningContents> {
  static readonly schema = {
    name: 'staff-tuning',
    attributes: { line: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
    contents: [
      { type: 'required', value: TuningStep },
      { type: 'optional', value: TuningAlter },
      { type: 'required', value: TuningOctave },
    ],
  } as const;

  readonly schema = StaffTuning.schema;

  attributes: StaffTuningAttributes;
  contents: StaffTuningContents;

  constructor(opts?: { attributes?: Partial<StaffTuningAttributes>; contents?: StaffTuningContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffTuning.schema);
    this.contents = opts?.contents ?? operations.zero(StaffTuning.schema.contents);
  }
  /** Gets @type {StaffTuningAttributes['line']}. */
  getLine(): number {
    return this.attributes['line'];
  }
  /** Sets @type {StaffTuningAttributes['line']}. */
  setLine(line: number): StaffTuning {
    this.attributes['line'] = line;
    return this;
  }
  /** Gets @type {TuningStep}. */
  getTuningStep(): TuningStep {
    return this.contents[0];
  }
  /** Sets @type {TuningStep}. */
  setTuningStep(tuningStep: TuningStep): this {
    this.contents[0] = tuningStep;
    return this;
  }
  /** Gets @type {TuningAlter | null}. */
  getTuningAlter(): TuningAlter | null {
    return this.contents[1];
  }
  /** Sets @type {TuningAlter | null}. */
  setTuningAlter(tuningAlter: TuningAlter | null): this {
    this.contents[1] = tuningAlter;
    return this;
  }
  /** Gets @type {TuningOctave}. */
  getTuningOctave(): TuningOctave {
    return this.contents[2];
  }
  /** Sets @type {TuningOctave}. */
  setTuningOctave(tuningOctave: TuningOctave): this {
    this.contents[2] = tuningOctave;
    return this;
  }
}

export type CapoAttributes = Record<string, unknown>;

export type CapoContents = [number];

/**
 * The `<capo>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<capo>` element indicates at which fret a capo should be placed on a fretted instrument. This changes the open
 * tuning of the strings specified by the `<staff-tuning>` element by the specified number of half-steps.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/capo/}
 */
export class Capo implements XMLElement<'capo', CapoAttributes, CapoContents> {
  static readonly schema = {
    name: 'capo',
    attributes: {},
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Capo.schema;

  attributes: CapoAttributes;
  contents: CapoContents;

  constructor(opts?: { attributes?: Partial<CapoAttributes>; contents?: CapoContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Capo.schema);
    this.contents = opts?.contents ?? operations.zero(Capo.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type StaffSizeAttributes = {
  /**
   * Specifies the percentage scaling that applies to the notation. Values less that 100 make the notation smaller
   * while values over 100 make the notation larger.
   */
  scaling: number | null;
};

export type StaffSizeContents = [number];

/**
 * The `<staff-size>` element
 *
 * Parent element: `<staff-details>`
 *
 * The `<staff-size>` element indicates how large a staff space is on this staff, expressed as a percentage of the
 * work's default scaling. Values less than 100 make the staff space smaller while values over 100 make the staff space
 * larger. A `<staff-type>` of cue, ossia, or editorial implies a `<staff-size>` of less than 100, but the exact value
 * is implementation-dependent unless specified here. Staff size affects staff height only, not the relationship of the
 * staff to the left and right margins.
 *
 * In some cases, a `<staff-size>` different than 100 also scales the notation on the staff, such as with a cue staff.
 * In other cases, such as percussion staves, the lines may be more widely spaced without scaling the notation on the
 * staff. The scaling attribute allows these two cases to be distinguished.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-size/}
 */
export class StaffSize implements XMLElement<'staff-size', StaffSizeAttributes, StaffSizeContents> {
  static readonly schema = {
    name: 'staff-size',
    attributes: { scaling: { type: 'optional', value: { type: 'float', min: 0, max: Infinity } } },
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'float', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = StaffSize.schema;

  attributes: StaffSizeAttributes;
  contents: StaffSizeContents;

  constructor(opts?: { attributes?: Partial<StaffSizeAttributes>; contents?: StaffSizeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffSize.schema);
    this.contents = opts?.contents ?? operations.zero(StaffSize.schema.contents);
  }
  /** Gets @type {StaffSizeAttributes['scaling']}. */
  getScaling(): number | null {
    return this.attributes['scaling'];
  }
  /** Sets @type {StaffSizeAttributes['scaling']}. */
  setScaling(scaling: number | null): StaffSize {
    this.attributes['scaling'] = scaling;
    return this;
  }
  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type StaffDetailsAttributes = {
  /**
   * Specifies the staff number from top to bottom within the part. The value is 1 if not present.
   */
  number: number | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Controls whether or not spacing is left for an invisible note or object. It is used only if no note, dot, or
   * lyric is being printed. The value is yes (leave spacing) if not specified.
   */
  'print-spacing': 'yes' | 'no' | null;
  /**
   * Indicates whether to show tablature frets as numbers (0, 1, 2) or letters (a, b, c). It is numbers if not
   * specified.
   */
  'show-frets': 'letters' | 'numbers' | null;
};

export type StaffDetailsContents = [
  StaffType | null,
  [StaffLines, Array<LineDetail>] | null,
  Array<StaffTuning>,
  Capo | null,
  StaffSize | null,
];

/**
 * The `<staff-details>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<staff-details>` element is used to indicate different types of staves.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/staff-details/}
 */
export class StaffDetails implements XMLElement<'staff-details', StaffDetailsAttributes, StaffDetailsContents> {
  static readonly schema = {
    name: 'staff-details',
    attributes: {
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'show-frets': { type: 'optional', value: { type: 'choices', choices: ['letters', 'numbers'] } },
    },
    contents: [
      { type: 'optional', value: StaffType },
      {
        type: 'label',
        label: 'lines',
        value: {
          type: 'optional',
          value: [
            { type: 'required', value: StaffLines },
            { type: 'zeroOrMore', value: LineDetail },
          ],
        },
      },
      { type: 'label', label: 'staff-tunings', value: { type: 'zeroOrMore', value: StaffTuning } },
      { type: 'optional', value: Capo },
      { type: 'optional', value: StaffSize },
    ],
  } as const;

  readonly schema = StaffDetails.schema;

  attributes: StaffDetailsAttributes;
  contents: StaffDetailsContents;

  constructor(opts?: { attributes?: Partial<StaffDetailsAttributes>; contents?: StaffDetailsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, StaffDetails.schema);
    this.contents = opts?.contents ?? operations.zero(StaffDetails.schema.contents);
  }
  /** Gets @type {StaffDetailsAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {StaffDetailsAttributes['number']}. */
  setNumber(number: number | null): StaffDetails {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {StaffDetailsAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {StaffDetailsAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): StaffDetails {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {StaffDetailsAttributes['print-spacing']}. */
  getPrintSpacing(): 'yes' | 'no' | null {
    return this.attributes['print-spacing'];
  }
  /** Sets @type {StaffDetailsAttributes['print-spacing']}. */
  setPrintSpacing(printSpacing: 'yes' | 'no' | null): StaffDetails {
    this.attributes['print-spacing'] = printSpacing;
    return this;
  }
  /** Gets @type {StaffDetailsAttributes['show-frets']}. */
  getShowFrets(): 'letters' | 'numbers' | null {
    return this.attributes['show-frets'];
  }
  /** Sets @type {StaffDetailsAttributes['show-frets']}. */
  setShowFrets(showFrets: 'letters' | 'numbers' | null): StaffDetails {
    this.attributes['show-frets'] = showFrets;
    return this;
  }
  /** Gets @type {StaffType | null}. */
  getStaffType(): StaffType | null {
    return this.contents[0];
  }
  /** Sets @type {StaffType | null}. */
  setStaffType(staffType: StaffType | null): this {
    this.contents[0] = staffType;
    return this;
  }
  /** Gets @type {[StaffLines, Array<LineDetail>] | null}. */
  getLines(): [StaffLines, Array<LineDetail>] | null {
    return this.contents[1];
  }
  /** Sets @type {[StaffLines, Array<LineDetail>] | null}. */
  setLines(lines: [StaffLines, Array<LineDetail>] | null): this {
    this.contents[1] = lines;
    return this;
  }
  /** Gets @type {Array<StaffTuning>}. */
  getStaffTunings(): Array<StaffTuning> {
    return this.contents[2];
  }
  /** Sets @type {Array<StaffTuning>}. */
  setStaffTunings(staffTunings: Array<StaffTuning>): this {
    this.contents[2] = staffTunings;
    return this;
  }
  /** Gets @type {Capo | null}. */
  getCapo(): Capo | null {
    return this.contents[3];
  }
  /** Sets @type {Capo | null}. */
  setCapo(capo: Capo | null): this {
    this.contents[3] = capo;
    return this;
  }
  /** Gets @type {StaffSize | null}. */
  getStaffSize(): StaffSize | null {
    return this.contents[4];
  }
  /** Sets @type {StaffSize | null}. */
  setStaffSize(staffSize: StaffSize | null): this {
    this.contents[4] = staffSize;
    return this;
  }
}

export type DiatonicAttributes = Record<string, unknown>;

export type DiatonicContents = [number];

/**
 * The `<diatonic>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * The `<diatonic>` element specifies the number of pitch steps needed to go from written to sounding pitch. This allows
 * for correct spelling of enharmonic transpositions. This value does not include <octave-change> values; the values for
 * both elements need to be added to the written pitch to get the correct sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/diatonic/}
 */
export class Diatonic implements XMLElement<'diatonic', DiatonicAttributes, DiatonicContents> {
  static readonly schema = {
    name: 'diatonic',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'diatonic',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Diatonic.schema;

  attributes: DiatonicAttributes;
  contents: DiatonicContents;

  constructor(opts?: { attributes?: Partial<DiatonicAttributes>; contents?: DiatonicContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Diatonic.schema);
    this.contents = opts?.contents ?? operations.zero(Diatonic.schema.contents);
  }

  /** Gets @type {number}. */
  getDiatonic(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setDiatonic(diatonic: number): this {
    this.contents[0] = diatonic;
    return this;
  }
}

export type ChromaticAttributes = Record<string, unknown>;

export type ChromaticContents = [number];

/**
 * The `<chromatic>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * The `<chromatic>` element represents the number of semitones needed to get from written to sounding pitch. This value
 * does not include `<octave-change>` values; the values for both elements need to be added to the written pitch to get
 * the correct sounding pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/chromatic/}
 */
export class Chromatic implements XMLElement<'chromatic', ChromaticAttributes, ChromaticContents> {
  static readonly schema = {
    name: 'chromatic',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = Chromatic.schema;

  attributes: ChromaticAttributes;
  contents: ChromaticContents;

  constructor(opts?: { attributes?: Partial<ChromaticAttributes>; contents?: ChromaticContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Chromatic.schema);
    this.contents = opts?.contents ?? operations.zero(Chromatic.schema.contents);
  }

  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type OctaveChangeAttributes = Record<string, unknown>;

export type OctaveChangeContents = [number];

/**
 * The `<octave-change>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * The `<octave-change>` element indicates how many octaves to add to get from written pitch to sounding pitch. The
 * `<octave-change>` element should be included when using transposition intervals of an octave or more, and should not
 * be present for intervals of less than an octave.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/octave-change/}
 */
export class OctaveChange implements XMLElement<'octave-change', OctaveChangeAttributes, OctaveChangeContents> {
  static readonly schema = {
    name: 'octave-change',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = OctaveChange.schema;

  attributes: OctaveChangeAttributes;
  contents: OctaveChangeContents;

  constructor(opts?: { attributes?: Partial<OctaveChangeAttributes>; contents?: OctaveChangeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, OctaveChange.schema);
    this.contents = opts?.contents ?? operations.zero(OctaveChange.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type DoubleAttributes = {
  /**
   * If the above attribute is set to yes, the doubling is one octave above what is written, as for mixed flute /
   * piccolo parts in band literature. Otherwise the doubling is one octave below what is written, as for mixed
   * cello / bass parts in orchestral literature.
   */
  above: 'yes' | 'no' | null;
};

export type DoubleContents = [];

/**
 * The `<double>` element
 *
 * Parent elements: `<part-transpose>`, `<transpose>`
 *
 * If the `<double>` element is present, it indicates that the music is doubled one octave from what is currently
 * written.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/double/}
 */
export class Double implements XMLElement<'double', DoubleAttributes, DoubleContents> {
  static readonly schema = {
    name: 'double',
    attributes: { above: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [],
  } as const;

  readonly schema = Double.schema;

  attributes: DoubleAttributes;
  contents: DoubleContents;

  constructor(opts?: { attributes?: Partial<DoubleAttributes>; contents?: DoubleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Double.schema);
    this.contents = opts?.contents ?? operations.zero(Double.schema.contents);
  }
  /** Gets @type {DoubleAttributes['above']}. */
  getAbove(): 'yes' | 'no' | null {
    return this.attributes['above'];
  }
  /** Sets @type {DoubleAttributes['above']}. */
  setAbove(above: 'yes' | 'no' | null): Double {
    this.attributes['above'] = above;
    return this;
  }
}

export type TransposeAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Allows a transposition to apply to only the specified staff in the part. If absent, the transposition applies
   * to all staves in the part. Per-staff transposition is most often used in parts that represent multiple
   * instruments.
   */
  number: number | null;
};

export type TransposeContents = [Diatonic | null, Chromatic, OctaveChange | null, Double | null];

/**
 * The `<transpose>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<transpose>` element represents what must be added to a written pitch to get a correct sounding pitch. It is
 * used for encoding parts for transposing instruments that are in written vs. concert pitch.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/transpose/}
 */
export class Transpose implements XMLElement<'transpose', TransposeAttributes, TransposeContents> {
  static readonly schema = {
    name: 'transpose',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      { type: 'optional', value: Diatonic },
      { type: 'required', value: Chromatic },
      { type: 'optional', value: OctaveChange },
      { type: 'optional', value: Double },
    ],
  } as const;

  readonly schema = Transpose.schema;

  attributes: TransposeAttributes;
  contents: TransposeContents;

  constructor(opts?: { attributes?: Partial<TransposeAttributes>; contents?: TransposeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Transpose.schema);
    this.contents = opts?.contents ?? operations.zero(Transpose.schema.contents);
  }
  /** Gets @type {TransposeAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {TransposeAttributes['id']}. */
  setId(id: string | null): Transpose {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {TransposeAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {TransposeAttributes['number']}. */
  setNumber(number: number | null): Transpose {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {Diatonic | null}. */
  getDiatonic(): Diatonic | null {
    return this.contents[0];
  }
  /** Sets @type {Diatonic | null}. */
  setDiatonic(diatonic: Diatonic | null): this {
    this.contents[0] = diatonic;
    return this;
  }
  /** Gets @type {Chromatic}. */
  getChromatic(): Chromatic {
    return this.contents[1];
  }
  /** Sets @type {Chromatic}. */
  setChromatic(chromatic: Chromatic): this {
    this.contents[1] = chromatic;
    return this;
  }
  /** Gets @type {OctaveChange | null}. */
  getOctaveChange(): OctaveChange | null {
    return this.contents[2];
  }
  /** Sets @type {OctaveChange | null}. */
  setOctaveChange(octaveChange: OctaveChange | null): this {
    this.contents[2] = octaveChange;
    return this;
  }
  /** Gets @type {Double | null}. */
  getDouble(): Double | null {
    return this.contents[3];
  }
  /** Sets @type {Double | null}. */
  setDouble(double: Double | null): this {
    this.contents[3] = double;
    return this;
  }
}

export type PartClefAttributes = Record<string, unknown>;

export type PartClefContents = [Sign, Line | null, ClefOctaveChange | null];

/**
 * The `<part-clef>` element
 *
 * Parent element: `<for-part>`
 *
 * The `<part-clef>` element is used for transpositions from concert scores that also include a change of clef, as for
 * instruments such as bass clarinet.
 *
 * The child elements of the `<part-clef>` element have the same meaning as for the `<clef>` element. However that
 * meaning applies to a transposed part created from the existing score file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-clef/}
 */
export class PartClef implements XMLElement<'part-clef', PartClefAttributes, PartClefContents> {
  static readonly schema = {
    name: 'part-clef',
    attributes: {},
    contents: [
      { type: 'required', value: Sign },
      { type: 'optional', value: Line },
      { type: 'optional', value: ClefOctaveChange },
    ],
  } as const;

  readonly schema = PartClef.schema;

  attributes: PartClefAttributes;
  contents: PartClefContents;

  constructor(opts?: { attributes?: Partial<PartClefAttributes>; contents?: PartClefContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartClef.schema);
    this.contents = opts?.contents ?? operations.zero(PartClef.schema.contents);
  }

  /** Gets @type {Sign}. */
  getSign(): Sign {
    return this.contents[0];
  }
  /** Sets @type {Sign}. */
  setSign(sign: Sign): this {
    this.contents[0] = sign;
    return this;
  }
  /** Gets @type {Line | null}. */
  getLine(): Line | null {
    return this.contents[1];
  }
  /** Sets @type {Line | null}. */
  setLine(line: Line | null): this {
    this.contents[1] = line;
    return this;
  }
  /** Gets @type {ClefOctaveChange | null}. */
  getClefOctaveChange(): ClefOctaveChange | null {
    return this.contents[2];
  }
  /** Sets @type {ClefOctaveChange | null}. */
  setClefOctaveChange(clefOctaveChange: ClefOctaveChange | null): this {
    this.contents[2] = clefOctaveChange;
    return this;
  }
}

export type PartTransposeAttributes = Record<string, unknown>;

export type PartTransposeContents = [Diatonic | null, Chromatic, OctaveChange | null, Double | null];

/**
 * The `<part-transpose>` element
 *
 * Parent element: `<for-part>`
 *
 * The child elements of the `<part-transpose>` element have the same meaning as for the `<transpose>` element. However
 * that meaning applies to a transposed part created from the existing score file.
 *
 * The `<chromatic>` element in a `<part-transpose>` element will usually have a non-zero value, since octave
 * transpositions can be represented in concert scores using the `<transpose>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-transpose/}
 */
export class PartTranspose implements XMLElement<'part-transpose', PartTransposeAttributes, PartTransposeContents> {
  static readonly schema = {
    name: 'part-transpose',
    attributes: {},
    contents: [
      { type: 'optional', value: Diatonic },
      { type: 'required', value: Chromatic },
      { type: 'optional', value: OctaveChange },
      { type: 'optional', value: Double },
    ],
  } as const;

  readonly schema = PartTranspose.schema;

  attributes: PartTransposeAttributes;
  contents: PartTransposeContents;

  constructor(opts?: { attributes?: Partial<PartTransposeAttributes>; contents?: PartTransposeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartTranspose.schema);
    this.contents = opts?.contents ?? operations.zero(PartTranspose.schema.contents);
  }

  /** Gets @type {Diatonic | null}. */
  getDiatonic(): Diatonic | null {
    return this.contents[0];
  }
  /** Sets @type {Diatonic | null}. */
  setDiatonic(diatonic: Diatonic | null): this {
    this.contents[0] = diatonic;
    return this;
  }
  /** Gets @type {Chromatic}. */
  getChromatic(): Chromatic {
    return this.contents[1];
  }
  /** Sets @type {Chromatic}. */
  setChromatic(chromatic: Chromatic): this {
    this.contents[1] = chromatic;
    return this;
  }
  /** Gets @type {OctaveChange | null}. */
  getOctaveChange(): OctaveChange | null {
    return this.contents[2];
  }
  /** Sets @type {OctaveChange | null}. */
  setOctaveChange(octaveChange: OctaveChange | null): this {
    this.contents[2] = octaveChange;
    return this;
  }
  /** Gets @type {Double | null}. */
  getDouble(): Double | null {
    return this.contents[3];
  }
  /** Sets @type {Double | null}. */
  setDouble(double: Double | null): this {
    this.contents[3] = double;
    return this;
  }
}

export type ForPartAttributes = {
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Allows a transposition to apply to only the specified staff in the part. If absent, the transposition applies
   * to all staves in the part. Per-staff transposition is most often used in parts that represent multiple
   * instruments.
   */
  number: number | null;
};

export type ForPartContents = [PartClef | null, PartTranspose];

/**
 * The `<for-part>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<for-part>` element is used in a concert score to indicate the transposition for a transposed part created from
 * that score. It is only used in score files that contain a `<concert-score>` element in the `<defaults>` element. This
 * allows concert scores with transposed parts to be represented in a single uncompressed MusicXML file.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/for-part/}
 */
export class ForPart implements XMLElement<'for-part', ForPartAttributes, ForPartContents> {
  static readonly schema = {
    name: 'for-part',
    attributes: {
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      { type: 'optional', value: PartClef },
      { type: 'required', value: PartTranspose },
    ],
  } as const;

  readonly schema = ForPart.schema;

  attributes: ForPartAttributes;
  contents: ForPartContents;

  constructor(opts?: { attributes?: Partial<ForPartAttributes>; contents?: ForPartContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ForPart.schema);
    this.contents = opts?.contents ?? operations.zero(ForPart.schema.contents);
  }
  /** Gets @type {ForPartAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {ForPartAttributes['id']}. */
  setId(id: string | null): ForPart {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {ForPartAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {ForPartAttributes['number']}. */
  setNumber(number: number | null): ForPart {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {PartClef | null}. */
  getPartClef(): PartClef | null {
    return this.contents[0];
  }
  /** Sets @type {PartClef | null}. */
  setPartClef(partClef: PartClef | null): this {
    this.contents[0] = partClef;
    return this;
  }
  /** Gets @type {PartTranspose}. */
  getPartTranspose(): PartTranspose {
    return this.contents[1];
  }
  /** Sets @type {PartTranspose}. */
  setPartTranspose(partTranspose: PartTranspose): this {
    this.contents[1] = partTranspose;
    return this;
  }
}

export type DirectiveAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Specifies the language used in the element content. It is Italian ("it") if not specified.
   */
  'xml:lang': string | null;
};

export type DirectiveContents = [string];

/**
 * The `<directive>` element
 *
 * Parent element: `<attributes>`
 *
 * Directives are like directions, but can be grouped together with attributes for convenience. This is typically used
 * for tempo markings at the beginning of a piece of music. This element was deprecated in Version 2.0 in favor of the
 * `<direction>` element's directive attribute.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/directive/}
 */
export class Directive implements XMLElement<'directive', DirectiveAttributes, DirectiveContents> {
  static readonly schema = {
    name: 'directive',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'xml:lang': { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Directive.schema;

  attributes: DirectiveAttributes;
  contents: DirectiveContents;

  constructor(opts?: { attributes?: Partial<DirectiveAttributes>; contents?: DirectiveContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Directive.schema);
    this.contents = opts?.contents ?? operations.zero(Directive.schema.contents);
  }
  /** Gets @type {DirectiveAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DirectiveAttributes['color']}. */
  setColor(color: string | null): Directive {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DirectiveAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DirectiveAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Directive {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DirectiveAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DirectiveAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Directive {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DirectiveAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DirectiveAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Directive {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DirectiveAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DirectiveAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Directive {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DirectiveAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DirectiveAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Directive {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DirectiveAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DirectiveAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Directive {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DirectiveAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DirectiveAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Directive {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DirectiveAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DirectiveAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Directive {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DirectiveAttributes['xml:lang']}. */
  getXmlLang(): string | null {
    return this.attributes['xml:lang'];
  }
  /** Sets @type {DirectiveAttributes['xml:lang']}. */
  setXmlLang(xmlLang: string | null): Directive {
    this.attributes['xml:lang'] = xmlLang;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type MultipleRestAttributes = {
  /**
   * Specifies whether the multiple rests uses the 1-bar / 2-bar / 4-bar rest symbols, or a single shape. It is no if
   * not specified.
   */
  'use-symbols': 'yes' | 'no' | null;
};

export type MultipleRestContents = [number];

/**
 * The `<multiple-rest>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<multiple-rest>` element indicates multiple rests that span several measures. The element text indicates the number of measures in the multiple rest.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/multiple-rest/}
 */
export class MultipleRest implements XMLElement<'multiple-rest', MultipleRestAttributes, MultipleRestContents> {
  static readonly schema = {
    name: 'multiple-rest',
    attributes: { 'use-symbols': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      {
        type: 'label',
        label: 'multiple-rest',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = MultipleRest.schema;

  attributes: MultipleRestAttributes;
  contents: MultipleRestContents;

  constructor(opts?: { attributes?: Partial<MultipleRestAttributes>; contents?: MultipleRestContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MultipleRest.schema);
    this.contents = opts?.contents ?? operations.zero(MultipleRest.schema.contents);
  }
  /** Gets @type {MultipleRestAttributes['use-symbols']}. */
  getUseSymbols(): 'yes' | 'no' | null {
    return this.attributes['use-symbols'];
  }
  /** Sets @type {MultipleRestAttributes['use-symbols']}. */
  setUseSymbols(useSymbols: 'yes' | 'no' | null): MultipleRest {
    this.attributes['use-symbols'] = useSymbols;
    return this;
  }
  /** Gets @type {number}. */
  getMultipleRest(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setMultipleRest(multipleRest: number): this {
    this.contents[0] = multipleRest;
    return this;
  }
}

export type MeasureRepeatAttributes = {
  /**
   * Indicates the starting or stopping point of the section displaying the measure repeat symbols.
   */
  type: 'start' | 'stop';
  /**
   * Specifies the number of slashes to use in the symbol. The value is 1 if not specified.
   */
  slashes: number | null;
};

export type MeasureRepeatContents = ['' | number];

/**
 * The `<measure-repeat>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<measure-repeat>` element is used for both single and multiple measure repeats. The text of the element
 * indicates the number of measures to be repeated in a single pattern. The text of the element is ignored when the type
 * is stop.
 *
 * The stop type indicates the first measure where the repeats are no longer displayed. Both the start and the stop of
 * the measures being repeated should be specified unless the repeats are displayed through the end of the part.
 *
 * The `<measure-repeat>` element specifies a notation style for repetitions. The actual music being repeated needs to
 * be repeated within each measure of the MusicXML file. This element specifies the notation that indicates the repeat.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-repeat/}
 */
export class MeasureRepeat implements XMLElement<'measure-repeat', MeasureRepeatAttributes, MeasureRepeatContents> {
  static readonly schema = {
    name: 'measure-repeat',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      slashes: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'choices', choices: ['', { type: 'int', min: 1, max: Infinity }] } },
      },
    ],
  } as const;

  readonly schema = MeasureRepeat.schema;

  attributes: MeasureRepeatAttributes;
  contents: MeasureRepeatContents;

  constructor(opts?: { attributes?: Partial<MeasureRepeatAttributes>; contents?: MeasureRepeatContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureRepeat.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureRepeat.schema.contents);
  }
  /** Gets @type {MeasureRepeatAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {MeasureRepeatAttributes['type']}. */
  setType(type: 'start' | 'stop'): MeasureRepeat {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {MeasureRepeatAttributes['slashes']}. */
  getSlashes(): number | null {
    return this.attributes['slashes'];
  }
  /** Sets @type {MeasureRepeatAttributes['slashes']}. */
  setSlashes(slashes: number | null): MeasureRepeat {
    this.attributes['slashes'] = slashes;
    return this;
  }
  /** Gets @type {'' | number}. */
  getValue(): '' | number {
    return this.contents[0];
  }
  /** Sets @type {'' | number}. */
  setValue(value: '' | number): this {
    this.contents[0] = value;
    return this;
  }
}

export type SlashTypeAttributes = Record<string, unknown>;

export type SlashTypeContents = [
  | 'whole'
  | '1024th'
  | '512th'
  | '256th'
  | '128th'
  | '64th'
  | '32nd'
  | '16th'
  | 'eighth'
  | 'half'
  | 'quarter'
  | 'whole'
  | 'breve'
  | 'long'
  | 'maxima',
];

/**
 * The `<slash-type>` element
 *
 * Parent elements: `<beat-repeat>`, `<slash>`
 *
 * The `<slash-type>` element indicates the graphical note type to use for the display of repetition marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slash-type/}
 */
export class SlashType implements XMLElement<'slash-type', SlashTypeAttributes, SlashTypeContents> {
  static readonly schema = {
    name: 'slash-type',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'note-type-value',
          value: {
            type: 'choices',
            choices: [
              'whole',
              '1024th',
              '512th',
              '256th',
              '128th',
              '64th',
              '32nd',
              '16th',
              'eighth',
              'half',
              'quarter',
              'whole',
              'breve',
              'long',
              'maxima',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = SlashType.schema;

  attributes: SlashTypeAttributes;
  contents: SlashTypeContents;

  constructor(opts?: { attributes?: Partial<SlashTypeAttributes>; contents?: SlashTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SlashType.schema);
    this.contents = opts?.contents ?? operations.zero(SlashType.schema.contents);
  }

  /** Gets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  getNoteTypeValue():
    | 'whole'
    | '1024th'
    | '512th'
    | '256th'
    | '128th'
    | '64th'
    | '32nd'
    | '16th'
    | 'eighth'
    | 'half'
    | 'quarter'
    | 'whole'
    | 'breve'
    | 'long'
    | 'maxima' {
    return this.contents[0];
  }
  /** Sets @type {'whole' | '1024th' | '512th' | '256th' | '128th' | '64th' | '32nd' | '16th' | 'eighth' | 'half' | 'quarter' | 'whole' | 'breve' | 'long' | 'maxima'}. */
  setNoteTypeValue(
    noteTypeValue:
      | 'whole'
      | '1024th'
      | '512th'
      | '256th'
      | '128th'
      | '64th'
      | '32nd'
      | '16th'
      | 'eighth'
      | 'half'
      | 'quarter'
      | 'whole'
      | 'breve'
      | 'long'
      | 'maxima'
  ): this {
    this.contents[0] = noteTypeValue;
    return this;
  }
}

export type SlashDotAttributes = Record<string, unknown>;

export type SlashDotContents = [];

/**
 * The `<slash-dot>` element
 *
 * Parent elements: `<beat-repeat>`, `<slash>`
 *
 * The `<slash-dot>` element is used to specify any augmentation dots in the note type used to display repetition marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slash-dot/}
 */
export class SlashDot implements XMLElement<'slash-dot', SlashDotAttributes, SlashDotContents> {
  static readonly schema = { name: 'slash-dot', attributes: {}, contents: [] } as const;

  readonly schema = SlashDot.schema;

  attributes: SlashDotAttributes;
  contents: SlashDotContents;

  constructor(opts?: { attributes?: Partial<SlashDotAttributes>; contents?: SlashDotContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, SlashDot.schema);
    this.contents = opts?.contents ?? operations.zero(SlashDot.schema.contents);
  }
}

export type ExceptVoiceAttributes = Record<string, unknown>;

export type ExceptVoiceContents = [string];

/**
 * The `<except-voice>` element
 *
 * Parent elements: `<beat-repeat>`, `<slash>`
 *
 * The `<except-voice>` element is used to specify a combination of slash notation and regular notation. Any `<note>`
 * elements that are in voices specified by the `<except-voice>` elements are displayed in normal notation, in addition
 * to the slash notation that is always displayed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/except-voice/}
 */
export class ExceptVoice implements XMLElement<'except-voice', ExceptVoiceAttributes, ExceptVoiceContents> {
  static readonly schema = {
    name: 'except-voice',
    attributes: {},
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = ExceptVoice.schema;

  attributes: ExceptVoiceAttributes;
  contents: ExceptVoiceContents;

  constructor(opts?: { attributes?: Partial<ExceptVoiceAttributes>; contents?: ExceptVoiceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ExceptVoice.schema);
    this.contents = opts?.contents ?? operations.zero(ExceptVoice.schema.contents);
  }

  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type BeatRepeatAttributes = {
  /**
   * Indicates the starting or stopping point of the section displaying the beat repeat symbols.
   */
  type: 'start' | 'stop';
  /**
   * Specifies the number of slashes to use in the symbol. The value is 1 if not specified.
   */
  slashes: number | null;
  /**
   * Indicates whether or not to use dots as well (for instance, with mixed rhythm patterns). The value is no if not
   * specified.
   */
  'use-dots': 'yes' | 'no' | null;
};

export type BeatRepeatContents = [[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null];

/**
 * The `<beat-repeat>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<beat-repeat>` element is used to indicate that a single beat (but possibly many notes) is repeated.
 *
 * The stop type indicates the first beat where the repeats are no longer displayed. Both the start and stop of the
 * beats being repeated should be specified unless the repeats are displayed through the end of the part.
 *
 * The `<beat-repeat>` element specifies a notation style for repetitions. The actual music being repeated needs to be
 * repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/beat-repeat/}
 */
export class BeatRepeat implements XMLElement<'beat-repeat', BeatRepeatAttributes, BeatRepeatContents> {
  static readonly schema = {
    name: 'beat-repeat',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      slashes: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      'use-dots': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'beat-repeat',
        value: {
          type: 'optional',
          value: [
            {
              type: 'optional',
              value: [
                { type: 'required', value: SlashType },
                { type: 'zeroOrMore', value: SlashDot },
              ],
            },
            { type: 'zeroOrMore', value: ExceptVoice },
          ],
        },
      },
    ],
  } as const;

  readonly schema = BeatRepeat.schema;

  attributes: BeatRepeatAttributes;
  contents: BeatRepeatContents;

  constructor(opts?: { attributes?: Partial<BeatRepeatAttributes>; contents?: BeatRepeatContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BeatRepeat.schema);
    this.contents = opts?.contents ?? operations.zero(BeatRepeat.schema.contents);
  }
  /** Gets @type {BeatRepeatAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {BeatRepeatAttributes['type']}. */
  setType(type: 'start' | 'stop'): BeatRepeat {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {BeatRepeatAttributes['slashes']}. */
  getSlashes(): number | null {
    return this.attributes['slashes'];
  }
  /** Sets @type {BeatRepeatAttributes['slashes']}. */
  setSlashes(slashes: number | null): BeatRepeat {
    this.attributes['slashes'] = slashes;
    return this;
  }
  /** Gets @type {BeatRepeatAttributes['use-dots']}. */
  getUseDots(): 'yes' | 'no' | null {
    return this.attributes['use-dots'];
  }
  /** Sets @type {BeatRepeatAttributes['use-dots']}. */
  setUseDots(useDots: 'yes' | 'no' | null): BeatRepeat {
    this.attributes['use-dots'] = useDots;
    return this;
  }
  /** Gets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
  getBeatRepeat(): [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null {
    return this.contents[0];
  }
  /** Sets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
  setBeatRepeat(beatRepeat: [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null): this {
    this.contents[0] = beatRepeat;
    return this;
  }
}

export type SlashAttributes = {
  /**
   * Indicates the starting or stopping point of the section displaying slash notation.
   */
  type: 'start' | 'stop';
  /**
   * Indicates whether or not to use dots as well (for instance, with mixed rhythm patterns). The value is no if not
   * specified. This attribute only has effect if use-stems is no.
   */
  'use-dots': 'yes' | 'no' | null;
  /**
   * If the slash is on every beat, use-stems is no (the default). To indicate rhythms but not pitches, use-stems is
   * set to yes.
   */
  'use-stems': 'yes' | 'no' | null;
};

export type SlashContents = [[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null];

/**
 * The `<slash>` element
 *
 * Parent element: `<measure-style>`
 *
 * The `<slash>` element indicates that slash notation is to be used.
 *
 * The stop type indicates the first beat where slash notation no longer displayed. Both the start and stop of the slash
 * notation should be specified unless the slashes are displayed through the end of the part.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/slash/}
 */
export class Slash implements XMLElement<'slash', SlashAttributes, SlashContents> {
  static readonly schema = {
    name: 'slash',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      'use-dots': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'use-stems': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: {
          type: 'optional',
          value: [
            {
              type: 'optional',
              value: [
                { type: 'required', value: SlashType },
                { type: 'zeroOrMore', value: SlashDot },
              ],
            },
            { type: 'zeroOrMore', value: ExceptVoice },
          ],
        },
      },
    ],
  } as const;

  readonly schema = Slash.schema;

  attributes: SlashAttributes;
  contents: SlashContents;

  constructor(opts?: { attributes?: Partial<SlashAttributes>; contents?: SlashContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Slash.schema);
    this.contents = opts?.contents ?? operations.zero(Slash.schema.contents);
  }
  /** Gets @type {SlashAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {SlashAttributes['type']}. */
  setType(type: 'start' | 'stop'): Slash {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {SlashAttributes['use-dots']}. */
  getUseDots(): 'yes' | 'no' | null {
    return this.attributes['use-dots'];
  }
  /** Sets @type {SlashAttributes['use-dots']}. */
  setUseDots(useDots: 'yes' | 'no' | null): Slash {
    this.attributes['use-dots'] = useDots;
    return this;
  }
  /** Gets @type {SlashAttributes['use-stems']}. */
  getUseStems(): 'yes' | 'no' | null {
    return this.attributes['use-stems'];
  }
  /** Sets @type {SlashAttributes['use-stems']}. */
  setUseStems(useStems: 'yes' | 'no' | null): Slash {
    this.attributes['use-stems'] = useStems;
    return this;
  }
  /** Gets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
  getValue(): [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null {
    return this.contents[0];
  }
  /** Sets @type {[[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null}. */
  setValue(value: [[SlashType, Array<SlashDot>] | null, Array<ExceptVoice>] | null): this {
    this.contents[0] = value;
    return this;
  }
}

export type MeasureStyleAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Allows a measure style to apply to only the specified staff in the part. If absent, the measure style applies
   * to all staves in the part.
   */
  number: number | null;
};

export type MeasureStyleContents = [MultipleRest | MeasureRepeat | BeatRepeat | Slash];

/**
 * The `<measure-style>` element
 *
 * Parent element: `<attributes>`
 *
 * The `<measure-style>` element indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
 *
 * The `<multiple-rest>` and `<measure-repeat>` elements indicate the number of measures covered in the element content. The `<beat-repeat>` and `<slash>` elements can cover partial measures. All but the multiple-rest element use a type attribute to indicate starting and stopping the use of the style.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-style/}
 */
export class MeasureStyle implements XMLElement<'measure-style', MeasureStyleAttributes, MeasureStyleContents> {
  static readonly schema = {
    name: 'measure-style',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      number: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
    },
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'choices', choices: [MultipleRest, MeasureRepeat, BeatRepeat, Slash] },
      },
    ],
  } as const;

  readonly schema = MeasureStyle.schema;

  attributes: MeasureStyleAttributes;
  contents: MeasureStyleContents;

  constructor(opts?: { attributes?: Partial<MeasureStyleAttributes>; contents?: MeasureStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureStyle.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureStyle.schema.contents);
  }
  /** Gets @type {MeasureStyleAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {MeasureStyleAttributes['color']}. */
  setColor(color: string | null): MeasureStyle {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {MeasureStyleAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {MeasureStyleAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): MeasureStyle {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {MeasureStyleAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {MeasureStyleAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): MeasureStyle {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {MeasureStyleAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {MeasureStyleAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): MeasureStyle {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {MeasureStyleAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {MeasureStyleAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): MeasureStyle {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {MeasureStyleAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {MeasureStyleAttributes['id']}. */
  setId(id: string | null): MeasureStyle {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {MeasureStyleAttributes['number']}. */
  getNumber(): number | null {
    return this.attributes['number'];
  }
  /** Sets @type {MeasureStyleAttributes['number']}. */
  setNumber(number: number | null): MeasureStyle {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {MultipleRest | MeasureRepeat | BeatRepeat | Slash}. */
  getValue(): MultipleRest | MeasureRepeat | BeatRepeat | Slash {
    return this.contents[0];
  }
  /** Sets @type {MultipleRest | MeasureRepeat | BeatRepeat | Slash}. */
  setValue(value: MultipleRest | MeasureRepeat | BeatRepeat | Slash): this {
    this.contents[0] = value;
    return this;
  }
}

export type Transposes = Array<Transpose>;

export type ForParts = Array<ForPart>;

export type AttributesAttributes = Record<string, unknown>;

export type AttributesContents = [
  Footnote | null,
  Level | null,
  Divisions | null,
  Array<Key>,
  Array<Time>,
  Staves | null,
  PartSymbol | null,
  Instruments | null,
  Array<Clef>,
  Array<StaffDetails>,
  Transposes | ForParts,
  Array<Directive>,
  Array<MeasureStyle>,
];

/**
 * The `<attributes>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<attributes>` element contains musical information that typically changes on measure boundaries. This includes
 * key and time signatures, clefs, transpositions, and staving. When attributes are changed mid-measure, it affects the
 * music in score order, not in MusicXML document order.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/attributes/}
 */
export class Attributes implements XMLElement<'attributes', AttributesAttributes, AttributesContents> {
  static readonly schema = {
    name: 'attributes',
    attributes: {},
    contents: [
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Divisions },
      { type: 'label', label: 'keys', value: { type: 'zeroOrMore', value: Key } },
      { type: 'label', label: 'times', value: { type: 'zeroOrMore', value: Time } },
      { type: 'optional', value: Staves },
      { type: 'optional', value: PartSymbol },
      { type: 'optional', value: Instruments },
      { type: 'label', label: 'clefs', value: { type: 'zeroOrMore', value: Clef } },
      { type: 'label', label: 'staff-details', value: { type: 'zeroOrMore', value: StaffDetails } },
      {
        type: 'label',
        label: 'transpositions',
        value: {
          type: 'choices',
          choices: [
            { type: 'label', label: 'transposes', value: { type: 'zeroOrMore', value: Transpose } },
            { type: 'label', label: 'for-parts', value: { type: 'zeroOrMore', value: ForPart } },
          ],
        },
      },
      { type: 'label', label: 'directives', value: { type: 'zeroOrMore', value: Directive } },
      { type: 'label', label: 'measure-styles', value: { type: 'zeroOrMore', value: MeasureStyle } },
    ],
  } as const;

  readonly schema = Attributes.schema;

  attributes: AttributesAttributes;
  contents: AttributesContents;

  constructor(opts?: { attributes?: Partial<AttributesAttributes>; contents?: AttributesContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Attributes.schema);
    this.contents = opts?.contents ?? operations.zero(Attributes.schema.contents);
  }

  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[0];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[0] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[1];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[1] = level;
    return this;
  }
  /** Gets @type {Divisions | null}. */
  getDivisions(): Divisions | null {
    return this.contents[2];
  }
  /** Sets @type {Divisions | null}. */
  setDivisions(divisions: Divisions | null): this {
    this.contents[2] = divisions;
    return this;
  }
  /** Gets @type {Array<Key>}. */
  getKeys(): Array<Key> {
    return this.contents[3];
  }
  /** Sets @type {Array<Key>}. */
  setKeys(keys: Array<Key>): this {
    this.contents[3] = keys;
    return this;
  }
  /** Gets @type {Array<Time>}. */
  getTimes(): Array<Time> {
    return this.contents[4];
  }
  /** Sets @type {Array<Time>}. */
  setTimes(times: Array<Time>): this {
    this.contents[4] = times;
    return this;
  }
  /** Gets @type {Staves | null}. */
  getStaves(): Staves | null {
    return this.contents[5];
  }
  /** Sets @type {Staves | null}. */
  setStaves(staves: Staves | null): this {
    this.contents[5] = staves;
    return this;
  }
  /** Gets @type {PartSymbol | null}. */
  getPartSymbol(): PartSymbol | null {
    return this.contents[6];
  }
  /** Sets @type {PartSymbol | null}. */
  setPartSymbol(partSymbol: PartSymbol | null): this {
    this.contents[6] = partSymbol;
    return this;
  }
  /** Gets @type {Instruments | null}. */
  getInstruments(): Instruments | null {
    return this.contents[7];
  }
  /** Sets @type {Instruments | null}. */
  setInstruments(instruments: Instruments | null): this {
    this.contents[7] = instruments;
    return this;
  }
  /** Gets @type {Array<Clef>}. */
  getClefs(): Array<Clef> {
    return this.contents[8];
  }
  /** Sets @type {Array<Clef>}. */
  setClefs(clefs: Array<Clef>): this {
    this.contents[8] = clefs;
    return this;
  }
  /** Gets @type {Array<StaffDetails>}. */
  getStaffDetails(): Array<StaffDetails> {
    return this.contents[9];
  }
  /** Sets @type {Array<StaffDetails>}. */
  setStaffDetails(staffDetails: Array<StaffDetails>): this {
    this.contents[9] = staffDetails;
    return this;
  }
  /** Gets @type {Transposes | ForParts}. */
  getTranspositions(): Transposes | ForParts {
    return this.contents[10];
  }
  /** Sets @type {Transposes | ForParts}. */
  setTranspositions(transpositions: Transposes | ForParts): this {
    this.contents[10] = transpositions;
    return this;
  }
  /** Gets @type {Array<Directive>}. */
  getDirectives(): Array<Directive> {
    return this.contents[11];
  }
  /** Sets @type {Array<Directive>}. */
  setDirectives(directives: Array<Directive>): this {
    this.contents[11] = directives;
    return this;
  }
  /** Gets @type {Array<MeasureStyle>}. */
  getMeasureStyles(): Array<MeasureStyle> {
    return this.contents[12];
  }
  /** Sets @type {Array<MeasureStyle>}. */
  setMeasureStyles(measureStyles: Array<MeasureStyle>): this {
    this.contents[12] = measureStyles;
    return this;
  }
}

export type RootStepAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates how the root should appear in a score if not using the element contents.
   */
  text: string | null;
};

export type RootStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

/**
 * The `<root-step>` element
 *
 * Parent element: `<root>`
 *
 * The `<root-step>` element represents the pitch step of the root of the current chord within the harmony element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/root-step/}
 */
export class RootStep implements XMLElement<'root-step', RootStepAttributes, RootStepContents> {
  static readonly schema = {
    name: 'root-step',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'label', label: 'step', value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] } },
    ],
  } as const;

  readonly schema = RootStep.schema;

  attributes: RootStepAttributes;
  contents: RootStepContents;

  constructor(opts?: { attributes?: Partial<RootStepAttributes>; contents?: RootStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, RootStep.schema);
    this.contents = opts?.contents ?? operations.zero(RootStep.schema.contents);
  }
  /** Gets @type {RootStepAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {RootStepAttributes['color']}. */
  setColor(color: string | null): RootStep {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {RootStepAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {RootStepAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): RootStep {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {RootStepAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {RootStepAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): RootStep {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {RootStepAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {RootStepAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): RootStep {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {RootStepAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {RootStepAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): RootStep {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {RootStepAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {RootStepAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): RootStep {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {RootStepAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {RootStepAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): RootStep {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {RootStepAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {RootStepAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): RootStep {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {RootStepAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {RootStepAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): RootStep {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {RootStepAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {RootStepAttributes['text']}. */
  setText(text: string | null): RootStep {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): this {
    this.contents[0] = step;
    return this;
  }
}

export type RootAlterAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether the alteration should appear to the left or the right of the step. It is right if not specified.
   */
  location: 'left' | 'right' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type RootAlterContents = [number];

/**
 * The `<root-alter>` element
 *
 * Parent element: `<root>`
 *
 * The `<root-alter>` element represents the chromatic alteration of the root of the current chord within the
 * `<harmony>` element. In some chord styles, the text for the `<root-step>` element may include `<root-alter>`
 * information. In that case, the print-object attribute of the `<root-alter>` element can be set to no.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/root-alter/}
 */
export class RootAlter implements XMLElement<'root-alter', RootAlterAttributes, RootAlterContents> {
  static readonly schema = {
    name: 'root-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = RootAlter.schema;

  attributes: RootAlterAttributes;
  contents: RootAlterContents;

  constructor(opts?: { attributes?: Partial<RootAlterAttributes>; contents?: RootAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, RootAlter.schema);
    this.contents = opts?.contents ?? operations.zero(RootAlter.schema.contents);
  }
  /** Gets @type {RootAlterAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {RootAlterAttributes['color']}. */
  setColor(color: string | null): RootAlter {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {RootAlterAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {RootAlterAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): RootAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {RootAlterAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {RootAlterAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): RootAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {RootAlterAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {RootAlterAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): RootAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {RootAlterAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {RootAlterAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): RootAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {RootAlterAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {RootAlterAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): RootAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {RootAlterAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {RootAlterAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): RootAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {RootAlterAttributes['location']}. */
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  /** Sets @type {RootAlterAttributes['location']}. */
  setLocation(location: 'left' | 'right' | null): RootAlter {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {RootAlterAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {RootAlterAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): RootAlter {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {RootAlterAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {RootAlterAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): RootAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {RootAlterAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {RootAlterAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): RootAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type RootAttributes = Record<string, unknown>;

export type RootContents = [RootStep, RootAlter | null];

/**
 * The `<root>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<root>` element indicates a pitch like C, D, E vs. a scale degree like 1, 2, 3. It is used with chord symbols in
 * popular music. The `<root>` element has a `<root-step>` and optional `<root-alter>` element similar to the `<step>`
 * and `<alter>` elements, but renamed to distinguish the different musical meanings.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/root/}
 */
export class Root implements XMLElement<'root', RootAttributes, RootContents> {
  static readonly schema = {
    name: 'root',
    attributes: {},
    contents: [
      { type: 'required', value: RootStep },
      { type: 'optional', value: RootAlter },
    ],
  } as const;

  readonly schema = Root.schema;

  attributes: RootAttributes;
  contents: RootContents;

  constructor(opts?: { attributes?: Partial<RootAttributes>; contents?: RootContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Root.schema);
    this.contents = opts?.contents ?? operations.zero(Root.schema.contents);
  }

  /** Gets @type {RootStep}. */
  getRootStep(): RootStep {
    return this.contents[0];
  }
  /** Sets @type {RootStep}. */
  setRootStep(rootStep: RootStep): this {
    this.contents[0] = rootStep;
    return this;
  }
  /** Gets @type {RootAlter | null}. */
  getRootAlter(): RootAlter | null {
    return this.contents[1];
  }
  /** Sets @type {RootAlter | null}. */
  setRootAlter(rootAlter: RootAlter | null): this {
    this.contents[1] = rootAlter;
    return this;
  }
}

export type NumeralRootAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates how the numeral should appear in the score. A `<numeral-root>` value of 5 with a `<kind>` of major
   * would have a text attribute of "V" if displayed as a Roman numeral, and "5" if displayed as a Nashville number.
   * The display is application-dependent if not specified.
   */
  text: string | null;
};

export type NumeralRootContents = [number];

/**
 * The `<numeral-root>` element
 *
 * Parent element: `<numeral>`
 *
 * The `<numeral-root>` element represents the Roman numeral or Nashville number as a positive integer from 1 to 7.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-root/}
 */
export class NumeralRoot implements XMLElement<'numeral-root', NumeralRootAttributes, NumeralRootContents> {
  static readonly schema = {
    name: 'numeral-root',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'required', value: { type: 'label', label: 'numeral-value', value: { type: 'int', min: 1, max: 7 } } },
    ],
  } as const;

  readonly schema = NumeralRoot.schema;

  attributes: NumeralRootAttributes;
  contents: NumeralRootContents;

  constructor(opts?: { attributes?: Partial<NumeralRootAttributes>; contents?: NumeralRootContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralRoot.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralRoot.schema.contents);
  }
  /** Gets @type {NumeralRootAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {NumeralRootAttributes['color']}. */
  setColor(color: string | null): NumeralRoot {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {NumeralRootAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): NumeralRoot {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {NumeralRootAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): NumeralRoot {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {NumeralRootAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): NumeralRoot {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {NumeralRootAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): NumeralRoot {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {NumeralRootAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): NumeralRoot {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {NumeralRootAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): NumeralRoot {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {NumeralRootAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): NumeralRoot {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {NumeralRootAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): NumeralRoot {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {NumeralRootAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {NumeralRootAttributes['text']}. */
  setText(text: string | null): NumeralRoot {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {number}. */
  getNumeralValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setNumeralValue(numeralValue: number): this {
    this.contents[0] = numeralValue;
    return this;
  }
}

export type NumeralAlterAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * The location attribute indicates whether the alteration should appear to the left or the right of the
   * `<numeral-root>`. It is left if not specified.
   */
  location: 'left' | 'right' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified. It can be used to hide an alteration
   * in cases such as when the MusicXML encoding of a 6 or 7 `<numeral-root>` in a minor key requires an alteration
   * that is not displayed.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates how the root should appear in a score if not using the element contents.
   */
  text: string | null;
};

export type NumeralAlterContents = [number];

/**
 * The `<numeral-alter>` element
 *
 * Parent element: `<numeral>`
 *
 * The `<numeral-alter>` element represents an alteration to the `<numeral-root>`, similar to the `<alter>` element for a `<pitch>`.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-alter/}
 */
export class NumeralAlter implements XMLElement<'numeral-alter', NumeralAlterAttributes, NumeralAlterContents> {
  static readonly schema = {
    name: 'numeral-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = NumeralAlter.schema;

  attributes: NumeralAlterAttributes;
  contents: NumeralAlterContents;

  constructor(opts?: { attributes?: Partial<NumeralAlterAttributes>; contents?: NumeralAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralAlter.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralAlter.schema.contents);
  }
  /** Gets @type {NumeralAlterAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {NumeralAlterAttributes['color']}. */
  setColor(color: string | null): NumeralAlter {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {NumeralAlterAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): NumeralAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {NumeralAlterAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): NumeralAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {NumeralAlterAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): NumeralAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {NumeralAlterAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): NumeralAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {NumeralAlterAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): NumeralAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {NumeralAlterAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): NumeralAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['location']}. */
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  /** Sets @type {NumeralAlterAttributes['location']}. */
  setLocation(location: 'left' | 'right' | null): NumeralAlter {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {NumeralAlterAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): NumeralAlter {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {NumeralAlterAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): NumeralAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {NumeralAlterAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): NumeralAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {NumeralAlterAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {NumeralAlterAttributes['text']}. */
  setText(text: string | null): NumeralAlter {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type NumeralFifthsAttributes = Record<string, unknown>;

export type NumeralFifthsContents = [number];

/**
 * The `<numeral-fifths>` element
 *
 * Parent element: `<numeral-key>`
 *
 * The `<numeral-fifths>` element specifies the key in the same way as the `<fifths>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-fifths/}
 */
export class NumeralFifths implements XMLElement<'numeral-fifths', NumeralFifthsAttributes, NumeralFifthsContents> {
  static readonly schema = {
    name: 'numeral-fifths',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'int', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = NumeralFifths.schema;

  attributes: NumeralFifthsAttributes;
  contents: NumeralFifthsContents;

  constructor(opts?: { attributes?: Partial<NumeralFifthsAttributes>; contents?: NumeralFifthsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralFifths.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralFifths.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type NumeralModeAttributes = Record<string, unknown>;

export type NumeralModeContents = ['major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'];

/**
 * The `<numeral-mode>` element
 *
 * Parent element: `<numeral-key>`
 *
 * The `<numeral-mode>` specifies the scale that is used to interpret the `<numeral-root>` element values.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-mode/}
 */
export class NumeralMode implements XMLElement<'numeral-mode', NumeralModeAttributes, NumeralModeContents> {
  static readonly schema = {
    name: 'numeral-mode',
    attributes: {},
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'numeral-mode',
          value: { type: 'choices', choices: ['major', 'harmonic minor', 'melodic minor', 'minor', 'natural minor'] },
        },
      },
    ],
  } as const;

  readonly schema = NumeralMode.schema;

  attributes: NumeralModeAttributes;
  contents: NumeralModeContents;

  constructor(opts?: { attributes?: Partial<NumeralModeAttributes>; contents?: NumeralModeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralMode.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralMode.schema.contents);
  }

  /** Gets @type {'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'}. */
  getNumeralMode(): 'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor' {
    return this.contents[0];
  }
  /** Sets @type {'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'}. */
  setNumeralMode(numeralMode: 'major' | 'harmonic minor' | 'melodic minor' | 'minor' | 'natural minor'): this {
    this.contents[0] = numeralMode;
    return this;
  }
}

export type NumeralKeyAttributes = {
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
};

export type NumeralKeyContents = [NumeralFifths, NumeralMode];

/**
 * The `<numeral-key>` element
 *
 * Parent element: `<numeral>`
 *
 * The `<numeral-key>` element is used when the key for the numeral is different than the key specified by the key
 * signature.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral-key/}
 */
export class NumeralKey implements XMLElement<'numeral-key', NumeralKeyAttributes, NumeralKeyContents> {
  static readonly schema = {
    name: 'numeral-key',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      { type: 'required', value: NumeralFifths },
      { type: 'required', value: NumeralMode },
    ],
  } as const;

  readonly schema = NumeralKey.schema;

  attributes: NumeralKeyAttributes;
  contents: NumeralKeyContents;

  constructor(opts?: { attributes?: Partial<NumeralKeyAttributes>; contents?: NumeralKeyContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, NumeralKey.schema);
    this.contents = opts?.contents ?? operations.zero(NumeralKey.schema.contents);
  }
  /** Gets @type {NumeralKeyAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {NumeralKeyAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): NumeralKey {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {NumeralFifths}. */
  getNumeralFifths(): NumeralFifths {
    return this.contents[0];
  }
  /** Sets @type {NumeralFifths}. */
  setNumeralFifths(numeralFifths: NumeralFifths): this {
    this.contents[0] = numeralFifths;
    return this;
  }
  /** Gets @type {NumeralMode}. */
  getNumeralMode(): NumeralMode {
    return this.contents[1];
  }
  /** Sets @type {NumeralMode}. */
  setNumeralMode(numeralMode: NumeralMode): this {
    this.contents[1] = numeralMode;
    return this;
  }
}

export type NumeralAttributes = Record<string, unknown>;

export type NumeralContents = [NumeralRoot, NumeralAlter | null, NumeralKey | null];

/**
 * The `<numeral>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<numeral>` element represents the Roman numeral or Nashville number part of a harmony. It requires that the key
 * be specified in the encoding, either with a `<key>` or `<numeral-key>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/numeral/}
 */
export class Numeral implements XMLElement<'numeral', NumeralAttributes, NumeralContents> {
  static readonly schema = {
    name: 'numeral',
    attributes: {},
    contents: [
      { type: 'required', value: NumeralRoot },
      { type: 'optional', value: NumeralAlter },
      { type: 'optional', value: NumeralKey },
    ],
  } as const;

  readonly schema = Numeral.schema;

  attributes: NumeralAttributes;
  contents: NumeralContents;

  constructor(opts?: { attributes?: Partial<NumeralAttributes>; contents?: NumeralContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Numeral.schema);
    this.contents = opts?.contents ?? operations.zero(Numeral.schema.contents);
  }

  /** Gets @type {NumeralRoot}. */
  getNumeralRoot(): NumeralRoot {
    return this.contents[0];
  }
  /** Sets @type {NumeralRoot}. */
  setNumeralRoot(numeralRoot: NumeralRoot): this {
    this.contents[0] = numeralRoot;
    return this;
  }
  /** Gets @type {NumeralAlter | null}. */
  getNumeralAlter(): NumeralAlter | null {
    return this.contents[1];
  }
  /** Sets @type {NumeralAlter | null}. */
  setNumeralAlter(numeralAlter: NumeralAlter | null): this {
    this.contents[1] = numeralAlter;
    return this;
  }
  /** Gets @type {NumeralKey | null}. */
  getNumeralKey(): NumeralKey | null {
    return this.contents[2];
  }
  /** Sets @type {NumeralKey | null}. */
  setNumeralKey(numeralKey: NumeralKey | null): this {
    this.contents[2] = numeralKey;
    return this;
  }
}

export type FunctionAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type FunctionContents = [string];

/**
 * The `<function>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<function>` element represents classical functional harmony with an indication like I, II, III rather than C, D,
 * E. It represents the Roman numeral part of a functional harmony rather than the complete function itself. It has been
 * deprecated as of MusicXML 4.0 in favor of the <numeral> element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/function/}
 */
export class Function implements XMLElement<'function', FunctionAttributes, FunctionContents> {
  static readonly schema = {
    name: 'function',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Function.schema;

  attributes: FunctionAttributes;
  contents: FunctionContents;

  constructor(opts?: { attributes?: Partial<FunctionAttributes>; contents?: FunctionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Function.schema);
    this.contents = opts?.contents ?? operations.zero(Function.schema.contents);
  }
  /** Gets @type {FunctionAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FunctionAttributes['color']}. */
  setColor(color: string | null): Function {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FunctionAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FunctionAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Function {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FunctionAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FunctionAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Function {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FunctionAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FunctionAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Function {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FunctionAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FunctionAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Function {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FunctionAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FunctionAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Function {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FunctionAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FunctionAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Function {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FunctionAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FunctionAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Function {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FunctionAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FunctionAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Function {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type KindAttributes = {
  /**
   * The bracket-degrees attribute is yes if all the degrees should be in a bracket. The default is
   * implementation-dependent.
   */
  'bracket-degrees': 'yes' | 'no' | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * The parentheses-degrees attribute is yes if all the degrees should be in parentheses. The default is
   * implementation-dependent.
   */
  'parentheses-degrees': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * If yes, the `<degree>` elements should be stacked above each other. The default is implementation-dependent.
   */
  'stack-degrees': 'yes' | 'no' | null;
  /**
   * Describes how the `<kind>` should be spelled in a score. If the use-symbols attribute is yes, this value
   * follows the symbol. The default is implementation-dependent.
   */
  text: string | null;
  /**
   * The use-symbols attribute is yes if the `<kind>` should be represented when possible with harmony symbols
   * rather than letters and numbers. These symbols include:
   *
   * - major: a triangle, like Unicode 25B3
   * - minor: -, like Unicode 002D
   * - augmented: +, like Unicode 002B
   * - diminished: °, like Unicode 00B0
   * - half-diminished: ø, like Unicode 00F8
   *
   * The default is implementation-dependent.
   */
  'use-symbols': 'yes' | 'no' | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type KindContents = [
  | 'none'
  | 'augmented'
  | 'augmented-seventh'
  | 'diminished'
  | 'diminished-seventh'
  | 'dominant'
  | 'dominant-11th'
  | 'dominant-13th'
  | 'dominant-ninth'
  | 'French'
  | 'German'
  | 'half-diminished'
  | 'Italian'
  | 'major'
  | 'major-11th'
  | 'major-13th'
  | 'major-minor'
  | 'major-ninth'
  | 'major-seventh'
  | 'major-sixth'
  | 'minor'
  | 'minor-11th'
  | 'minor-13th'
  | 'minor-ninth'
  | 'minor-seventh'
  | 'minor-sixth'
  | 'Neapolitan'
  | 'other'
  | 'pedal'
  | 'power'
  | 'suspended-fourth'
  | 'suspended-second'
  | 'Tristan',
];

/**
 * The `<kind>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<kind>` element indicates the type of chord. The `<degree>` elements can then add, subtract, or alter from these
 * starting points
 *
 * The attributes are used to indicate the formatting of the symbol. Since the `<kind>` element is the constant in all
 * the harmony-chord element groups that can make up a polychord, many formatting attributes are here. The alignment
 * attributes are for the entire harmony-chord group of which this kind element is a part.
 *
 * For the major-minor `<kind>`, only the minor symbol is used when use-symbols is yes. The major symbol is set using
 * the symbol attribute in the `<degree-value>` element. The corresponding `<degree-alter>` value will usually be 0 in
 * this case.
 *
 * The text attribute may use strings such as "13sus" that refer to both the kind and one or more `<degree>` elements.
 * In this case, the corresponding `<degree>` elements should have the print-object attribute set to no to keep
 * redundant alterations from being displayed.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/kind/}
 */
export class Kind implements XMLElement<'kind', KindAttributes, KindContents> {
  static readonly schema = {
    name: 'kind',
    attributes: {
      'bracket-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'parentheses-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'stack-degrees': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      text: { type: 'optional', value: { type: 'string' } },
      'use-symbols': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'kind-value',
          value: {
            type: 'choices',
            choices: [
              'none',
              'augmented',
              'augmented-seventh',
              'diminished',
              'diminished-seventh',
              'dominant',
              'dominant-11th',
              'dominant-13th',
              'dominant-ninth',
              'French',
              'German',
              'half-diminished',
              'Italian',
              'major',
              'major-11th',
              'major-13th',
              'major-minor',
              'major-ninth',
              'major-seventh',
              'major-sixth',
              'minor',
              'minor-11th',
              'minor-13th',
              'minor-ninth',
              'minor-seventh',
              'minor-sixth',
              'Neapolitan',
              'other',
              'pedal',
              'power',
              'suspended-fourth',
              'suspended-second',
              'Tristan',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = Kind.schema;

  attributes: KindAttributes;
  contents: KindContents;

  constructor(opts?: { attributes?: Partial<KindAttributes>; contents?: KindContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Kind.schema);
    this.contents = opts?.contents ?? operations.zero(Kind.schema.contents);
  }
  /** Gets @type {KindAttributes['bracket-degrees']}. */
  getBracketDegrees(): 'yes' | 'no' | null {
    return this.attributes['bracket-degrees'];
  }
  /** Sets @type {KindAttributes['bracket-degrees']}. */
  setBracketDegrees(bracketDegrees: 'yes' | 'no' | null): Kind {
    this.attributes['bracket-degrees'] = bracketDegrees;
    return this;
  }
  /** Gets @type {KindAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {KindAttributes['color']}. */
  setColor(color: string | null): Kind {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {KindAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {KindAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Kind {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {KindAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {KindAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Kind {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {KindAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {KindAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Kind {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {KindAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {KindAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Kind {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {KindAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {KindAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Kind {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {KindAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {KindAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Kind {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {KindAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {KindAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Kind {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {KindAttributes['parentheses-degrees']}. */
  getParenthesesDegrees(): 'yes' | 'no' | null {
    return this.attributes['parentheses-degrees'];
  }
  /** Sets @type {KindAttributes['parentheses-degrees']}. */
  setParenthesesDegrees(parenthesesDegrees: 'yes' | 'no' | null): Kind {
    this.attributes['parentheses-degrees'] = parenthesesDegrees;
    return this;
  }
  /** Gets @type {KindAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {KindAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Kind {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {KindAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {KindAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Kind {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {KindAttributes['stack-degrees']}. */
  getStackDegrees(): 'yes' | 'no' | null {
    return this.attributes['stack-degrees'];
  }
  /** Sets @type {KindAttributes['stack-degrees']}. */
  setStackDegrees(stackDegrees: 'yes' | 'no' | null): Kind {
    this.attributes['stack-degrees'] = stackDegrees;
    return this;
  }
  /** Gets @type {KindAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {KindAttributes['text']}. */
  setText(text: string | null): Kind {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {KindAttributes['use-symbols']}. */
  getUseSymbols(): 'yes' | 'no' | null {
    return this.attributes['use-symbols'];
  }
  /** Sets @type {KindAttributes['use-symbols']}. */
  setUseSymbols(useSymbols: 'yes' | 'no' | null): Kind {
    this.attributes['use-symbols'] = useSymbols;
    return this;
  }
  /** Gets @type {KindAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {KindAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): Kind {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {'none' | 'augmented' | 'augmented-seventh' | 'diminished' | 'diminished-seventh' | 'dominant' | 'dominant-11th' | 'dominant-13th' | 'dominant-ninth' | 'French' | 'German' | 'half-diminished' | 'Italian' | 'major' | 'major-11th' | 'major-13th' | 'major-minor' | 'major-ninth' | 'major-seventh' | 'major-sixth' | 'minor' | 'minor-11th' | 'minor-13th' | 'minor-ninth' | 'minor-seventh' | 'minor-sixth' | 'Neapolitan' | 'other' | 'pedal' | 'power' | 'suspended-fourth' | 'suspended-second' | 'Tristan'}. */
  getKindValue():
    | 'none'
    | 'augmented'
    | 'augmented-seventh'
    | 'diminished'
    | 'diminished-seventh'
    | 'dominant'
    | 'dominant-11th'
    | 'dominant-13th'
    | 'dominant-ninth'
    | 'French'
    | 'German'
    | 'half-diminished'
    | 'Italian'
    | 'major'
    | 'major-11th'
    | 'major-13th'
    | 'major-minor'
    | 'major-ninth'
    | 'major-seventh'
    | 'major-sixth'
    | 'minor'
    | 'minor-11th'
    | 'minor-13th'
    | 'minor-ninth'
    | 'minor-seventh'
    | 'minor-sixth'
    | 'Neapolitan'
    | 'other'
    | 'pedal'
    | 'power'
    | 'suspended-fourth'
    | 'suspended-second'
    | 'Tristan' {
    return this.contents[0];
  }
  /** Sets @type {'none' | 'augmented' | 'augmented-seventh' | 'diminished' | 'diminished-seventh' | 'dominant' | 'dominant-11th' | 'dominant-13th' | 'dominant-ninth' | 'French' | 'German' | 'half-diminished' | 'Italian' | 'major' | 'major-11th' | 'major-13th' | 'major-minor' | 'major-ninth' | 'major-seventh' | 'major-sixth' | 'minor' | 'minor-11th' | 'minor-13th' | 'minor-ninth' | 'minor-seventh' | 'minor-sixth' | 'Neapolitan' | 'other' | 'pedal' | 'power' | 'suspended-fourth' | 'suspended-second' | 'Tristan'}. */
  setKindValue(
    kindValue:
      | 'none'
      | 'augmented'
      | 'augmented-seventh'
      | 'diminished'
      | 'diminished-seventh'
      | 'dominant'
      | 'dominant-11th'
      | 'dominant-13th'
      | 'dominant-ninth'
      | 'French'
      | 'German'
      | 'half-diminished'
      | 'Italian'
      | 'major'
      | 'major-11th'
      | 'major-13th'
      | 'major-minor'
      | 'major-ninth'
      | 'major-seventh'
      | 'major-sixth'
      | 'minor'
      | 'minor-11th'
      | 'minor-13th'
      | 'minor-ninth'
      | 'minor-seventh'
      | 'minor-sixth'
      | 'Neapolitan'
      | 'other'
      | 'pedal'
      | 'power'
      | 'suspended-fourth'
      | 'suspended-second'
      | 'Tristan'
  ): this {
    this.contents[0] = kindValue;
    return this;
  }
}

export type InversionAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates how the inversion should be displayed in a score.
   */
  text: string | null;
};

export type InversionContents = [number];

/**
 * The `<inversion>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<inversion>` element represents harmony inversions. The value is a number indicating which inversion is used: 0
 * for root position, 1 for first inversion, etc.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/inversion/}
 */
export class Inversion implements XMLElement<'inversion', InversionAttributes, InversionContents> {
  static readonly schema = {
    name: 'inversion',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'label', label: 'inversion', value: { type: 'required', value: { type: 'int', min: 0, max: Infinity } } },
    ],
  } as const;

  readonly schema = Inversion.schema;

  attributes: InversionAttributes;
  contents: InversionContents;

  constructor(opts?: { attributes?: Partial<InversionAttributes>; contents?: InversionContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Inversion.schema);
    this.contents = opts?.contents ?? operations.zero(Inversion.schema.contents);
  }
  /** Gets @type {InversionAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {InversionAttributes['color']}. */
  setColor(color: string | null): Inversion {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {InversionAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {InversionAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Inversion {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {InversionAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {InversionAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Inversion {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {InversionAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {InversionAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Inversion {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {InversionAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {InversionAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Inversion {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {InversionAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {InversionAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Inversion {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {InversionAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {InversionAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Inversion {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {InversionAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {InversionAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Inversion {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {InversionAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {InversionAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Inversion {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {InversionAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {InversionAttributes['text']}. */
  setText(text: string | null): Inversion {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {number}. */
  getInversion(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setInversion(inversion: number): this {
    this.contents[0] = inversion;
    return this;
  }
}

export type BassSeparatorAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type BassSeparatorContents = [string];

/**
 * The `<bass-separator>` element
 *
 * Parent element: `<bass>`
 *
 * The `<bass-separator>` element indicates that text, rather than a line or slash, separates the bass from what
 * precedes it.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass-separator/}
 */
export class BassSeparator implements XMLElement<'bass-separator', BassSeparatorAttributes, BassSeparatorContents> {
  static readonly schema = {
    name: 'bass-separator',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = BassSeparator.schema;

  attributes: BassSeparatorAttributes;
  contents: BassSeparatorContents;

  constructor(opts?: { attributes?: Partial<BassSeparatorAttributes>; contents?: BassSeparatorContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BassSeparator.schema);
    this.contents = opts?.contents ?? operations.zero(BassSeparator.schema.contents);
  }
  /** Gets @type {BassSeparatorAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BassSeparatorAttributes['color']}. */
  setColor(color: string | null): BassSeparator {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {BassSeparatorAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): BassSeparator {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {BassSeparatorAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): BassSeparator {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {BassSeparatorAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): BassSeparator {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {BassSeparatorAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BassSeparator {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {BassSeparatorAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BassSeparator {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {BassSeparatorAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BassSeparator {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {BassSeparatorAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): BassSeparator {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {BassSeparatorAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {BassSeparatorAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): BassSeparator {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type BassStepAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates how the bass should appear in a score if not using the element contents.
   */
  text: string | null;
};

export type BassStepContents = ['A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'];

/**
 * The `<bass-step>` element
 *
 * Parent element: `<bass>`
 *
 * The `<bass-step>` element represents the pitch step of the bass of the current chord within the harmony element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass-step/}
 */
export class BassStep implements XMLElement<'bass-step', BassStepAttributes, BassStepContents> {
  static readonly schema = {
    name: 'bass-step',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'step',
          value: { type: 'choices', choices: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        },
      },
    ],
  } as const;

  readonly schema = BassStep.schema;

  attributes: BassStepAttributes;
  contents: BassStepContents;

  constructor(opts?: { attributes?: Partial<BassStepAttributes>; contents?: BassStepContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BassStep.schema);
    this.contents = opts?.contents ?? operations.zero(BassStep.schema.contents);
  }
  /** Gets @type {BassStepAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BassStepAttributes['color']}. */
  setColor(color: string | null): BassStep {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BassStepAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {BassStepAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): BassStep {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {BassStepAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {BassStepAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): BassStep {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {BassStepAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {BassStepAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): BassStep {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {BassStepAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {BassStepAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BassStep {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {BassStepAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {BassStepAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BassStep {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {BassStepAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {BassStepAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BassStep {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {BassStepAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {BassStepAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): BassStep {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {BassStepAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {BassStepAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): BassStep {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {BassStepAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {BassStepAttributes['text']}. */
  setText(text: string | null): BassStep {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  getStep(): 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' {
    return this.contents[0];
  }
  /** Sets @type {'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'}. */
  setStep(step: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G'): this {
    this.contents[0] = step;
    return this;
  }
}

export type BassAlterAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates whether the alteration should appear to the left or the right of the step. It is right if not
   * specified.
   */
  location: 'left' | 'right' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type BassAlterContents = [number];

/**
 * The `<bass-alter>` element
 *
 * Parent element: `<bass>`
 *
 * The `<bass-alter>` element represents the chromatic alteration of the `<bass>` of the current chord within the
 * `<harmony>` element. In some chord styles, the text for the `<bass-step>` element may include `<bass-alter>`
 * information. In that case, the print-object attribute of the `<bass-alter>` element can be set to no.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass-alter/}
 */
export class BassAlter implements XMLElement<'bass-alter', BassAlterAttributes, BassAlterContents> {
  static readonly schema = {
    name: 'bass-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [
      {
        type: 'required',
        value: { type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = BassAlter.schema;

  attributes: BassAlterAttributes;
  contents: BassAlterContents;

  constructor(opts?: { attributes?: Partial<BassAlterAttributes>; contents?: BassAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BassAlter.schema);
    this.contents = opts?.contents ?? operations.zero(BassAlter.schema.contents);
  }
  /** Gets @type {BassAlterAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BassAlterAttributes['color']}. */
  setColor(color: string | null): BassAlter {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {BassAlterAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {BassAlterAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): BassAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {BassAlterAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {BassAlterAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): BassAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {BassAlterAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {BassAlterAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): BassAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {BassAlterAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {BassAlterAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): BassAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {BassAlterAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {BassAlterAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): BassAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {BassAlterAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {BassAlterAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): BassAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {BassAlterAttributes['location']}. */
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  /** Sets @type {BassAlterAttributes['location']}. */
  setLocation(location: 'left' | 'right' | null): BassAlter {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {BassAlterAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {BassAlterAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): BassAlter {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {BassAlterAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {BassAlterAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): BassAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {BassAlterAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {BassAlterAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): BassAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type BassAttributes = {
  /**
   * Specifies where the bass is displayed relative to what precedes it.
   */
  arrangement: 'horizontal' | 'vertical' | 'diagonal' | null;
};

export type BassContents = [BassSeparator | null, BassStep, BassAlter | null];

/**
 * The `<bass>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<bass>` element is used to indicate a bass note in popular music chord symbols, e.g. G/C. It is generally not
 * used in functional harmony, as inversion is generally not used in pop chord symbols. As with `<root>`, it is divided
 * into step and alter elements, similar to pitches.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bass/}
 */
export class Bass implements XMLElement<'bass', BassAttributes, BassContents> {
  static readonly schema = {
    name: 'bass',
    attributes: {
      arrangement: { type: 'optional', value: { type: 'choices', choices: ['horizontal', 'vertical', 'diagonal'] } },
    },
    contents: [
      { type: 'optional', value: BassSeparator },
      { type: 'required', value: BassStep },
      { type: 'optional', value: BassAlter },
    ],
  } as const;

  readonly schema = Bass.schema;

  attributes: BassAttributes;
  contents: BassContents;

  constructor(opts?: { attributes?: Partial<BassAttributes>; contents?: BassContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Bass.schema);
    this.contents = opts?.contents ?? operations.zero(Bass.schema.contents);
  }
  /** Gets @type {BassAttributes['arrangement']}. */
  getArrangement(): 'horizontal' | 'vertical' | 'diagonal' | null {
    return this.attributes['arrangement'];
  }
  /** Sets @type {BassAttributes['arrangement']}. */
  setArrangement(arrangement: 'horizontal' | 'vertical' | 'diagonal' | null): Bass {
    this.attributes['arrangement'] = arrangement;
    return this;
  }
  /** Gets @type {BassSeparator | null}. */
  getBassSeparator(): BassSeparator | null {
    return this.contents[0];
  }
  /** Sets @type {BassSeparator | null}. */
  setBassSeparator(bassSeparator: BassSeparator | null): this {
    this.contents[0] = bassSeparator;
    return this;
  }
  /** Gets @type {BassStep}. */
  getBassStep(): BassStep {
    return this.contents[1];
  }
  /** Sets @type {BassStep}. */
  setBassStep(bassStep: BassStep): this {
    this.contents[1] = bassStep;
    return this;
  }
  /** Gets @type {BassAlter | null}. */
  getBassAlter(): BassAlter | null {
    return this.contents[2];
  }
  /** Sets @type {BassAlter | null}. */
  setBassAlter(bassAlter: BassAlter | null): this {
    this.contents[2] = bassAlter;
    return this;
  }
}

export type DegreeValueAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates that a symbol should be used in specifying the degree.
   */
  symbol: 'major' | 'minor' | 'augmented' | 'diminished' | 'half-diminished' | null;
  /**
   * Specifies how the value of the degree should be displayed. If the symbol attribute is present, the value of the
   * text attribute follows the symbol.
   */
  text: string | null;
};

export type DegreeValueContents = [number];

/**
 * The `<degree-value>` element
 *
 * Parent element: `<degree>`
 *
 * The content of the `<degree-value>` element is a number indicating the degree of the chord (1 for the root, 3 for
 * third, etc).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree-value/}
 */
export class DegreeValue implements XMLElement<'degree-value', DegreeValueAttributes, DegreeValueContents> {
  static readonly schema = {
    name: 'degree-value',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      symbol: {
        type: 'optional',
        value: { type: 'choices', choices: ['major', 'minor', 'augmented', 'diminished', 'half-diminished'] },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'label', label: 'value', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
    ],
  } as const;

  readonly schema = DegreeValue.schema;

  attributes: DegreeValueAttributes;
  contents: DegreeValueContents;

  constructor(opts?: { attributes?: Partial<DegreeValueAttributes>; contents?: DegreeValueContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DegreeValue.schema);
    this.contents = opts?.contents ?? operations.zero(DegreeValue.schema.contents);
  }
  /** Gets @type {DegreeValueAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DegreeValueAttributes['color']}. */
  setColor(color: string | null): DegreeValue {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DegreeValueAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DegreeValue {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DegreeValueAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DegreeValue {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DegreeValueAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DegreeValue {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DegreeValueAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DegreeValue {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DegreeValueAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DegreeValue {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DegreeValueAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DegreeValue {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DegreeValueAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DegreeValue {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DegreeValueAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DegreeValue {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['symbol']}. */
  getSymbol(): 'major' | 'minor' | 'augmented' | 'diminished' | 'half-diminished' | null {
    return this.attributes['symbol'];
  }
  /** Sets @type {DegreeValueAttributes['symbol']}. */
  setSymbol(symbol: 'major' | 'minor' | 'augmented' | 'diminished' | 'half-diminished' | null): DegreeValue {
    this.attributes['symbol'] = symbol;
    return this;
  }
  /** Gets @type {DegreeValueAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {DegreeValueAttributes['text']}. */
  setText(text: string | null): DegreeValue {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type DegreeAlterAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Indicates if plus and minus symbols should be used instead of sharp and flat symbols to display the degree
   * alteration. It is no if not specified.
   */
  'plus-minus': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type DegreeAlterContents = [number];

/**
 * The `<degree-alter>` element
 *
 * Parent element: `<degree>`
 *
 * The `<degree-alter>` element represents the chromatic alteration for the current degree. If the `<degree-type>` value
 * is alter or subtract, the `<degree-alter>` value is relative to the degree already in the chord based on its kind
 * element. If the `<degree-type>` value is add, the `<degree-alter>` is relative to a dominant chord (major and perfect
 * intervals except for a minor seventh).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree-alter/}
 */
export class DegreeAlter implements XMLElement<'degree-alter', DegreeAlterAttributes, DegreeAlterContents> {
  static readonly schema = {
    name: 'degree-alter',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'plus-minus': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'label', label: 'semitones', value: { type: 'float', min: -Infinity, max: Infinity } }],
  } as const;

  readonly schema = DegreeAlter.schema;

  attributes: DegreeAlterAttributes;
  contents: DegreeAlterContents;

  constructor(opts?: { attributes?: Partial<DegreeAlterAttributes>; contents?: DegreeAlterContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DegreeAlter.schema);
    this.contents = opts?.contents ?? operations.zero(DegreeAlter.schema.contents);
  }
  /** Gets @type {DegreeAlterAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DegreeAlterAttributes['color']}. */
  setColor(color: string | null): DegreeAlter {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DegreeAlterAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DegreeAlter {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DegreeAlterAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DegreeAlter {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DegreeAlterAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DegreeAlter {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DegreeAlterAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DegreeAlter {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DegreeAlterAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DegreeAlter {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DegreeAlterAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DegreeAlter {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['plus-minus']}. */
  getPlusMinus(): 'yes' | 'no' | null {
    return this.attributes['plus-minus'];
  }
  /** Sets @type {DegreeAlterAttributes['plus-minus']}. */
  setPlusMinus(plusMinus: 'yes' | 'no' | null): DegreeAlter {
    this.attributes['plus-minus'] = plusMinus;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DegreeAlterAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DegreeAlter {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DegreeAlterAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DegreeAlterAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DegreeAlter {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {number}. */
  getSemitones(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSemitones(semitones: number): this {
    this.contents[0] = semitones;
    return this;
  }
}

export type DegreeTypeAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Specifies how the type of the degree should be displayed.
   */
  text: string | null;
};

export type DegreeTypeContents = ['add' | 'alter' | 'subtract'];

/**
 * The `<degree-type>` element
 *
 * Parent element: `<degree>`
 *
 * The `<degree-type>` element indicates if this degree is an addition, alteration, or subtraction relative to the
 * `<kind>` of the current chord. The value of the `<degree-type>` element affects the interpretation of the value of
 * the `<degree-alter>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree-type/}
 */
export class DegreeType implements XMLElement<'degree-type', DegreeTypeAttributes, DegreeTypeContents> {
  static readonly schema = {
    name: 'degree-type',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'degree-type-value',
          value: { type: 'choices', choices: ['add', 'alter', 'subtract'] },
        },
      },
    ],
  } as const;

  readonly schema = DegreeType.schema;

  attributes: DegreeTypeAttributes;
  contents: DegreeTypeContents;

  constructor(opts?: { attributes?: Partial<DegreeTypeAttributes>; contents?: DegreeTypeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, DegreeType.schema);
    this.contents = opts?.contents ?? operations.zero(DegreeType.schema.contents);
  }
  /** Gets @type {DegreeTypeAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {DegreeTypeAttributes['color']}. */
  setColor(color: string | null): DegreeType {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {DegreeTypeAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): DegreeType {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {DegreeTypeAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): DegreeType {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {DegreeTypeAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): DegreeType {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {DegreeTypeAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): DegreeType {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {DegreeTypeAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): DegreeType {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {DegreeTypeAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): DegreeType {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {DegreeTypeAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): DegreeType {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {DegreeTypeAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): DegreeType {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {DegreeTypeAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {DegreeTypeAttributes['text']}. */
  setText(text: string | null): DegreeType {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {'add' | 'alter' | 'subtract'}. */
  getDegreeTypeValue(): 'add' | 'alter' | 'subtract' {
    return this.contents[0];
  }
  /** Sets @type {'add' | 'alter' | 'subtract'}. */
  setDegreeTypeValue(degreeTypeValue: 'add' | 'alter' | 'subtract'): this {
    this.contents[0] = degreeTypeValue;
    return this;
  }
}

export type DegreeAttributes = {
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
};

export type DegreeContents = [DegreeValue, DegreeAlter, DegreeType];

/**
 * The `<degree>` element
 *
 * Parent element: `<harmony>`
 *
 * The `<degree>` element is used to add, alter, or subtract individual notes in the chord. The print-object attribute
 * can be used to keep the degree from printing separately when it has already taken into account in the text attribute
 * of the `<kind>` element.
 *
 * A harmony with a `<kind>` value of other can be spelled explicitly by using a series of `<degree>` elements together
 * with a `<root>`, `<numeral>`, or `<function>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/degree/}
 */
export class Degree implements XMLElement<'degree', DegreeAttributes, DegreeContents> {
  static readonly schema = {
    name: 'degree',
    attributes: { 'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } } },
    contents: [
      { type: 'required', value: DegreeValue },
      { type: 'required', value: DegreeAlter },
      { type: 'required', value: DegreeType },
    ],
  } as const;

  readonly schema = Degree.schema;

  attributes: DegreeAttributes;
  contents: DegreeContents;

  constructor(opts?: { attributes?: Partial<DegreeAttributes>; contents?: DegreeContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Degree.schema);
    this.contents = opts?.contents ?? operations.zero(Degree.schema.contents);
  }
  /** Gets @type {DegreeAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {DegreeAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Degree {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {DegreeValue}. */
  getDegreeValue(): DegreeValue {
    return this.contents[0];
  }
  /** Sets @type {DegreeValue}. */
  setDegreeValue(degreeValue: DegreeValue): this {
    this.contents[0] = degreeValue;
    return this;
  }
  /** Gets @type {DegreeAlter}. */
  getDegreeAlter(): DegreeAlter {
    return this.contents[1];
  }
  /** Sets @type {DegreeAlter}. */
  setDegreeAlter(degreeAlter: DegreeAlter): this {
    this.contents[1] = degreeAlter;
    return this;
  }
  /** Gets @type {DegreeType}. */
  getDegreeType(): DegreeType {
    return this.contents[2];
  }
  /** Sets @type {DegreeType}. */
  setDegreeType(degreeType: DegreeType): this {
    this.contents[2] = degreeType;
    return this;
  }
}

export type FrameStringsAttributes = Record<string, unknown>;

export type FrameStringsContents = [number];

/**
 * The `<frame-strings>` element
 *
 * Parent element: `<frame>`
 *
 * The `<frame-strings>` element gives the overall size of the frame in vertical lines (strings).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame-strings/}
 */
export class FrameStrings implements XMLElement<'frame-strings', FrameStringsAttributes, FrameStringsContents> {
  static readonly schema = {
    name: 'frame-strings',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'lines-size',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = FrameStrings.schema;

  attributes: FrameStringsAttributes;
  contents: FrameStringsContents;

  constructor(opts?: { attributes?: Partial<FrameStringsAttributes>; contents?: FrameStringsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FrameStrings.schema);
    this.contents = opts?.contents ?? operations.zero(FrameStrings.schema.contents);
  }

  /** Gets @type {number}. */
  getLinesSize(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setLinesSize(linesSize: number): this {
    this.contents[0] = linesSize;
    return this;
  }
}

export type FrameFretsAttributes = Record<string, unknown>;

export type FrameFretsContents = [number];

/**
 * The `<frame-frets>` element
 *
 * Parent element: `<frame>`
 *
 * The frame-frets element gives the overall size of the frame in horizontal spaces (frets).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame-frets/}
 */
export class FrameFrets implements XMLElement<'frame-frets', FrameFretsAttributes, FrameFretsContents> {
  static readonly schema = {
    name: 'frame-frets',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'space-size',
        value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = FrameFrets.schema;

  attributes: FrameFretsAttributes;
  contents: FrameFretsContents;

  constructor(opts?: { attributes?: Partial<FrameFretsAttributes>; contents?: FrameFretsContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FrameFrets.schema);
    this.contents = opts?.contents ?? operations.zero(FrameFrets.schema.contents);
  }

  /** Gets @type {number}. */
  getSpaceSize(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setSpaceSize(spaceSize: number): this {
    this.contents[0] = spaceSize;
    return this;
  }
}

export type FirstFretAttributes = {
  /**
   * Indicates whether the text appears to the left or right of the frame.
   */
  location: 'left' | 'right' | null;
  /**
   * Indicates how the first fret is represented in the fret diagram.
   */
  text: string | null;
};

export type FirstFretContents = [number];

/**
 * The `<first-fret>` element
 *
 * Parent element: `<frame>`
 *
 * The `<first-fret>` element indicates which fret is shown in the top space of the frame; it is fret 1 if the element
 * is not present.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/first-fret/}
 */
export class FirstFret implements XMLElement<'first-fret', FirstFretAttributes, FirstFretContents> {
  static readonly schema = {
    name: 'first-fret',
    attributes: {
      location: { type: 'optional', value: { type: 'choices', choices: ['left', 'right'] } },
      text: { type: 'optional', value: { type: 'string' } },
    },
    contents: [
      { type: 'label', label: 'fret', value: { type: 'required', value: { type: 'int', min: 1, max: Infinity } } },
    ],
  } as const;

  readonly schema = FirstFret.schema;

  attributes: FirstFretAttributes;
  contents: FirstFretContents;

  constructor(opts?: { attributes?: Partial<FirstFretAttributes>; contents?: FirstFretContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FirstFret.schema);
    this.contents = opts?.contents ?? operations.zero(FirstFret.schema.contents);
  }
  /** Gets @type {FirstFretAttributes['location']}. */
  getLocation(): 'left' | 'right' | null {
    return this.attributes['location'];
  }
  /** Sets @type {FirstFretAttributes['location']}. */
  setLocation(location: 'left' | 'right' | null): FirstFret {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {FirstFretAttributes['text']}. */
  getText(): string | null {
    return this.attributes['text'];
  }
  /** Sets @type {FirstFretAttributes['text']}. */
  setText(text: string | null): FirstFret {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {number}. */
  getFret(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setFret(fret: number): this {
    this.contents[0] = fret;
    return this;
  }
}

export type BarreAttributes = {
  /**
   * The start value indicates the lowest pitched string (e.g., the string with the highest MusicXML number). The stop
   * value indicates the highest pitched string.
   */
  type: 'start' | 'stop';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
};

export type BarreContents = [];

/**
 * The `<barre>` element
 *
 * Parent element: `<frame-note>`
 *
 * The `<barre>` element indicates placing a finger over multiple strings on a single fret.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/barre/}
 */
export class Barre implements XMLElement<'barre', BarreAttributes, BarreContents> {
  static readonly schema = {
    name: 'barre',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
    },
    contents: [],
  } as const;

  readonly schema = Barre.schema;

  attributes: BarreAttributes;
  contents: BarreContents;

  constructor(opts?: { attributes?: Partial<BarreAttributes>; contents?: BarreContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Barre.schema);
    this.contents = opts?.contents ?? operations.zero(Barre.schema.contents);
  }
  /** Gets @type {BarreAttributes['type']}. */
  getType(): 'start' | 'stop' {
    return this.attributes['type'];
  }
  /** Sets @type {BarreAttributes['type']}. */
  setType(type: 'start' | 'stop'): Barre {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {BarreAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BarreAttributes['color']}. */
  setColor(color: string | null): Barre {
    this.attributes['color'] = color;
    return this;
  }
}

export type FrameNoteAttributes = Record<string, unknown>;

export type FrameNoteContents = [String, Fret, Fingering | null, Barre | null];

/**
 * The `<frame-note>` element
 *
 * Parent element: `<frame>`
 *
 * The frame-note type represents each note included in the frame. An open string will have a fret value of 0, while a
 * muted string will not be associated with a frame-note element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame-note/}
 */
export class FrameNote implements XMLElement<'frame-note', FrameNoteAttributes, FrameNoteContents> {
  static readonly schema = {
    name: 'frame-note',
    attributes: {},
    contents: [
      { type: 'required', value: String },
      { type: 'required', value: Fret },
      { type: 'optional', value: Fingering },
      { type: 'optional', value: Barre },
    ],
  } as const;

  readonly schema = FrameNote.schema;

  attributes: FrameNoteAttributes;
  contents: FrameNoteContents;

  constructor(opts?: { attributes?: Partial<FrameNoteAttributes>; contents?: FrameNoteContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FrameNote.schema);
    this.contents = opts?.contents ?? operations.zero(FrameNote.schema.contents);
  }

  /** Gets @type {String}. */
  getString(): String {
    return this.contents[0];
  }
  /** Sets @type {String}. */
  setString(string: String): this {
    this.contents[0] = string;
    return this;
  }
  /** Gets @type {Fret}. */
  getFret(): Fret {
    return this.contents[1];
  }
  /** Sets @type {Fret}. */
  setFret(fret: Fret): this {
    this.contents[1] = fret;
    return this;
  }
  /** Gets @type {Fingering | null}. */
  getFingering(): Fingering | null {
    return this.contents[2];
  }
  /** Sets @type {Fingering | null}. */
  setFingering(fingering: Fingering | null): this {
    this.contents[2] = fingering;
    return this;
  }
  /** Gets @type {Barre | null}. */
  getBarre(): Barre | null {
    return this.contents[3];
  }
  /** Sets @type {Barre | null}. */
  setBarre(barre: Barre | null): this {
    this.contents[3] = barre;
    return this;
  }
}

export type FrameAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   *
   */
  height: number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   *
   */
  unplayed: string | null;
  /**
   * Indicates vertical alignment to the top, middle, or bottom of the image. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | null;
  /**
   *
   */
  width: number | null;
};

export type FrameContents = [FrameStrings, FrameFrets, FirstFret | null, Array<FrameNote>];

/**
 * The `<frame>` element
 *
 * Parent element: `<harmony>`
 *
 * The frame type represents a frame or fretboard diagram used together with a chord symbol. The representation is based on the NIFF guitar grid with additional information. The frame type's unplayed attribute indicates what to display above a string that has no associated frame-note element. Typical values are x and the empty string. If the attribute is not present, the display of the unplayed string is application-defined.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/frame/}
 */
export class Frame implements XMLElement<'frame', FrameAttributes, FrameContents> {
  static readonly schema = {
    name: 'frame',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      height: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      unplayed: { type: 'optional', value: { type: 'string' } },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom'] } },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [
      { type: 'required', value: FrameStrings },
      { type: 'required', value: FrameFrets },
      { type: 'optional', value: FirstFret },
      { type: 'label', label: 'frame-notes', value: { type: 'oneOrMore', value: FrameNote } },
    ],
  } as const;

  readonly schema = Frame.schema;

  attributes: FrameAttributes;
  contents: FrameContents;

  constructor(opts?: { attributes?: Partial<FrameAttributes>; contents?: FrameContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Frame.schema);
    this.contents = opts?.contents ?? operations.zero(Frame.schema.contents);
  }
  /** Gets @type {FrameAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FrameAttributes['color']}. */
  setColor(color: string | null): Frame {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FrameAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FrameAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Frame {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FrameAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FrameAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Frame {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FrameAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {FrameAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): Frame {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {FrameAttributes['height']}. */
  getHeight(): number | null {
    return this.attributes['height'];
  }
  /** Sets @type {FrameAttributes['height']}. */
  setHeight(height: number | null): Frame {
    this.attributes['height'] = height;
    return this;
  }
  /** Gets @type {FrameAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {FrameAttributes['id']}. */
  setId(id: string | null): Frame {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {FrameAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FrameAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Frame {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FrameAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FrameAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Frame {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FrameAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FrameAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Frame {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FrameAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FrameAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Frame {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FrameAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FrameAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Frame {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FrameAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FrameAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Frame {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {FrameAttributes['unplayed']}. */
  getUnplayed(): string | null {
    return this.attributes['unplayed'];
  }
  /** Sets @type {FrameAttributes['unplayed']}. */
  setUnplayed(unplayed: string | null): Frame {
    this.attributes['unplayed'] = unplayed;
    return this;
  }
  /** Gets @type {FrameAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {FrameAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | null): Frame {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {FrameAttributes['width']}. */
  getWidth(): number | null {
    return this.attributes['width'];
  }
  /** Sets @type {FrameAttributes['width']}. */
  setWidth(width: number | null): Frame {
    this.attributes['width'] = width;
    return this;
  }
  /** Gets @type {FrameStrings}. */
  getFrameStrings(): FrameStrings {
    return this.contents[0];
  }
  /** Sets @type {FrameStrings}. */
  setFrameStrings(frameStrings: FrameStrings): this {
    this.contents[0] = frameStrings;
    return this;
  }
  /** Gets @type {FrameFrets}. */
  getFrameFrets(): FrameFrets {
    return this.contents[1];
  }
  /** Sets @type {FrameFrets}. */
  setFrameFrets(frameFrets: FrameFrets): this {
    this.contents[1] = frameFrets;
    return this;
  }
  /** Gets @type {FirstFret | null}. */
  getFirstFret(): FirstFret | null {
    return this.contents[2];
  }
  /** Sets @type {FirstFret | null}. */
  setFirstFret(firstFret: FirstFret | null): this {
    this.contents[2] = firstFret;
    return this;
  }
  /** Gets @type {Array<FrameNote>}. */
  getFrameNotes(): Array<FrameNote> {
    return this.contents[3];
  }
  /** Sets @type {Array<FrameNote>}. */
  setFrameNotes(frameNotes: Array<FrameNote>): this {
    this.contents[3] = frameNotes;
    return this;
  }
}

export type HarmonyAttributes = {
  /**
   * Specifies how multiple harmony-chords are arranged relative to each other. Harmony-chords with vertical
   * arrangement are separated by horizontal lines. Harmony-chords with diagonal or horizontal arrangement are
   * separated by diagonal lines or slashes.
   */
  arrangement: 'horizontal' | 'vertical' | 'diagonal' | null;
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Specifies the printing of a frame or fretboard diagram.
   */
  'print-frame': 'yes' | 'no' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Distinguishes elements that are associated with a system rather than the particular part where the element
   * appears.
   */
  system: 'none' | 'only-top' | 'also-top' | null;
  /**
   * If there are alternate harmonies possible, this can be specified using multiple `<harmony>` elements
   * differentiated by type. Explicit harmonies have all note present in the music; implied have some notes missing
   * but implied; alternate represents alternate analyses.
   */
  type: 'alternate' | 'explicit' | 'implied' | null;
};

export type HarmonyContents = [
  Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>,
  Frame | null,
  Offset | null,
  Footnote | null,
  Level | null,
  Staff | null,
];

/**
 * The `<harmony>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<harmony>` element represents harmony analysis, including chord symbols in popular music as well as functional
 * harmony analysis in classical music.
 *
 * The print-object attribute controls whether or not anything is printed due to the `<harmony>` element. The print
 * suggestion attributes set the defaults for the harmony, but individual elements can override this with their own
 * values.
 *
 * A `<harmony>` element can contain many stacked chords (e.g. V of II). Each individual chord including a required
 * `<kind>` element is referred to as a harmony-chord. Stacked chords or secondary functions are represented using a
 * sequence of harmony-chords. For example, V of II would be represented by a harmony-chord with a 5 numeral followed by
 * a harmony-chord with a 2 numeral.
 *
 * A `<root>` is a pitch name like C, D, E, while a `<numeral>` is a scale degree like 1, 2, 3. The `<root>` element is
 * generally used with pop chord symbols, while the `<numeral>` element is generally used with classical functional
 * harmony and Nashville numbers. It is an either/or choice to avoid data inconsistency. The `<function>` element, which
 * represents Roman numerals with roman numeral text, has been deprecated as of MusicXML 4.0.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/harmony/}
 */
export class Harmony implements XMLElement<'harmony', HarmonyAttributes, HarmonyContents> {
  static readonly schema = {
    name: 'harmony',
    attributes: {
      arrangement: { type: 'optional', value: { type: 'choices', choices: ['horizontal', 'vertical', 'diagonal'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-frame': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
      type: { type: 'optional', value: { type: 'choices', choices: ['alternate', 'explicit', 'implied'] } },
    },
    contents: [
      {
        type: 'label',
        label: 'values',
        value: {
          type: 'oneOrMore',
          value: [
            { type: 'choices', choices: [Root, Numeral, Function] },
            { type: 'required', value: Kind },
            { type: 'optional', value: Inversion },
            { type: 'optional', value: Bass },
            { type: 'zeroOrMore', value: Degree },
          ],
        },
      },
      { type: 'optional', value: Frame },
      { type: 'optional', value: Offset },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: Staff },
    ],
  } as const;

  readonly schema = Harmony.schema;

  attributes: HarmonyAttributes;
  contents: HarmonyContents;

  constructor(opts?: { attributes?: Partial<HarmonyAttributes>; contents?: HarmonyContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Harmony.schema);
    this.contents = opts?.contents ?? operations.zero(Harmony.schema.contents);
  }
  /** Gets @type {HarmonyAttributes['arrangement']}. */
  getArrangement(): 'horizontal' | 'vertical' | 'diagonal' | null {
    return this.attributes['arrangement'];
  }
  /** Sets @type {HarmonyAttributes['arrangement']}. */
  setArrangement(arrangement: 'horizontal' | 'vertical' | 'diagonal' | null): Harmony {
    this.attributes['arrangement'] = arrangement;
    return this;
  }
  /** Gets @type {HarmonyAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {HarmonyAttributes['color']}. */
  setColor(color: string | null): Harmony {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {HarmonyAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {HarmonyAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Harmony {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {HarmonyAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {HarmonyAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Harmony {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {HarmonyAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {HarmonyAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Harmony {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {HarmonyAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {HarmonyAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Harmony {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {HarmonyAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {HarmonyAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Harmony {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {HarmonyAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {HarmonyAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Harmony {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {HarmonyAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {HarmonyAttributes['id']}. */
  setId(id: string | null): Harmony {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {HarmonyAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {HarmonyAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): Harmony {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {HarmonyAttributes['print-frame']}. */
  getPrintFrame(): 'yes' | 'no' | null {
    return this.attributes['print-frame'];
  }
  /** Sets @type {HarmonyAttributes['print-frame']}. */
  setPrintFrame(printFrame: 'yes' | 'no' | null): Harmony {
    this.attributes['print-frame'] = printFrame;
    return this;
  }
  /** Gets @type {HarmonyAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {HarmonyAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Harmony {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {HarmonyAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {HarmonyAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Harmony {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {HarmonyAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {HarmonyAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Harmony {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {HarmonyAttributes['system']}. */
  getSystem(): 'none' | 'only-top' | 'also-top' | null {
    return this.attributes['system'];
  }
  /** Sets @type {HarmonyAttributes['system']}. */
  setSystem(system: 'none' | 'only-top' | 'also-top' | null): Harmony {
    this.attributes['system'] = system;
    return this;
  }
  /** Gets @type {HarmonyAttributes['type']}. */
  getType(): 'alternate' | 'explicit' | 'implied' | null {
    return this.attributes['type'];
  }
  /** Sets @type {HarmonyAttributes['type']}. */
  setType(type: 'alternate' | 'explicit' | 'implied' | null): Harmony {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>}. */
  getValues(): Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]> {
    return this.contents[0];
  }
  /** Sets @type {Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>}. */
  setValues(values: Array<[Root | Numeral | Function, Kind, Inversion | null, Bass | null, Array<Degree>]>): this {
    this.contents[0] = values;
    return this;
  }
  /** Gets @type {Frame | null}. */
  getFrame(): Frame | null {
    return this.contents[1];
  }
  /** Sets @type {Frame | null}. */
  setFrame(frame: Frame | null): this {
    this.contents[1] = frame;
    return this;
  }
  /** Gets @type {Offset | null}. */
  getOffset(): Offset | null {
    return this.contents[2];
  }
  /** Sets @type {Offset | null}. */
  setOffset(offset: Offset | null): this {
    this.contents[2] = offset;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[3];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[3] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[4];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[4] = level;
    return this;
  }
  /** Gets @type {Staff | null}. */
  getStaff(): Staff | null {
    return this.contents[5];
  }
  /** Sets @type {Staff | null}. */
  setStaff(staff: Staff | null): this {
    this.contents[5] = staff;
    return this;
  }
}

export type PrefixAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type PrefixContents = [string];

/**
 * The `<prefix>` element
 *
 * Parent element: `<figure>`
 *
 * Values for the `<prefix>` element include plus and the accidental values sharp, flat, natural, double-sharp,
 * flat-flat, and sharp-sharp. The `<prefix>` element may contain additional values for symbols specific to particular
 * figured bass styles.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/prefix/}
 */
export class Prefix implements XMLElement<'prefix', PrefixAttributes, PrefixContents> {
  static readonly schema = {
    name: 'prefix',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Prefix.schema;

  attributes: PrefixAttributes;
  contents: PrefixContents;

  constructor(opts?: { attributes?: Partial<PrefixAttributes>; contents?: PrefixContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Prefix.schema);
    this.contents = opts?.contents ?? operations.zero(Prefix.schema.contents);
  }
  /** Gets @type {PrefixAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {PrefixAttributes['color']}. */
  setColor(color: string | null): Prefix {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {PrefixAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {PrefixAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Prefix {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {PrefixAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {PrefixAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Prefix {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {PrefixAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {PrefixAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Prefix {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {PrefixAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {PrefixAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Prefix {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {PrefixAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {PrefixAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Prefix {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {PrefixAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {PrefixAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Prefix {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {PrefixAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {PrefixAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Prefix {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {PrefixAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {PrefixAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Prefix {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type FigureNumberAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type FigureNumberContents = [string];

/**
 * The `<figure>` element
 *
 * Parent element: `<figured-bass>`
 *
 * The `<figure>` element represents a single figure within a `<figured-bass>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/figure-number/}
 */
export class FigureNumber implements XMLElement<'figure-number', FigureNumberAttributes, FigureNumberContents> {
  static readonly schema = {
    name: 'figure-number',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'string' }],
  } as const;

  readonly schema = FigureNumber.schema;

  attributes: FigureNumberAttributes;
  contents: FigureNumberContents;

  constructor(opts?: { attributes?: Partial<FigureNumberAttributes>; contents?: FigureNumberContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FigureNumber.schema);
    this.contents = opts?.contents ?? operations.zero(FigureNumber.schema.contents);
  }
  /** Gets @type {FigureNumberAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FigureNumberAttributes['color']}. */
  setColor(color: string | null): FigureNumber {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FigureNumberAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): FigureNumber {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FigureNumberAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): FigureNumber {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FigureNumberAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): FigureNumber {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FigureNumberAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): FigureNumber {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FigureNumberAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): FigureNumber {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FigureNumberAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): FigureNumber {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FigureNumberAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): FigureNumber {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FigureNumberAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FigureNumberAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): FigureNumber {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type SuffixAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
};

export type SuffixContents = [string];

/**
 * The `<suffix>` element
 *
 * Parent element: `<figure>`
 *
 * Values for the `<suffix>` element include plus and the accidental values sharp, flat, natural, double-sharp,
 * flat-flat, and sharp-sharp. Suffixes include both symbols that come after the figure number and those that overstrike
 * the figure number. The `<suffix>` values slash, back-slash, and vertical are used for slashed numbers indicating
 * chromatic alteration. The orientation and display of the slash usually depends on the figure number. The `<suffix>`
 * element may contain additional values for symbols specific to particular figured bass styles.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/suffix/}
 */
export class Suffix implements XMLElement<'suffix', SuffixAttributes, SuffixContents> {
  static readonly schema = {
    name: 'suffix',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Suffix.schema;

  attributes: SuffixAttributes;
  contents: SuffixContents;

  constructor(opts?: { attributes?: Partial<SuffixAttributes>; contents?: SuffixContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Suffix.schema);
    this.contents = opts?.contents ?? operations.zero(Suffix.schema.contents);
  }
  /** Gets @type {SuffixAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {SuffixAttributes['color']}. */
  setColor(color: string | null): Suffix {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {SuffixAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {SuffixAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Suffix {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {SuffixAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {SuffixAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Suffix {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {SuffixAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {SuffixAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Suffix {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {SuffixAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {SuffixAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Suffix {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {SuffixAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {SuffixAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Suffix {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {SuffixAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {SuffixAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Suffix {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {SuffixAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {SuffixAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Suffix {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {SuffixAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {SuffixAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Suffix {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type FigureAttributes = Record<string, unknown>;

export type FigureContents = [
  Prefix | null,
  FigureNumber | null,
  Suffix | null,
  Extend | null,
  Footnote | null,
  Level | null,
];

/**
 * The `<figure>` element
 *
 * Parent element: `<figured-bass>`
 *
 * The `<figure>` element represents a single figure within a `<figured-bass>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/figure/}
 */
export class Figure implements XMLElement<'figure', FigureAttributes, FigureContents> {
  static readonly schema = {
    name: 'figure',
    attributes: {},
    contents: [
      { type: 'optional', value: Prefix },
      { type: 'optional', value: FigureNumber },
      { type: 'optional', value: Suffix },
      { type: 'optional', value: Extend },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = Figure.schema;

  attributes: FigureAttributes;
  contents: FigureContents;

  constructor(opts?: { attributes?: Partial<FigureAttributes>; contents?: FigureContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Figure.schema);
    this.contents = opts?.contents ?? operations.zero(Figure.schema.contents);
  }

  /** Gets @type {Prefix | null}. */
  getPrefix(): Prefix | null {
    return this.contents[0];
  }
  /** Sets @type {Prefix | null}. */
  setPrefix(prefix: Prefix | null): this {
    this.contents[0] = prefix;
    return this;
  }
  /** Gets @type {FigureNumber | null}. */
  getFigureNumber(): FigureNumber | null {
    return this.contents[1];
  }
  /** Sets @type {FigureNumber | null}. */
  setFigureNumber(figureNumber: FigureNumber | null): this {
    this.contents[1] = figureNumber;
    return this;
  }
  /** Gets @type {Suffix | null}. */
  getSuffix(): Suffix | null {
    return this.contents[2];
  }
  /** Sets @type {Suffix | null}. */
  setSuffix(suffix: Suffix | null): this {
    this.contents[2] = suffix;
    return this;
  }
  /** Gets @type {Extend | null}. */
  getExtend(): Extend | null {
    return this.contents[3];
  }
  /** Sets @type {Extend | null}. */
  setExtend(extend: Extend | null): this {
    this.contents[3] = extend;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[4];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[4] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[5];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[5] = level;
    return this;
  }
}

export type FiguredBassAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates if the entire figured bass is parenthesized. It is no if not present.
   */
  parentheses: 'yes' | 'no' | null;
  /**
   * Indicates whether something is above or below another element, such as a note or a notation.
   */
  placement: 'above' | 'below' | null;
  /**
   * Controls the printing of an augmentation dot separately from the rest of the note or rest. This is especially
   * useful for notes that overlap in different voices, or for chord sheets that contain lyrics and chords but no
   * melody. If print-object is set to no, this attribute is also interpreted as being set to no if not present.
   */
  'print-dot': 'yes' | 'no' | null;
  /**
   * Controls the printing of a lyric separately from the rest of the note or rest. This is especially useful for
   * notes that overlap in different voices, or for chord sheets that contain lyrics and chords but no melody. If
   * print-object is set to no, this attribute is also interpreted as being set to no if not present.
   */
  'print-lyric': 'yes' | 'no' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Controls whether or not spacing is left for an invisible note or object. It is used only if no note, dot, or
   * lyric is being printed. The value is yes (leave spacing) if not specified.
   */
  'print-spacing': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type FiguredBassContents = [Array<Figure>, Duration | null, Footnote | null, Level | null];

/**
 * The `<figured-bass>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<figured-bass>` element represents figured bass notation. A `<figured-bass>` element takes its position from the
 * first regular note (not a grace note or chord note) that follows in score order. The optional `<duration>` element is
 * used to indicate changes of figures under a note. Figures are ordered from top to bottom.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/figured-bass/}
 */
export class FiguredBass implements XMLElement<'figured-bass', FiguredBassAttributes, FiguredBassContents> {
  static readonly schema = {
    name: 'figured-bass',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      parentheses: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      placement: { type: 'optional', value: { type: 'choices', choices: ['above', 'below'] } },
      'print-dot': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-lyric': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'print-spacing': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      { type: 'label', label: 'figures', value: { type: 'oneOrMore', value: Figure } },
      { type: 'optional', value: Duration },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
    ],
  } as const;

  readonly schema = FiguredBass.schema;

  attributes: FiguredBassAttributes;
  contents: FiguredBassContents;

  constructor(opts?: { attributes?: Partial<FiguredBassAttributes>; contents?: FiguredBassContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, FiguredBass.schema);
    this.contents = opts?.contents ?? operations.zero(FiguredBass.schema.contents);
  }
  /** Gets @type {FiguredBassAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {FiguredBassAttributes['color']}. */
  setColor(color: string | null): FiguredBass {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {FiguredBassAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): FiguredBass {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {FiguredBassAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): FiguredBass {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {FiguredBassAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): FiguredBass {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {FiguredBassAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): FiguredBass {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {FiguredBassAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): FiguredBass {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {FiguredBassAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): FiguredBass {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {FiguredBassAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): FiguredBass {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {FiguredBassAttributes['id']}. */
  setId(id: string | null): FiguredBass {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['parentheses']}. */
  getParentheses(): 'yes' | 'no' | null {
    return this.attributes['parentheses'];
  }
  /** Sets @type {FiguredBassAttributes['parentheses']}. */
  setParentheses(parentheses: 'yes' | 'no' | null): FiguredBass {
    this.attributes['parentheses'] = parentheses;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['placement']}. */
  getPlacement(): 'above' | 'below' | null {
    return this.attributes['placement'];
  }
  /** Sets @type {FiguredBassAttributes['placement']}. */
  setPlacement(placement: 'above' | 'below' | null): FiguredBass {
    this.attributes['placement'] = placement;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['print-dot']}. */
  getPrintDot(): 'yes' | 'no' | null {
    return this.attributes['print-dot'];
  }
  /** Sets @type {FiguredBassAttributes['print-dot']}. */
  setPrintDot(printDot: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-dot'] = printDot;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['print-lyric']}. */
  getPrintLyric(): 'yes' | 'no' | null {
    return this.attributes['print-lyric'];
  }
  /** Sets @type {FiguredBassAttributes['print-lyric']}. */
  setPrintLyric(printLyric: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-lyric'] = printLyric;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {FiguredBassAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['print-spacing']}. */
  getPrintSpacing(): 'yes' | 'no' | null {
    return this.attributes['print-spacing'];
  }
  /** Sets @type {FiguredBassAttributes['print-spacing']}. */
  setPrintSpacing(printSpacing: 'yes' | 'no' | null): FiguredBass {
    this.attributes['print-spacing'] = printSpacing;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {FiguredBassAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): FiguredBass {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {FiguredBassAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): FiguredBass {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {FiguredBassAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {FiguredBassAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): FiguredBass {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {Array<Figure>}. */
  getFigures(): Array<Figure> {
    return this.contents[0];
  }
  /** Sets @type {Array<Figure>}. */
  setFigures(figures: Array<Figure>): this {
    this.contents[0] = figures;
    return this;
  }
  /** Gets @type {Duration | null}. */
  getDuration(): Duration | null {
    return this.contents[1];
  }
  /** Sets @type {Duration | null}. */
  setDuration(duration: Duration | null): this {
    this.contents[1] = duration;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[2];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[2] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[3];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[3] = level;
    return this;
  }
}

export type MeasureDistanceAttributes = Record<string, unknown>;

export type MeasureDistanceContents = [number];

/**
 * The `<measure-distance>` element
 *
 * Parent element: `<measure-layout>`
 *
 * The `<measure-distance>` element specifies the horizontal distance from the previous measure. This value is only used
 * for systems where there is horizontal whitespace in the middle of a system, as in systems with codas. To specify the
 * measure width, use the width attribute of the `<measure>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-distance/}
 */
export class MeasureDistance
  implements XMLElement<'measure-distance', MeasureDistanceAttributes, MeasureDistanceContents>
{
  static readonly schema = {
    name: 'measure-distance',
    attributes: {},
    contents: [
      {
        type: 'label',
        label: 'value',
        value: { type: 'required', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
    ],
  } as const;

  readonly schema = MeasureDistance.schema;

  attributes: MeasureDistanceAttributes;
  contents: MeasureDistanceContents;

  constructor(opts?: { attributes?: Partial<MeasureDistanceAttributes>; contents?: MeasureDistanceContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureDistance.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureDistance.schema.contents);
  }

  /** Gets @type {number}. */
  getValue(): number {
    return this.contents[0];
  }
  /** Sets @type {number}. */
  setValue(value: number): this {
    this.contents[0] = value;
    return this;
  }
}

export type MeasureLayoutAttributes = Record<string, unknown>;

export type MeasureLayoutContents = [MeasureDistance | null];

/**
 * The `<measure-layout>` element
 *
 * Parent element: `<print>`
 *
 * The `<measure-layout>` element includes the horizontal distance from the previous measure. It applies to the current
 * measure only.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-layout/}
 */
export class MeasureLayout implements XMLElement<'measure-layout', MeasureLayoutAttributes, MeasureLayoutContents> {
  static readonly schema = {
    name: 'measure-layout',
    attributes: {},
    contents: [{ type: 'optional', value: MeasureDistance }],
  } as const;

  readonly schema = MeasureLayout.schema;

  attributes: MeasureLayoutAttributes;
  contents: MeasureLayoutContents;

  constructor(opts?: { attributes?: Partial<MeasureLayoutAttributes>; contents?: MeasureLayoutContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureLayout.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureLayout.schema.contents);
  }

  /** Gets @type {MeasureDistance | null}. */
  getMeasureDistance(): MeasureDistance | null {
    return this.contents[0];
  }
  /** Sets @type {MeasureDistance | null}. */
  setMeasureDistance(measureDistance: MeasureDistance | null): this {
    this.contents[0] = measureDistance;
    return this;
  }
}

export type MeasureNumberingAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * In cases where text extends over more than one line, horizontal alignment and justify values can be different.
   * The most typical case is for credits, such as:
   *
   * Words and music by
   * Pat Songwriter
   *
   * Typically this type of credit is aligned to the right, so that the position information refers to the
   * right-most part of the text. But in this example, the text is center-justified, not right-justified.
   *
   * The halign attribute is used in these situations. If it is not present, its value is the same as for the
   * justify attribute. For elements where a justify attribute is not allowed, the default is
   * implementation-dependent.
   */
  halign: 'left' | 'center' | 'right' | null;
  /**
   * The multiple-rest-always and multiple-rest-range attributes describe how measure numbers are shown on multiple
   * rests when the `<measure-numbering>` value is not set to none. The multiple-rest-always attribute is set to yes
   * when the measure number should always be shown, even if the multiple rest starts midway through a system when
   * measure numbering is set to system level.
   */
  'multiple-rest-always': 'yes' | 'no' | null;
  /**
   * The multiple-rest-always and multiple-rest-range attributes describe how measure numbers are shown on multiple
   * rests when the `<measure-numbering>` value is not set to none. The multiple-rest-range attribute is set to yes
   * when measure numbers on multiple rests display the range of numbers for the first and last measure, rather than
   * just the number of the first measure.
   */
  'multiple-rest-range': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Refers to staff numbers within the part, from top to bottom on the system. It indicates which staff is used as
   * the reference point for vertical positioning. A value of 1 is assumed if not present.
   */
  staff: number | null;
  /**
   * Specifies if measure numbers are associated with a system rather than the particular part where the
   * `<measure-numbering>` element appears.
   */
  system: 'none' | 'only-top' | 'only-bottom' | 'also-top' | 'also-bottom' | null;
  /**
   * Indicates vertical alignment to the top, middle, bottom, or baseline of the text. The default is
   * implementation-dependent.
   */
  valign: 'top' | 'middle' | 'bottom' | 'baseline' | null;
};

export type MeasureNumberingContents = ['none' | 'measure' | 'system'];

/**
 * The `<measure-numbering>` element
 *
 * Parent element: `<print>`
 *
 * The `<measure-numbering>` element describes how frequently measure numbers are displayed on this part. The text
 * attribute from the `<measure>` element is used for display, or the number attribute if the text attribute is not
 * present. Measures with an implicit attribute set to yes never display a measure number, regardless of the
 * `<measure-numbering>` setting.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-numbering/}
 */
export class MeasureNumbering
  implements XMLElement<'measure-numbering', MeasureNumberingAttributes, MeasureNumberingContents>
{
  static readonly schema = {
    name: 'measure-numbering',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      halign: { type: 'optional', value: { type: 'choices', choices: ['left', 'center', 'right'] } },
      'multiple-rest-always': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'multiple-rest-range': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      staff: { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      system: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'only-top', 'only-bottom', 'also-top', 'also-bottom'] },
      },
      valign: { type: 'optional', value: { type: 'choices', choices: ['top', 'middle', 'bottom', 'baseline'] } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'measure-number-value',
          value: { type: 'choices', choices: ['none', 'measure', 'system'] },
        },
      },
    ],
  } as const;

  readonly schema = MeasureNumbering.schema;

  attributes: MeasureNumberingAttributes;
  contents: MeasureNumberingContents;

  constructor(opts?: { attributes?: Partial<MeasureNumberingAttributes>; contents?: MeasureNumberingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureNumbering.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureNumbering.schema.contents);
  }
  /** Gets @type {MeasureNumberingAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {MeasureNumberingAttributes['color']}. */
  setColor(color: string | null): MeasureNumbering {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {MeasureNumberingAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): MeasureNumbering {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {MeasureNumberingAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): MeasureNumbering {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {MeasureNumberingAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): MeasureNumbering {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {MeasureNumberingAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): MeasureNumbering {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {MeasureNumberingAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): MeasureNumbering {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {MeasureNumberingAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): MeasureNumbering {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['halign']}. */
  getHalign(): 'left' | 'center' | 'right' | null {
    return this.attributes['halign'];
  }
  /** Sets @type {MeasureNumberingAttributes['halign']}. */
  setHalign(halign: 'left' | 'center' | 'right' | null): MeasureNumbering {
    this.attributes['halign'] = halign;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['multiple-rest-always']}. */
  getMultipleRestAlways(): 'yes' | 'no' | null {
    return this.attributes['multiple-rest-always'];
  }
  /** Sets @type {MeasureNumberingAttributes['multiple-rest-always']}. */
  setMultipleRestAlways(multipleRestAlways: 'yes' | 'no' | null): MeasureNumbering {
    this.attributes['multiple-rest-always'] = multipleRestAlways;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['multiple-rest-range']}. */
  getMultipleRestRange(): 'yes' | 'no' | null {
    return this.attributes['multiple-rest-range'];
  }
  /** Sets @type {MeasureNumberingAttributes['multiple-rest-range']}. */
  setMultipleRestRange(multipleRestRange: 'yes' | 'no' | null): MeasureNumbering {
    this.attributes['multiple-rest-range'] = multipleRestRange;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {MeasureNumberingAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): MeasureNumbering {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {MeasureNumberingAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): MeasureNumbering {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['staff']}. */
  getStaff(): number | null {
    return this.attributes['staff'];
  }
  /** Sets @type {MeasureNumberingAttributes['staff']}. */
  setStaff(staff: number | null): MeasureNumbering {
    this.attributes['staff'] = staff;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['system']}. */
  getSystem(): 'none' | 'only-top' | 'only-bottom' | 'also-top' | 'also-bottom' | null {
    return this.attributes['system'];
  }
  /** Sets @type {MeasureNumberingAttributes['system']}. */
  setSystem(system: 'none' | 'only-top' | 'only-bottom' | 'also-top' | 'also-bottom' | null): MeasureNumbering {
    this.attributes['system'] = system;
    return this;
  }
  /** Gets @type {MeasureNumberingAttributes['valign']}. */
  getValign(): 'top' | 'middle' | 'bottom' | 'baseline' | null {
    return this.attributes['valign'];
  }
  /** Sets @type {MeasureNumberingAttributes['valign']}. */
  setValign(valign: 'top' | 'middle' | 'bottom' | 'baseline' | null): MeasureNumbering {
    this.attributes['valign'] = valign;
    return this;
  }
  /** Gets @type {'none' | 'measure' | 'system'}. */
  getMeasureNumberValue(): 'none' | 'measure' | 'system' {
    return this.contents[0];
  }
  /** Sets @type {'none' | 'measure' | 'system'}. */
  setMeasureNumberValue(measureNumberValue: 'none' | 'measure' | 'system'): this {
    this.contents[0] = measureNumberValue;
    return this;
  }
}

export type PrintAttributes = {
  /**
   * The number of blank pages to insert before the current measure. It is ignored if new-page is not "yes". These
   * blank pages have no music, but may have text or images specified by the credit element. This is used to allow
   * a combination of pages that are all text, or all text and images, together with pages of music.
   */
  'blank-page': number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Indicates whether to force a page break, or to force the current music onto the same page as the preceding
   * music. Normally this is the first music data within a measure. If used in multi-part music, the attributes
   * should be placed in the same positions within each part, or the results are undefined.
   */
  'new-page': 'yes' | 'no' | null;
  /**
   * Indicates whether to force a system break, or to force the current music onto the same system as the preceding
   * music. Normally this is the first music data within a measure. If used in multi-part music, the attributes
   * should be placed in the same positions within each part, or the results are undefined.
   */
  'new-system': 'yes' | 'no' | null;
  /**
   * Sets the number of a new page. It is ignored if new-page is not "yes".
   */
  'page-number': string | null;
  /**
   * Specifies spacing between multiple staves in tenths of staff space. Deprecated as of Version 1.1; the
   * staff-layout element should be used instead. If both are present, the staff-layout values take priority.
   */
  'staff-spacing': number | null;
};

export type PrintContents = [
  PageLayout | null,
  SystemLayout | null,
  Array<StaffLayout>,
  MeasureLayout | null,
  MeasureNumbering | null,
  PartNameDisplay | null,
  PartAbbreviationDisplay | null,
];

/**
 * The `<print>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<print>` element contains general printing parameters, including layout elements. The `<part-name-display>` and
 * `<part-abbreviation-display>` elements may also be used here to change how a part name or abbreviation is displayed
 * over the course of a piece. They take effect when the current measure or a succeeding measure starts a new system.
 *
 * Layout group elements in a `<print>` element only apply to the current page, system, or staff. Music that follows
 * continues to take the default values from the layout determined by the `<defaults>` element.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/print/}
 */
export class Print implements XMLElement<'print', PrintAttributes, PrintContents> {
  static readonly schema = {
    name: 'print',
    attributes: {
      'blank-page': { type: 'optional', value: { type: 'int', min: 1, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'new-page': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'new-system': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'page-number': { type: 'optional', value: { type: 'string' } },
      'staff-spacing': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [
      { type: 'optional', value: PageLayout },
      { type: 'optional', value: SystemLayout },
      { type: 'label', label: 'staff-layouts', value: { type: 'zeroOrMore', value: StaffLayout } },
      { type: 'optional', value: MeasureLayout },
      { type: 'optional', value: MeasureNumbering },
      { type: 'optional', value: PartNameDisplay },
      { type: 'optional', value: PartAbbreviationDisplay },
    ],
  } as const;

  readonly schema = Print.schema;

  attributes: PrintAttributes;
  contents: PrintContents;

  constructor(opts?: { attributes?: Partial<PrintAttributes>; contents?: PrintContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Print.schema);
    this.contents = opts?.contents ?? operations.zero(Print.schema.contents);
  }
  /** Gets @type {PrintAttributes['blank-page']}. */
  getBlankPage(): number | null {
    return this.attributes['blank-page'];
  }
  /** Sets @type {PrintAttributes['blank-page']}. */
  setBlankPage(blankPage: number | null): Print {
    this.attributes['blank-page'] = blankPage;
    return this;
  }
  /** Gets @type {PrintAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {PrintAttributes['id']}. */
  setId(id: string | null): Print {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {PrintAttributes['new-page']}. */
  getNewPage(): 'yes' | 'no' | null {
    return this.attributes['new-page'];
  }
  /** Sets @type {PrintAttributes['new-page']}. */
  setNewPage(newPage: 'yes' | 'no' | null): Print {
    this.attributes['new-page'] = newPage;
    return this;
  }
  /** Gets @type {PrintAttributes['new-system']}. */
  getNewSystem(): 'yes' | 'no' | null {
    return this.attributes['new-system'];
  }
  /** Sets @type {PrintAttributes['new-system']}. */
  setNewSystem(newSystem: 'yes' | 'no' | null): Print {
    this.attributes['new-system'] = newSystem;
    return this;
  }
  /** Gets @type {PrintAttributes['page-number']}. */
  getPageNumber(): string | null {
    return this.attributes['page-number'];
  }
  /** Sets @type {PrintAttributes['page-number']}. */
  setPageNumber(pageNumber: string | null): Print {
    this.attributes['page-number'] = pageNumber;
    return this;
  }
  /** Gets @type {PrintAttributes['staff-spacing']}. */
  getStaffSpacing(): number | null {
    return this.attributes['staff-spacing'];
  }
  /** Sets @type {PrintAttributes['staff-spacing']}. */
  setStaffSpacing(staffSpacing: number | null): Print {
    this.attributes['staff-spacing'] = staffSpacing;
    return this;
  }
  /** Gets @type {PageLayout | null}. */
  getPageLayout(): PageLayout | null {
    return this.contents[0];
  }
  /** Sets @type {PageLayout | null}. */
  setPageLayout(pageLayout: PageLayout | null): this {
    this.contents[0] = pageLayout;
    return this;
  }
  /** Gets @type {SystemLayout | null}. */
  getSystemLayout(): SystemLayout | null {
    return this.contents[1];
  }
  /** Sets @type {SystemLayout | null}. */
  setSystemLayout(systemLayout: SystemLayout | null): this {
    this.contents[1] = systemLayout;
    return this;
  }
  /** Gets @type {Array<StaffLayout>}. */
  getStaffLayouts(): Array<StaffLayout> {
    return this.contents[2];
  }
  /** Sets @type {Array<StaffLayout>}. */
  setStaffLayouts(staffLayouts: Array<StaffLayout>): this {
    this.contents[2] = staffLayouts;
    return this;
  }
  /** Gets @type {MeasureLayout | null}. */
  getMeasureLayout(): MeasureLayout | null {
    return this.contents[3];
  }
  /** Sets @type {MeasureLayout | null}. */
  setMeasureLayout(measureLayout: MeasureLayout | null): this {
    this.contents[3] = measureLayout;
    return this;
  }
  /** Gets @type {MeasureNumbering | null}. */
  getMeasureNumbering(): MeasureNumbering | null {
    return this.contents[4];
  }
  /** Sets @type {MeasureNumbering | null}. */
  setMeasureNumbering(measureNumbering: MeasureNumbering | null): this {
    this.contents[4] = measureNumbering;
    return this;
  }
  /** Gets @type {PartNameDisplay | null}. */
  getPartNameDisplay(): PartNameDisplay | null {
    return this.contents[5];
  }
  /** Sets @type {PartNameDisplay | null}. */
  setPartNameDisplay(partNameDisplay: PartNameDisplay | null): this {
    this.contents[5] = partNameDisplay;
    return this;
  }
  /** Gets @type {PartAbbreviationDisplay | null}. */
  getPartAbbreviationDisplay(): PartAbbreviationDisplay | null {
    return this.contents[6];
  }
  /** Sets @type {PartAbbreviationDisplay | null}. */
  setPartAbbreviationDisplay(partAbbreviationDisplay: PartAbbreviationDisplay | null): this {
    this.contents[6] = partAbbreviationDisplay;
    return this;
  }
}

export type BarStyleAttributes = {
  /**
   * Indicates the color of an element.
   */
  color: string | null;
};

export type BarStyleContents = [
  | 'none'
  | 'dashed'
  | 'dotted'
  | 'heavy'
  | 'heavy-heavy'
  | 'heavy-light'
  | 'light-heavy'
  | 'light-light'
  | 'regular'
  | 'short'
  | 'tick',
];

/**
 * The `<bar-style>` element
 *
 * Parent element: `<barline>`
 *
 * The `<bar-style>` element contains barline style and color information.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/bar-style/}
 */
export class BarStyle implements XMLElement<'bar-style', BarStyleAttributes, BarStyleContents> {
  static readonly schema = {
    name: 'bar-style',
    attributes: {
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
    },
    contents: [
      {
        type: 'required',
        value: {
          type: 'label',
          label: 'bar-style',
          value: {
            type: 'choices',
            choices: [
              'none',
              'dashed',
              'dotted',
              'heavy',
              'heavy-heavy',
              'heavy-light',
              'light-heavy',
              'light-light',
              'regular',
              'short',
              'tick',
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = BarStyle.schema;

  attributes: BarStyleAttributes;
  contents: BarStyleContents;

  constructor(opts?: { attributes?: Partial<BarStyleAttributes>; contents?: BarStyleContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, BarStyle.schema);
    this.contents = opts?.contents ?? operations.zero(BarStyle.schema.contents);
  }
  /** Gets @type {BarStyleAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {BarStyleAttributes['color']}. */
  setColor(color: string | null): BarStyle {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {'none' | 'dashed' | 'dotted' | 'heavy' | 'heavy-heavy' | 'heavy-light' | 'light-heavy' | 'light-light' | 'regular' | 'short' | 'tick'}. */
  getBarStyle():
    | 'none'
    | 'dashed'
    | 'dotted'
    | 'heavy'
    | 'heavy-heavy'
    | 'heavy-light'
    | 'light-heavy'
    | 'light-light'
    | 'regular'
    | 'short'
    | 'tick' {
    return this.contents[0];
  }
  /** Sets @type {'none' | 'dashed' | 'dotted' | 'heavy' | 'heavy-heavy' | 'heavy-light' | 'light-heavy' | 'light-light' | 'regular' | 'short' | 'tick'}. */
  setBarStyle(
    barStyle:
      | 'none'
      | 'dashed'
      | 'dotted'
      | 'heavy'
      | 'heavy-heavy'
      | 'heavy-light'
      | 'light-heavy'
      | 'light-light'
      | 'regular'
      | 'short'
      | 'tick'
  ): this {
    this.contents[0] = barStyle;
    return this;
  }
}

export type EndingAttributes = {
  /**
   * Indicates which times the ending is played, similar to the time-only attribute used by other elements. While
   * this often represents the numeric values for what is under the ending line, it can also indicate whether an
   * ending is played during a larger dal segno or da capo repeat. Single endings such as "1" or comma-separated
   * multiple endings such as "1,2" may be used.
   */
  number: string;
  /**
   * Typically, the start type is associated with the left barline of the first measure in an ending. The stop and
   * discontinue types are associated with the right barline of the last measure in an ending. Stop is used when the
   * ending mark concludes with a downward jog, as is typical for first endings. Discontinue is used when there is
   * no downward jog, as is typical for second endings that do not conclude a piece.
   */
  type: 'start' | 'stop' | 'discontinue';
  /**
   * Indicates the color of an element.
   */
  color: string | null;
  /**
   * Changes the computation of the default horizontal position. The origin is changed relative to the left-hand
   * side of the note or the musical position within the bar. Positive x is right and negative x is left.
   *
   * This attribute provides higher-resolution positioning data than the `<offset>` element. Applications reading a
   * MusicXML file that can understand both features should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-x': number | null;
  /**
   * Changes the computation of the default vertical position. The origin is changed relative to the top line of the
   * staff. Positive y is up and negative y is down.
   *
   * This attribute provides higher-resolution positioning data than the placement attribute. Applications reading a
   * MusicXML file that can understand both attributes should generally rely on this attribute for its greater
   * accuracy.
   */
  'default-y': number | null;
  /**
   * Specifies the length of the ending jog.
   */
  'end-length': number | null;
  /**
   * A comma-separated list of font names.
   */
  'font-family': string | null;
  /**
   * One of the CSS sizes or a numeric point size.
   */
  'font-size': 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null;
  /**
   * Normal or italic style.
   */
  'font-style': 'normal' | 'italic' | null;
  /**
   * Normal or bold weight.
   */
  'font-weight': 'normal' | 'bold' | null;
  /**
   * Specifies whether or not to print an object. It is yes if not specified.
   */
  'print-object': 'yes' | 'no' | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-x': number | null;
  /**
   * Changes the horizontal position relative to the default position, either as computed by the individual
   * program, or as overridden by the default-x attribute. Positive x is right and negative x is left. It should be
   * interpreted in the context of the <offset> element or directive attribute if those are present.
   */
  'relative-y': number | null;
  /**
   * Distinguishes elements that are associated with a system rather than the particular part where the element
   * appears.
   */
  system: 'none' | 'only-top' | 'also-top' | null;
  /**
   * An offset that specifies where the start of the ending text appears, relative to the start of the ending line.
   */
  'text-x': number | null;
  /**
   * An offset that specifies where the baseline of ending text appears, relative to the start of the ending line.
   */
  'text-y': number | null;
};

export type EndingContents = [string];

/**
 * The `<ending>` element
 *
 * Parent element: `<barline>`
 *
 * The `<ending>` element represents multiple (e.g. first and second) endings. The element text is used when the text
 * displayed in the ending is different than what appears in the number attribute.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/ending/}
 */
export class Ending implements XMLElement<'ending', EndingAttributes, EndingContents> {
  static readonly schema = {
    name: 'ending',
    attributes: {
      number: {
        type: 'required',
        value: { type: 'regex', pattern: /([ ]*)|([1-9][0-9]*(, ?[1-9][0-9]*)*)/, zero: '' },
      },
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'discontinue'] } },
      color: { type: 'optional', value: { type: 'regex', pattern: /#[\dA-F]{6}([\dA-F][\dA-F])?/, zero: '#000000' } },
      'default-x': {
        type: 'label',
        label: 'default-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'default-y': {
        type: 'label',
        label: 'default-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'end-length': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'font-family': { type: 'optional', value: { type: 'regex', pattern: /[^,]+(, ?[^,]+)*/, zero: ' ' } },
      'font-size': {
        type: 'optional',
        value: {
          type: 'choices',
          choices: [
            { type: 'choices', choices: ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'] },
            { type: 'float', min: -Infinity, max: Infinity },
          ],
        },
      },
      'font-style': { type: 'optional', value: { type: 'choices', choices: ['normal', 'italic'] } },
      'font-weight': { type: 'optional', value: { type: 'choices', choices: ['normal', 'bold'] } },
      'print-object': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'relative-x': {
        type: 'label',
        label: 'relative-x',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      'relative-y': {
        type: 'label',
        label: 'relative-y',
        value: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      },
      system: { type: 'optional', value: { type: 'choices', choices: ['none', 'only-top', 'also-top'] } },
      'text-x': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      'text-y': { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Ending.schema;

  attributes: EndingAttributes;
  contents: EndingContents;

  constructor(opts?: { attributes?: Partial<EndingAttributes>; contents?: EndingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Ending.schema);
    this.contents = opts?.contents ?? operations.zero(Ending.schema.contents);
  }
  /** Gets @type {EndingAttributes['number']}. */
  getNumber(): string {
    return this.attributes['number'];
  }
  /** Sets @type {EndingAttributes['number']}. */
  setNumber(number: string): Ending {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {EndingAttributes['type']}. */
  getType(): 'start' | 'stop' | 'discontinue' {
    return this.attributes['type'];
  }
  /** Sets @type {EndingAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'discontinue'): Ending {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {EndingAttributes['color']}. */
  getColor(): string | null {
    return this.attributes['color'];
  }
  /** Sets @type {EndingAttributes['color']}. */
  setColor(color: string | null): Ending {
    this.attributes['color'] = color;
    return this;
  }
  /** Gets @type {EndingAttributes['default-x']}. */
  getDefaultX(): number | null {
    return this.attributes['default-x'];
  }
  /** Sets @type {EndingAttributes['default-x']}. */
  setDefaultX(defaultX: number | null): Ending {
    this.attributes['default-x'] = defaultX;
    return this;
  }
  /** Gets @type {EndingAttributes['default-y']}. */
  getDefaultY(): number | null {
    return this.attributes['default-y'];
  }
  /** Sets @type {EndingAttributes['default-y']}. */
  setDefaultY(defaultY: number | null): Ending {
    this.attributes['default-y'] = defaultY;
    return this;
  }
  /** Gets @type {EndingAttributes['end-length']}. */
  getEndLength(): number | null {
    return this.attributes['end-length'];
  }
  /** Sets @type {EndingAttributes['end-length']}. */
  setEndLength(endLength: number | null): Ending {
    this.attributes['end-length'] = endLength;
    return this;
  }
  /** Gets @type {EndingAttributes['font-family']}. */
  getFontFamily(): string | null {
    return this.attributes['font-family'];
  }
  /** Sets @type {EndingAttributes['font-family']}. */
  setFontFamily(fontFamily: string | null): Ending {
    this.attributes['font-family'] = fontFamily;
    return this;
  }
  /** Gets @type {EndingAttributes['font-size']}. */
  getFontSize(): 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null {
    return this.attributes['font-size'];
  }
  /** Sets @type {EndingAttributes['font-size']}. */
  setFontSize(
    fontSize: 'xx-small' | 'x-small' | 'small' | 'medium' | 'large' | 'x-large' | 'xx-large' | number | null
  ): Ending {
    this.attributes['font-size'] = fontSize;
    return this;
  }
  /** Gets @type {EndingAttributes['font-style']}. */
  getFontStyle(): 'normal' | 'italic' | null {
    return this.attributes['font-style'];
  }
  /** Sets @type {EndingAttributes['font-style']}. */
  setFontStyle(fontStyle: 'normal' | 'italic' | null): Ending {
    this.attributes['font-style'] = fontStyle;
    return this;
  }
  /** Gets @type {EndingAttributes['font-weight']}. */
  getFontWeight(): 'normal' | 'bold' | null {
    return this.attributes['font-weight'];
  }
  /** Sets @type {EndingAttributes['font-weight']}. */
  setFontWeight(fontWeight: 'normal' | 'bold' | null): Ending {
    this.attributes['font-weight'] = fontWeight;
    return this;
  }
  /** Gets @type {EndingAttributes['print-object']}. */
  getPrintObject(): 'yes' | 'no' | null {
    return this.attributes['print-object'];
  }
  /** Sets @type {EndingAttributes['print-object']}. */
  setPrintObject(printObject: 'yes' | 'no' | null): Ending {
    this.attributes['print-object'] = printObject;
    return this;
  }
  /** Gets @type {EndingAttributes['relative-x']}. */
  getRelativeX(): number | null {
    return this.attributes['relative-x'];
  }
  /** Sets @type {EndingAttributes['relative-x']}. */
  setRelativeX(relativeX: number | null): Ending {
    this.attributes['relative-x'] = relativeX;
    return this;
  }
  /** Gets @type {EndingAttributes['relative-y']}. */
  getRelativeY(): number | null {
    return this.attributes['relative-y'];
  }
  /** Sets @type {EndingAttributes['relative-y']}. */
  setRelativeY(relativeY: number | null): Ending {
    this.attributes['relative-y'] = relativeY;
    return this;
  }
  /** Gets @type {EndingAttributes['system']}. */
  getSystem(): 'none' | 'only-top' | 'also-top' | null {
    return this.attributes['system'];
  }
  /** Sets @type {EndingAttributes['system']}. */
  setSystem(system: 'none' | 'only-top' | 'also-top' | null): Ending {
    this.attributes['system'] = system;
    return this;
  }
  /** Gets @type {EndingAttributes['text-x']}. */
  getTextX(): number | null {
    return this.attributes['text-x'];
  }
  /** Sets @type {EndingAttributes['text-x']}. */
  setTextX(textX: number | null): Ending {
    this.attributes['text-x'] = textX;
    return this;
  }
  /** Gets @type {EndingAttributes['text-y']}. */
  getTextY(): number | null {
    return this.attributes['text-y'];
  }
  /** Sets @type {EndingAttributes['text-y']}. */
  setTextY(textY: number | null): Ending {
    this.attributes['text-y'] = textY;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type RepeatAttributes = {
  /**
   * The start of the repeat has a forward direction while the end of the repeat has a backward direction.
   */
  direction: 'backward' | 'forward';
  /**
   * Indicates if the repeats are played after a jump due to a da capo or dal segno. It is only used with backward
   * repeats that are not part of an ending.
   */
  'after-jump': 'yes' | 'no' | null;
  /**
   * Indicates the number of times the repeated section is played. It is only used with backward repeats that are not
   * part of an ending.
   */
  times: number | null;
  /**
   * Indicates whether the repeat has winged extensions that appear above and below the barline.
   */
  winged: 'none' | 'straight' | 'curved' | 'double-straight' | 'double-curved' | null;
};

export type RepeatContents = [];

/**
 * The `<repeat>` element
 *
 * Parent element: `<barline>`
 *
 * The `<repeat>` element represents repeat marks.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/repeat/}
 */
export class Repeat implements XMLElement<'repeat', RepeatAttributes, RepeatContents> {
  static readonly schema = {
    name: 'repeat',
    attributes: {
      direction: { type: 'required', value: { type: 'choices', choices: ['backward', 'forward'] } },
      'after-jump': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      times: { type: 'optional', value: { type: 'int', min: 0, max: Infinity } },
      winged: {
        type: 'optional',
        value: { type: 'choices', choices: ['none', 'straight', 'curved', 'double-straight', 'double-curved'] },
      },
    },
    contents: [],
  } as const;

  readonly schema = Repeat.schema;

  attributes: RepeatAttributes;
  contents: RepeatContents;

  constructor(opts?: { attributes?: Partial<RepeatAttributes>; contents?: RepeatContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Repeat.schema);
    this.contents = opts?.contents ?? operations.zero(Repeat.schema.contents);
  }
  /** Gets @type {RepeatAttributes['direction']}. */
  getDirection(): 'backward' | 'forward' {
    return this.attributes['direction'];
  }
  /** Sets @type {RepeatAttributes['direction']}. */
  setDirection(direction: 'backward' | 'forward'): Repeat {
    this.attributes['direction'] = direction;
    return this;
  }
  /** Gets @type {RepeatAttributes['after-jump']}. */
  getAfterJump(): 'yes' | 'no' | null {
    return this.attributes['after-jump'];
  }
  /** Sets @type {RepeatAttributes['after-jump']}. */
  setAfterJump(afterJump: 'yes' | 'no' | null): Repeat {
    this.attributes['after-jump'] = afterJump;
    return this;
  }
  /** Gets @type {RepeatAttributes['times']}. */
  getTimes(): number | null {
    return this.attributes['times'];
  }
  /** Sets @type {RepeatAttributes['times']}. */
  setTimes(times: number | null): Repeat {
    this.attributes['times'] = times;
    return this;
  }
  /** Gets @type {RepeatAttributes['winged']}. */
  getWinged(): 'none' | 'straight' | 'curved' | 'double-straight' | 'double-curved' | null {
    return this.attributes['winged'];
  }
  /** Sets @type {RepeatAttributes['winged']}. */
  setWinged(winged: 'none' | 'straight' | 'curved' | 'double-straight' | 'double-curved' | null): Repeat {
    this.attributes['winged'] = winged;
    return this;
  }
}

export type BarlineAttributes = {
  /**
   * Used for playback when there is a `<coda>` child element. Indicates the end point for a forward jump to a coda
   * sign. If there are multiple jumps, the value of these parameters can be used to name and distinguish them.
   */
  coda: string | null;
  /**
   * If the segno or coda attributes are used, the divisions attribute can be used to indicate the number of
   * divisions per quarter note. Otherwise sound and MIDI generating programs may have to recompute this.
   */
  divisions: number | null;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Barlines have a location attribute to make it easier to process barlines independently of the other musical
   * data in a score. It is often easier to set up measures separately from entering notes. The location attribute
   * must match where the `<barline>` element occurs within the rest of the musical data in the score. If location
   * is left, it should be the first element in the measure, aside from the `<print>`, `<bookmark>`, and `<link>`
   * elements. If location is right, it should be the last element, again with the possible exception of the
   * `<print>`, `<bookmark>`, and `<link>` elements. The default value is right.
   */
  location: 'right' | 'left' | 'middle' | null;
  /**
   * Used for playback when there is a `<segno>` child element. Indicates the end point for a backward jump to a
   * segno sign. If there are multiple jumps, the value of these parameters can be used to name and distinguish
   * them.
   */
  segno: string | null;
};

export type BarlineContents = [
  BarStyle | null,
  Footnote | null,
  Level | null,
  WavyLine | null,
  Segno | null,
  Coda | null,
  [] | [Fermata] | [Fermata, Fermata],
  Ending | null,
  Repeat | null,
];

/**
 * The `<barline>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * If a barline is other than a normal single barline, it should be represented by a `<barline>` element that describes
 * it. This includes information about repeats and multiple endings, as well as line style. Barline data is on the same
 * level as the other musical data in a score - a child of a measure in a partwise score, or a part in a timewise score.
 * This allows for barlines within measures, as in dotted barlines that subdivide measures in complex meters. The two
 * `<fermata>` elements allow for fermatas on both sides of the barline (the lower one inverted).
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/barline/}
 */
export class Barline implements XMLElement<'barline', BarlineAttributes, BarlineContents> {
  static readonly schema = {
    name: 'barline',
    attributes: {
      coda: { type: 'label', label: 'coda-token', value: { type: 'optional', value: { type: 'string' } } },
      divisions: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      location: { type: 'optional', value: { type: 'choices', choices: ['right', 'left', 'middle'] } },
      segno: { type: 'label', label: 'segno-token', value: { type: 'optional', value: { type: 'string' } } },
    },
    contents: [
      { type: 'optional', value: BarStyle },
      { type: 'optional', value: Footnote },
      { type: 'optional', value: Level },
      { type: 'optional', value: WavyLine },
      { type: 'optional', value: Segno },
      { type: 'optional', value: Coda },
      { type: 'label', label: 'fermatas', value: { type: 'choices', choices: [[], [Fermata], [Fermata, Fermata]] } },
      { type: 'optional', value: Ending },
      { type: 'optional', value: Repeat },
    ],
  } as const;

  readonly schema = Barline.schema;

  attributes: BarlineAttributes;
  contents: BarlineContents;

  constructor(opts?: { attributes?: Partial<BarlineAttributes>; contents?: BarlineContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Barline.schema);
    this.contents = opts?.contents ?? operations.zero(Barline.schema.contents);
  }
  /** Gets @type {BarlineAttributes['coda-token']}. */
  getCodaToken(): string | null {
    return this.attributes['coda'];
  }
  /** Sets @type {BarlineAttributes['coda-token']}. */
  setCodaToken(codaToken: string | null): Barline {
    this.attributes['coda'] = codaToken;
    return this;
  }
  /** Gets @type {BarlineAttributes['divisions']}. */
  getDivisions(): number | null {
    return this.attributes['divisions'];
  }
  /** Sets @type {BarlineAttributes['divisions']}. */
  setDivisions(divisions: number | null): Barline {
    this.attributes['divisions'] = divisions;
    return this;
  }
  /** Gets @type {BarlineAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {BarlineAttributes['id']}. */
  setId(id: string | null): Barline {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {BarlineAttributes['location']}. */
  getLocation(): 'right' | 'left' | 'middle' | null {
    return this.attributes['location'];
  }
  /** Sets @type {BarlineAttributes['location']}. */
  setLocation(location: 'right' | 'left' | 'middle' | null): Barline {
    this.attributes['location'] = location;
    return this;
  }
  /** Gets @type {BarlineAttributes['segno-token']}. */
  getSegnoToken(): string | null {
    return this.attributes['segno'];
  }
  /** Sets @type {BarlineAttributes['segno-token']}. */
  setSegnoToken(segnoToken: string | null): Barline {
    this.attributes['segno'] = segnoToken;
    return this;
  }
  /** Gets @type {BarStyle | null}. */
  getBarStyle(): BarStyle | null {
    return this.contents[0];
  }
  /** Sets @type {BarStyle | null}. */
  setBarStyle(barStyle: BarStyle | null): this {
    this.contents[0] = barStyle;
    return this;
  }
  /** Gets @type {Footnote | null}. */
  getFootnote(): Footnote | null {
    return this.contents[1];
  }
  /** Sets @type {Footnote | null}. */
  setFootnote(footnote: Footnote | null): this {
    this.contents[1] = footnote;
    return this;
  }
  /** Gets @type {Level | null}. */
  getLevel(): Level | null {
    return this.contents[2];
  }
  /** Sets @type {Level | null}. */
  setLevel(level: Level | null): this {
    this.contents[2] = level;
    return this;
  }
  /** Gets @type {WavyLine | null}. */
  getWavyLine(): WavyLine | null {
    return this.contents[3];
  }
  /** Sets @type {WavyLine | null}. */
  setWavyLine(wavyLine: WavyLine | null): this {
    this.contents[3] = wavyLine;
    return this;
  }
  /** Gets @type {Segno | null}. */
  getSegno(): Segno | null {
    return this.contents[4];
  }
  /** Sets @type {Segno | null}. */
  setSegno(segno: Segno | null): this {
    this.contents[4] = segno;
    return this;
  }
  /** Gets @type {Coda | null}. */
  getCoda(): Coda | null {
    return this.contents[5];
  }
  /** Sets @type {Coda | null}. */
  setCoda(coda: Coda | null): this {
    this.contents[5] = coda;
    return this;
  }
  /** Gets @type {[] | [Fermata] | [Fermata, Fermata]}. */
  getFermatas(): [] | [Fermata] | [Fermata, Fermata] {
    return this.contents[6];
  }
  /** Sets @type {[] | [Fermata] | [Fermata, Fermata]}. */
  setFermatas(fermatas: [] | [Fermata] | [Fermata, Fermata]): this {
    this.contents[6] = fermatas;
    return this;
  }
  /** Gets @type {Ending | null}. */
  getEnding(): Ending | null {
    return this.contents[7];
  }
  /** Sets @type {Ending | null}. */
  setEnding(ending: Ending | null): this {
    this.contents[7] = ending;
    return this;
  }
  /** Gets @type {Repeat | null}. */
  getRepeat(): Repeat | null {
    return this.contents[8];
  }
  /** Sets @type {Repeat | null}. */
  setRepeat(repeat: Repeat | null): this {
    this.contents[8] = repeat;
    return this;
  }
}

export type FeatureAttributes = {
  /**
   * Represents the type of the feature. This type is flexible to allow for different analyses.
   */
  type: string | null;
};

export type FeatureContents = [string];

/**
 * The `<feature>` element
 *
 * Parent element: `<grouping>`
 *
 * The `<feature>` element is a part of the <grouping> element used for musical analysis. The type attribute represents
 * the type of the feature and the element content represents its value.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/feature/}
 */
export class Feature implements XMLElement<'feature', FeatureAttributes, FeatureContents> {
  static readonly schema = {
    name: 'feature',
    attributes: { type: { type: 'optional', value: { type: 'string' } } },
    contents: [{ type: 'required', value: { type: 'string' } }],
  } as const;

  readonly schema = Feature.schema;

  attributes: FeatureAttributes;
  contents: FeatureContents;

  constructor(opts?: { attributes?: Partial<FeatureAttributes>; contents?: FeatureContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Feature.schema);
    this.contents = opts?.contents ?? operations.zero(Feature.schema.contents);
  }
  /** Gets @type {FeatureAttributes['type']}. */
  getType(): string | null {
    return this.attributes['type'];
  }
  /** Sets @type {FeatureAttributes['type']}. */
  setType(type: string | null): Feature {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {string}. */
  getText(): string {
    return this.contents[0];
  }
  /** Sets @type {string}. */
  setText(text: string): this {
    this.contents[0] = text;
    return this;
  }
}

export type GroupingAttributes = {
  /**
   * Indicates if this is a single-note grouping, or the start or stop of a multi-note grouping.
   */
  type: 'start' | 'stop' | 'single';
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Distinguishes which `<grouping>` elements are in which hierarchy.
   */
  'member-of': string | null;
  /**
   * Distinguishes between various overlapping and hierarchical groupings. The default value is 1.
   */
  number: string | null;
};

export type GroupingContents = [Array<Feature>];

/**
 * The `<grouping>` element
 *
 * Parent elements: `<measure>` (partwise), `<part>` (timewise)
 *
 * The `<grouping>` element is used for musical analysis. When the type attribute is start or single, it usually
 * contains one or more <feature> elements. Feature elements contained within a stop type of grouping may be ignored.
 *
 * This element is flexible to allow for different types of analyses. Future versions of the MusicXML format may add
 * elements that can represent more standardized categories of analysis data, allowing for easier data sharing.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/grouping/}
 */
export class Grouping implements XMLElement<'grouping', GroupingAttributes, GroupingContents> {
  static readonly schema = {
    name: 'grouping',
    attributes: {
      type: { type: 'required', value: { type: 'choices', choices: ['start', 'stop', 'single'] } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      'member-of': { type: 'optional', value: { type: 'string' } },
      number: { type: 'optional', value: { type: 'string' } },
    },
    contents: [{ type: 'label', label: 'features', value: { type: 'zeroOrMore', value: Feature } }],
  } as const;

  readonly schema = Grouping.schema;

  attributes: GroupingAttributes;
  contents: GroupingContents;

  constructor(opts?: { attributes?: Partial<GroupingAttributes>; contents?: GroupingContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, Grouping.schema);
    this.contents = opts?.contents ?? operations.zero(Grouping.schema.contents);
  }
  /** Gets @type {GroupingAttributes['type']}. */
  getType(): 'start' | 'stop' | 'single' {
    return this.attributes['type'];
  }
  /** Sets @type {GroupingAttributes['type']}. */
  setType(type: 'start' | 'stop' | 'single'): Grouping {
    this.attributes['type'] = type;
    return this;
  }
  /** Gets @type {GroupingAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {GroupingAttributes['id']}. */
  setId(id: string | null): Grouping {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {GroupingAttributes['member-of']}. */
  getMemberOf(): string | null {
    return this.attributes['member-of'];
  }
  /** Sets @type {GroupingAttributes['member-of']}. */
  setMemberOf(memberOf: string | null): Grouping {
    this.attributes['member-of'] = memberOf;
    return this;
  }
  /** Gets @type {GroupingAttributes['number']}. */
  getNumber(): string | null {
    return this.attributes['number'];
  }
  /** Sets @type {GroupingAttributes['number']}. */
  setNumber(number: string | null): Grouping {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {Array<Feature>}. */
  getFeatures(): Array<Feature> {
    return this.contents[0];
  }
  /** Sets @type {Array<Feature>}. */
  setFeatures(features: Array<Feature>): this {
    this.contents[0] = features;
    return this;
  }
}

export type MeasurePartwiseAttributes = {
  /**
   * The attribute that identifies the measure. Going from partwise to timewise, measures are grouped via this
   * attribute. In partwise files, it should be the same for measures in different parts that share the same left
   * barline.
   *
   * While often numeric, it does not have to be. Non-numeric values are typically used together with the implicit or
   * non-controlling attributes being set to "yes". For a pickup measure, the number attribute is typically set to "0"
   * and the implicit attribute is typically set to "yes".
   */
  number: string;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Set to "yes" for measures where the measure number should never appear, such as pickup measures and the last half
   * of mid-measure repeats. The value is "no" if not specified.
   */
  implicit: 'yes' | 'no' | null;
  /**
   * Intended for use in multimetric music like the Don Giovanni minuet. If set to "yes", the left barline in this
   * measure does not coincide with the left barline of measures in other parts. The value is "no" if not specified.
   */
  'non-controller': 'yes' | 'no' | null;
  /**
   * If measure numbers are not unique within a part, this can cause problems for conversions between partwise and
   * timewise formats. The text attribute allows specification of displayed measure numbers that are different than
   * what is used in the number attribute. This attribute is ignored for measures where the implicit attribute is set
   * to "yes". Further details about measure numbering can be specified using the `<measure-numbering>` element.
   */
  text: Exclude<'yes' | string, ''> | null;
  /**
   * Measure width specified in tenths. These are the global tenths specified in the `<scaling>` element, not local
   * tenths as modified by the `<staff-size>` element. The width covers the entire measure from barline or system
   * start to barline or system end.
   */
  width: number | null;
};

export type MeasurePartwiseContents = [
  Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  >,
];

/**
 * The `<measure>` element (partwise)
 *
 * Parent element: `<part>` (partwise)
 *
 * The `<measure>` element includes the basic musical data such as `<note>`s within a `<score-partwise version="4.0">` document.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-partwise/}
 */
export class MeasurePartwise implements XMLElement<'measure', MeasurePartwiseAttributes, MeasurePartwiseContents> {
  static readonly schema = {
    name: 'measure',
    attributes: {
      number: { type: 'required', value: { type: 'string' } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      implicit: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'non-controller': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      text: {
        type: 'optional',
        value: {
          type: 'not',
          include: { type: 'choices', choices: ['yes', { type: 'string' }] },
          exclude: { type: 'constant', value: '' },
        },
      },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [
      {
        type: 'label',
        label: 'values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Note,
              Backup,
              Forward,
              Direction,
              Attributes,
              Harmony,
              FiguredBass,
              Print,
              Sound,
              Listening,
              Barline,
              Grouping,
              Link,
              Bookmark,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = MeasurePartwise.schema;

  attributes: MeasurePartwiseAttributes;
  contents: MeasurePartwiseContents;

  constructor(opts?: { attributes?: Partial<MeasurePartwiseAttributes>; contents?: MeasurePartwiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasurePartwise.schema);
    this.contents = opts?.contents ?? operations.zero(MeasurePartwise.schema.contents);
  }
  /** Gets @type {MeasurePartwiseAttributes['number']}. */
  getNumber(): string {
    return this.attributes['number'];
  }
  /** Sets @type {MeasurePartwiseAttributes['number']}. */
  setNumber(number: string): MeasurePartwise {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {MeasurePartwiseAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {MeasurePartwiseAttributes['id']}. */
  setId(id: string | null): MeasurePartwise {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {MeasurePartwiseAttributes['implicit']}. */
  getImplicit(): 'yes' | 'no' | null {
    return this.attributes['implicit'];
  }
  /** Sets @type {MeasurePartwiseAttributes['implicit']}. */
  setImplicit(implicit: 'yes' | 'no' | null): MeasurePartwise {
    this.attributes['implicit'] = implicit;
    return this;
  }
  /** Gets @type {MeasurePartwiseAttributes['non-controller']}. */
  getNonController(): 'yes' | 'no' | null {
    return this.attributes['non-controller'];
  }
  /** Sets @type {MeasurePartwiseAttributes['non-controller']}. */
  setNonController(nonController: 'yes' | 'no' | null): MeasurePartwise {
    this.attributes['non-controller'] = nonController;
    return this;
  }
  /** Gets @type {MeasurePartwiseAttributes['text']}. */
  getText(): Exclude<'yes' | string, ''> | null {
    return this.attributes['text'];
  }
  /** Sets @type {MeasurePartwiseAttributes['text']}. */
  setText(text: Exclude<'yes' | string, ''> | null): MeasurePartwise {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {MeasurePartwiseAttributes['width']}. */
  getWidth(): number | null {
    return this.attributes['width'];
  }
  /** Sets @type {MeasurePartwiseAttributes['width']}. */
  setWidth(width: number | null): MeasurePartwise {
    this.attributes['width'] = width;
    return this;
  }
  /** Gets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
  getValues(): Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  > {
    return this.contents[0];
  }
  /** Sets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
  setValues(
    values: Array<
      | Note
      | Backup
      | Forward
      | Direction
      | Attributes
      | Harmony
      | FiguredBass
      | Print
      | Sound
      | Listening
      | Barline
      | Grouping
      | Link
      | Bookmark
    >
  ): this {
    this.contents[0] = values;
    return this;
  }
}

export type PartPartwiseAttributes = {
  /**
   * An IDREF back to a `<score-part>` element within the `<part-list>` element.
   */
  id: string;
};

export type PartPartwiseContents = [Array<MeasurePartwise>];

/**
 * The `<part>` element
 *
 * Parent element: `<score-partwise version="4.0">`
 *
 * The `<part>` element is the top level of musical organization below the `<score-partwise version="4.0">` document element. It
 * contains a sequence of `<measure>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-partwise/}
 */
export class PartPartwise implements XMLElement<'part', PartPartwiseAttributes, PartPartwiseContents> {
  static readonly schema = {
    name: 'part',
    attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
    contents: [{ type: 'label', label: 'measures', value: { type: 'oneOrMore', value: MeasurePartwise } }],
  } as const;

  readonly schema = PartPartwise.schema;

  attributes: PartPartwiseAttributes;
  contents: PartPartwiseContents;

  constructor(opts?: { attributes?: Partial<PartPartwiseAttributes>; contents?: PartPartwiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartPartwise.schema);
    this.contents = opts?.contents ?? operations.zero(PartPartwise.schema.contents);
  }
  /** Gets @type {PartPartwiseAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {PartPartwiseAttributes['id']}. */
  setId(id: string): PartPartwise {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Array<MeasurePartwise>}. */
  getMeasures(): Array<MeasurePartwise> {
    return this.contents[0];
  }
  /** Sets @type {Array<MeasurePartwise>}. */
  setMeasures(measures: Array<MeasurePartwise>): this {
    this.contents[0] = measures;
    return this;
  }
}

export type ScorePartwiseAttributes = {
  /**
   * The version attribute was added in Version 1.1 for the score-partwise and score-timewise documents. It provides
   * an easier way to get version information than through the MusicXML public ID. The default value is 1.0 to make
   * it possible for programs that handle later versions to distinguish earlier version files reliably. Programs
   * that write MusicXML 1.1 or later files should set this attribute.
   */
  version: '4.0';
};

export type ScorePartwiseContents = [
  Work | null,
  MovementNumber | null,
  MovementTitle | null,
  Identification | null,
  Defaults | null,
  Array<Credit>,
  PartList,
  Array<PartPartwise>,
];

/**
 * The `<score-partwise version="4.0">` element
 *
 * Parent elements: None
 *
 * The `<score-partwise version="4.0">` element is the root element for a partwise MusicXML score. It includes score header
 * information followed by a series of `<part>` elements with `<measure>` elements inside.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-partwise/}
 */
export class ScorePartwise implements XMLElement<'score-partwise', ScorePartwiseAttributes, ScorePartwiseContents> {
  static readonly schema = {
    name: 'score-partwise',
    attributes: { version: { type: 'constant', value: '4.0' } },
    contents: [
      { type: 'optional', value: Work },
      { type: 'optional', value: MovementNumber },
      { type: 'optional', value: MovementTitle },
      { type: 'optional', value: Identification },
      { type: 'optional', value: Defaults },
      { type: 'label', label: 'credits', value: { type: 'zeroOrMore', value: Credit } },
      { type: 'required', value: PartList },
      { type: 'label', label: 'parts', value: { type: 'oneOrMore', value: PartPartwise } },
    ],
  } as const;

  readonly schema = ScorePartwise.schema;

  attributes: ScorePartwiseAttributes;
  contents: ScorePartwiseContents;

  constructor(opts?: { attributes?: Partial<ScorePartwiseAttributes>; contents?: ScorePartwiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScorePartwise.schema);
    this.contents = opts?.contents ?? operations.zero(ScorePartwise.schema.contents);
  }
  /** Gets @type {ScorePartwiseAttributes['version']}. */
  getVersion(): '4.0' {
    return this.attributes['version'];
  }
  /** Sets @type {ScorePartwiseAttributes['version']}. */
  setVersion(version: '4.0'): ScorePartwise {
    this.attributes['version'] = version;
    return this;
  }
  /** Gets @type {Work | null}. */
  getWork(): Work | null {
    return this.contents[0];
  }
  /** Sets @type {Work | null}. */
  setWork(work: Work | null): this {
    this.contents[0] = work;
    return this;
  }
  /** Gets @type {MovementNumber | null}. */
  getMovementNumber(): MovementNumber | null {
    return this.contents[1];
  }
  /** Sets @type {MovementNumber | null}. */
  setMovementNumber(movementNumber: MovementNumber | null): this {
    this.contents[1] = movementNumber;
    return this;
  }
  /** Gets @type {MovementTitle | null}. */
  getMovementTitle(): MovementTitle | null {
    return this.contents[2];
  }
  /** Sets @type {MovementTitle | null}. */
  setMovementTitle(movementTitle: MovementTitle | null): this {
    this.contents[2] = movementTitle;
    return this;
  }
  /** Gets @type {Identification | null}. */
  getIdentification(): Identification | null {
    return this.contents[3];
  }
  /** Sets @type {Identification | null}. */
  setIdentification(identification: Identification | null): this {
    this.contents[3] = identification;
    return this;
  }
  /** Gets @type {Defaults | null}. */
  getDefaults(): Defaults | null {
    return this.contents[4];
  }
  /** Sets @type {Defaults | null}. */
  setDefaults(defaults: Defaults | null): this {
    this.contents[4] = defaults;
    return this;
  }
  /** Gets @type {Array<Credit>}. */
  getCredits(): Array<Credit> {
    return this.contents[5];
  }
  /** Sets @type {Array<Credit>}. */
  setCredits(credits: Array<Credit>): this {
    this.contents[5] = credits;
    return this;
  }
  /** Gets @type {PartList}. */
  getPartList(): PartList {
    return this.contents[6];
  }
  /** Sets @type {PartList}. */
  setPartList(partList: PartList): this {
    this.contents[6] = partList;
    return this;
  }
  /** Gets @type {Array<PartPartwise>}. */
  getParts(): Array<PartPartwise> {
    return this.contents[7];
  }
  /** Sets @type {Array<PartPartwise>}. */
  setParts(parts: Array<PartPartwise>): this {
    this.contents[7] = parts;
    return this;
  }
}

export type PartTimewiseAttributes = {
  /**
   * An IDREF back to a `<score-part>` element within the `<part-list>` element.
   */
  id: string;
};

export type PartTimewiseContents = [
  Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  >,
];

/**
 * The `<part>` element (timewise)
 *
 * Parent element: `<measure>` (timewise)
 *
 * The `<part>` element includes the basic musical data such as `<note>`s within a `<score-timewise>` document.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/part-partwise/}
 */
export class PartTimewise implements XMLElement<'part', PartTimewiseAttributes, PartTimewiseContents> {
  static readonly schema = {
    name: 'part',
    attributes: { id: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
    contents: [
      {
        type: 'label',
        label: 'values',
        value: {
          type: 'zeroOrMore',
          value: {
            type: 'choices',
            choices: [
              Note,
              Backup,
              Forward,
              Direction,
              Attributes,
              Harmony,
              FiguredBass,
              Print,
              Sound,
              Listening,
              Barline,
              Grouping,
              Link,
              Bookmark,
            ],
          },
        },
      },
    ],
  } as const;

  readonly schema = PartTimewise.schema;

  attributes: PartTimewiseAttributes;
  contents: PartTimewiseContents;

  constructor(opts?: { attributes?: Partial<PartTimewiseAttributes>; contents?: PartTimewiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, PartTimewise.schema);
    this.contents = opts?.contents ?? operations.zero(PartTimewise.schema.contents);
  }
  /** Gets @type {PartTimewiseAttributes['id']}. */
  getId(): string {
    return this.attributes['id'];
  }
  /** Sets @type {PartTimewiseAttributes['id']}. */
  setId(id: string): PartTimewise {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
  getValues(): Array<
    | Note
    | Backup
    | Forward
    | Direction
    | Attributes
    | Harmony
    | FiguredBass
    | Print
    | Sound
    | Listening
    | Barline
    | Grouping
    | Link
    | Bookmark
  > {
    return this.contents[0];
  }
  /** Sets @type {Array<Note | Backup | Forward | Direction | Attributes | Harmony | FiguredBass | Print | Sound | Listening | Barline | Grouping | Link | Bookmark>}. */
  setValues(
    values: Array<
      | Note
      | Backup
      | Forward
      | Direction
      | Attributes
      | Harmony
      | FiguredBass
      | Print
      | Sound
      | Listening
      | Barline
      | Grouping
      | Link
      | Bookmark
    >
  ): this {
    this.contents[0] = values;
    return this;
  }
}

export type MeasureTimewiseAttributes = {
  /**
   * The attribute that identifies the measure. Going from partwise to timewise, measures are grouped via this
   * attribute. In partwise files, it should be the same for measures in different parts that share the same left
   * barline.
   *
   * While often numeric, it does not have to be. Non-numeric values are typically used together with the implicit or
   * non-controlling attributes being set to "yes". For a pickup measure, the number attribute is typically set to "0"
   * and the implicit attribute is typically set to "yes".
   */
  number: string;
  /**
   * Specifies an ID that is unique to the entire document.
   */
  id: string | null;
  /**
   * Set to "yes" for measures where the measure number should never appear, such as pickup measures and the last half
   * of mid-measure repeats. The value is "no" if not specified.
   */
  implicit: 'yes' | 'no' | null;
  /**
   * Intended for use in multimetric music like the Don Giovanni minuet. If set to "yes", the left barline in this
   * measure does not coincide with the left barline of measures in other parts. The value is "no" if not specified.
   */
  'non-controller': 'yes' | 'no' | null;
  /**
   * If measure numbers are not unique within a part, this can cause problems for conversions between partwise and
   * timewise formats. The text attribute allows specification of displayed measure numbers that are different than
   * what is used in the number attribute. This attribute is ignored for measures where the implicit attribute is set
   * to "yes". Further details about measure numbering can be specified using the `<measure-numbering>` element.
   */
  text: Exclude<'yes' | string, ''> | null;
  /**
   * Measure width specified in tenths. These are the global tenths specified in the `<scaling>` element, not local
   * tenths as modified by the `<staff-size>` element. The width covers the entire measure from barline or system
   * start to barline or system end.
   */
  width: number | null;
};

export type MeasureTimewiseContents = [Array<PartTimewise>];

/**
 * The `<measure>` element (timewise)
 *
 * Parent element: `<score-timewise>`
 *
 * The `<measure>` element is the top level of musical organization below the `<score-timewise>` document element. It
 * contains a sequence of `<part>` elements.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/measure-timewise/}
 */
export class MeasureTimewise implements XMLElement<'measure', MeasureTimewiseAttributes, MeasureTimewiseContents> {
  static readonly schema = {
    name: 'measure',
    attributes: {
      number: { type: 'required', value: { type: 'string' } },
      id: { type: 'optional', value: { type: 'regex', pattern: /[A-Za-z_][A-Za-z0-9.-_]*/, zero: '_' } },
      implicit: { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      'non-controller': { type: 'optional', value: { type: 'choices', choices: ['yes', 'no'] } },
      text: {
        type: 'optional',
        value: {
          type: 'not',
          include: { type: 'choices', choices: ['yes', { type: 'string' }] },
          exclude: { type: 'constant', value: '' },
        },
      },
      width: { type: 'optional', value: { type: 'float', min: -Infinity, max: Infinity } },
    },
    contents: [{ type: 'label', label: 'parts', value: { type: 'oneOrMore', value: PartTimewise } }],
  } as const;

  readonly schema = MeasureTimewise.schema;

  attributes: MeasureTimewiseAttributes;
  contents: MeasureTimewiseContents;

  constructor(opts?: { attributes?: Partial<MeasureTimewiseAttributes>; contents?: MeasureTimewiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, MeasureTimewise.schema);
    this.contents = opts?.contents ?? operations.zero(MeasureTimewise.schema.contents);
  }
  /** Gets @type {MeasureTimewiseAttributes['number']}. */
  getNumber(): string {
    return this.attributes['number'];
  }
  /** Sets @type {MeasureTimewiseAttributes['number']}. */
  setNumber(number: string): MeasureTimewise {
    this.attributes['number'] = number;
    return this;
  }
  /** Gets @type {MeasureTimewiseAttributes['id']}. */
  getId(): string | null {
    return this.attributes['id'];
  }
  /** Sets @type {MeasureTimewiseAttributes['id']}. */
  setId(id: string | null): MeasureTimewise {
    this.attributes['id'] = id;
    return this;
  }
  /** Gets @type {MeasureTimewiseAttributes['implicit']}. */
  getImplicit(): 'yes' | 'no' | null {
    return this.attributes['implicit'];
  }
  /** Sets @type {MeasureTimewiseAttributes['implicit']}. */
  setImplicit(implicit: 'yes' | 'no' | null): MeasureTimewise {
    this.attributes['implicit'] = implicit;
    return this;
  }
  /** Gets @type {MeasureTimewiseAttributes['non-controller']}. */
  getNonController(): 'yes' | 'no' | null {
    return this.attributes['non-controller'];
  }
  /** Sets @type {MeasureTimewiseAttributes['non-controller']}. */
  setNonController(nonController: 'yes' | 'no' | null): MeasureTimewise {
    this.attributes['non-controller'] = nonController;
    return this;
  }
  /** Gets @type {MeasureTimewiseAttributes['text']}. */
  getText(): Exclude<'yes' | string, ''> | null {
    return this.attributes['text'];
  }
  /** Sets @type {MeasureTimewiseAttributes['text']}. */
  setText(text: Exclude<'yes' | string, ''> | null): MeasureTimewise {
    this.attributes['text'] = text;
    return this;
  }
  /** Gets @type {MeasureTimewiseAttributes['width']}. */
  getWidth(): number | null {
    return this.attributes['width'];
  }
  /** Sets @type {MeasureTimewiseAttributes['width']}. */
  setWidth(width: number | null): MeasureTimewise {
    this.attributes['width'] = width;
    return this;
  }
  /** Gets @type {Array<PartTimewise>}. */
  getParts(): Array<PartTimewise> {
    return this.contents[0];
  }
  /** Sets @type {Array<PartTimewise>}. */
  setParts(parts: Array<PartTimewise>): this {
    this.contents[0] = parts;
    return this;
  }
}

export type ScoreTimewiseAttributes = {
  /**
   * The version attribute was added in Version 1.1 for the score-partwise and score-timewise documents. It provides
   * an easier way to get version information than through the MusicXML public ID. The default value is 1.0 to make
   * it possible for programs that handle later versions to distinguish earlier version files reliably. Programs
   * that write MusicXML 1.1 or later files should set this attribute.
   */
  version: '4.0';
};

export type ScoreTimewiseContents = [
  Work | null,
  MovementNumber | null,
  MovementTitle | null,
  Identification | null,
  Defaults | null,
  Array<Credit>,
  PartList,
  Array<MeasureTimewise>,
];

/**
 * The `<score-timewise>` element
 *
 * Parent elements: None
 *
 * The `<score-timewise>` element is the root element for a timewise MusicXML score. It includes score header
 * information followed by a series of `<measure>` elements with `<part>` elements inside.
 *
 * {@link https://www.w3.org/2021/06/musicxml40/musicxml-reference/elements/score-timewise/}
 */
export class ScoreTimewise implements XMLElement<'score-timewise', ScoreTimewiseAttributes, ScoreTimewiseContents> {
  static readonly schema = {
    name: 'score-timewise',
    attributes: { version: { type: 'constant', value: '4.0' } },
    contents: [
      { type: 'optional', value: Work },
      { type: 'optional', value: MovementNumber },
      { type: 'optional', value: MovementTitle },
      { type: 'optional', value: Identification },
      { type: 'optional', value: Defaults },
      { type: 'label', label: 'credits', value: { type: 'zeroOrMore', value: Credit } },
      { type: 'required', value: PartList },
      { type: 'label', label: 'measures', value: { type: 'oneOrMore', value: MeasureTimewise } },
    ],
  } as const;

  readonly schema = ScoreTimewise.schema;

  attributes: ScoreTimewiseAttributes;
  contents: ScoreTimewiseContents;

  constructor(opts?: { attributes?: Partial<ScoreTimewiseAttributes>; contents?: ScoreTimewiseContents }) {
    this.attributes = operations.merge(opts?.attributes || {}, ScoreTimewise.schema);
    this.contents = opts?.contents ?? operations.zero(ScoreTimewise.schema.contents);
  }
  /** Gets @type {ScoreTimewiseAttributes['version']}. */
  getVersion(): '4.0' {
    return this.attributes['version'];
  }
  /** Sets @type {ScoreTimewiseAttributes['version']}. */
  setVersion(version: '4.0'): ScoreTimewise {
    this.attributes['version'] = version;
    return this;
  }
  /** Gets @type {Work | null}. */
  getWork(): Work | null {
    return this.contents[0];
  }
  /** Sets @type {Work | null}. */
  setWork(work: Work | null): this {
    this.contents[0] = work;
    return this;
  }
  /** Gets @type {MovementNumber | null}. */
  getMovementNumber(): MovementNumber | null {
    return this.contents[1];
  }
  /** Sets @type {MovementNumber | null}. */
  setMovementNumber(movementNumber: MovementNumber | null): this {
    this.contents[1] = movementNumber;
    return this;
  }
  /** Gets @type {MovementTitle | null}. */
  getMovementTitle(): MovementTitle | null {
    return this.contents[2];
  }
  /** Sets @type {MovementTitle | null}. */
  setMovementTitle(movementTitle: MovementTitle | null): this {
    this.contents[2] = movementTitle;
    return this;
  }
  /** Gets @type {Identification | null}. */
  getIdentification(): Identification | null {
    return this.contents[3];
  }
  /** Sets @type {Identification | null}. */
  setIdentification(identification: Identification | null): this {
    this.contents[3] = identification;
    return this;
  }
  /** Gets @type {Defaults | null}. */
  getDefaults(): Defaults | null {
    return this.contents[4];
  }
  /** Sets @type {Defaults | null}. */
  setDefaults(defaults: Defaults | null): this {
    this.contents[4] = defaults;
    return this;
  }
  /** Gets @type {Array<Credit>}. */
  getCredits(): Array<Credit> {
    return this.contents[5];
  }
  /** Sets @type {Array<Credit>}. */
  setCredits(credits: Array<Credit>): this {
    this.contents[5] = credits;
    return this;
  }
  /** Gets @type {PartList}. */
  getPartList(): PartList {
    return this.contents[6];
  }
  /** Sets @type {PartList}. */
  setPartList(partList: PartList): this {
    this.contents[6] = partList;
    return this;
  }
  /** Gets @type {Array<MeasureTimewise>}. */
  getMeasures(): Array<MeasureTimewise> {
    return this.contents[7];
  }
  /** Sets @type {Array<MeasureTimewise>}. */
  setMeasures(measures: Array<MeasureTimewise>): this {
    this.contents[7] = measures;
    return this;
  }
}
